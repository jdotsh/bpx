"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/studio/page",{

/***/ "(app-pages-browser)/./components/bpmn/BpmnStudioFixed.tsx":
/*!*********************************************!*\
  !*** ./components/bpmn/BpmnStudioFixed.tsx ***!
  \*********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BpmnStudioFixed: function() { return /* binding */ BpmnStudioFixed; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var bpmn_js_lib_Modeler__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! bpmn-js/lib/Modeler */ \"(app-pages-browser)/./node_modules/bpmn-js/lib/Modeler.js\");\n/* harmony import */ var _bpmn_toolbar__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./bpmn-toolbar */ \"(app-pages-browser)/./components/bpmn/bpmn-toolbar.tsx\");\n/* harmony import */ var _bpmn_elements_palette__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./bpmn-elements-palette */ \"(app-pages-browser)/./components/bpmn/bpmn-elements-palette.tsx\");\n/* harmony import */ var _XmlViewerModal__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./XmlViewerModal */ \"(app-pages-browser)/./components/bpmn/XmlViewerModal.tsx\");\n/* harmony import */ var _components_theme_provider__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @/components/theme-provider */ \"(app-pages-browser)/./components/theme-provider.tsx\");\n/* __next_internal_client_entry_do_not_use__ BpmnStudioFixed auto */ \nvar _s = $RefreshSig$();\n\n\n\n\n\n\n// NO CSS imports here - they are in globals.css\nconst DEFAULT_BPMN = '<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n<bpmn2:definitions xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" \\n  xmlns:bpmn2=\"http://www.omg.org/spec/BPMN/20100524/MODEL\" \\n  xmlns:bpmndi=\"http://www.omg.org/spec/BPMN/20100524/DI\" \\n  xmlns:dc=\"http://www.omg.org/spec/DD/20100524/DC\" \\n  xmlns:di=\"http://www.omg.org/spec/DD/20100524/DI\" \\n  id=\"sample-diagram\" \\n  targetNamespace=\"http://bpmn.io/schema/bpmn\">\\n  <bpmn2:process id=\"Process_1\" isExecutable=\"false\">\\n    <bpmn2:startEvent id=\"StartEvent_1\" name=\"Start\"/>\\n  </bpmn2:process>\\n  <bpmndi:BPMNDiagram id=\"BPMNDiagram_1\">\\n    <bpmndi:BPMNPlane id=\"BPMNPlane_1\" bpmnElement=\"Process_1\">\\n      <bpmndi:BPMNShape id=\"_BPMNShape_StartEvent_2\" bpmnElement=\"StartEvent_1\">\\n        <dc:Bounds height=\"36.0\" width=\"36.0\" x=\"412.0\" y=\"240.0\"/>\\n      </bpmndi:BPMNShape>\\n    </bpmndi:BPMNPlane>\\n  </bpmndi:BPMNDiagram>\\n</bpmn2:definitions>';\nfunction BpmnStudioFixed() {\n    _s();\n    const containerRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const modelerRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const fileInputRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const [isReady, setIsReady] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [canUndo, setCanUndo] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [canRedo, setCanRedo] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const { theme, setTheme } = (0,_components_theme_provider__WEBPACK_IMPORTED_MODULE_5__.useTheme)();\n    const styleElementRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const [zoomLevel, setZoomLevel] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(100);\n    const [saving, setSaving] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [activeTool, setActiveTool] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(undefined);\n    const [isMeetingMode, setIsMeetingMode] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [isMinimapOpen, setIsMinimapOpen] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [showGrid, setShowGrid] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(true);\n    const [showPreview, setShowPreview] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [showXmlViewer, setShowXmlViewer] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [currentXml, setCurrentXml] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"\");\n    const [selectedElements, setSelectedElements] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    // Helper function to apply styles (needs to be defined before useEffect)\n    const applyBpmnStyles = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((modeler, currentTheme)=>{\n        if (!modeler) return;\n        try {\n            const canvas = modeler.get(\"canvas\");\n            if (!canvas) return;\n            // Get the container and ensure SVG is available\n            const container = canvas._container || canvas.getContainer();\n            const svg = (container === null || container === void 0 ? void 0 : container.querySelector(\"svg\")) || canvas._svg;\n            // Check if SVG element exists and has necessary methods\n            if (!svg || typeof svg.createSVGMatrix !== \"function\") {\n                console.warn(\"SVG element not ready, delaying style application\");\n                setTimeout(()=>applyBpmnStyles(modeler, currentTheme), 100);\n                return;\n            }\n            // Reuse existing style element or create new one\n            let style = styleElementRef.current;\n            if (!style) {\n                style = document.createElement(\"style\");\n                style.id = \"bpmn-custom-styles\";\n                styleElementRef.current = style;\n            }\n            // Define styles based on current theme\n            const isDark = currentTheme === \"dark\";\n            console.log(\"Applying BPMN styles for theme:\", currentTheme, \"isDark:\", isDark);\n            style.textContent = '\\n      /* Ensure proper pointer events for drag and drop */\\n      .djs-container {\\n        pointer-events: auto !important;\\n      }\\n      \\n      .djs-element > * {\\n        pointer-events: all !important;\\n      }\\n      \\n      .djs-hit {\\n        pointer-events: all !important;\\n        fill: transparent !important;\\n        stroke: transparent !important;\\n      }\\n      \\n      .djs-shape .djs-hit {\\n        fill: transparent !important;\\n        pointer-events: all !important;\\n      }\\n      \\n      .djs-drag-active {\\n        pointer-events: all !important;\\n      }\\n      \\n      /* === ACTIVITIES (Tasks, Sub-processes) === */\\n      \\n      /* Task rectangles - MAXIMUM SPECIFICITY */\\n      .djs-shape .djs-visual > rect,\\n      .djs-element[data-element-id*=\"Task\"] rect,\\n      .djs-element[data-element-id*=\"Activity\"] rect,\\n      rect.djs-hit,\\n      rect.djs-outline {\\n        stroke: '.concat(isDark ? \"#ffffff\" : \"#000000\", \" !important;\\n        stroke-dasharray: none !important;\\n        stroke-width: 2px !important;\\n        fill: \").concat(isDark ? \"#1f2937\" : \"#ffffff\", \" !important;\\n      }\\n      \\n      /* All rect elements in shapes (fallback) */\\n      .djs-shape rect {\\n        stroke: \").concat(isDark ? \"#ffffff\" : \"#000000\", \" !important;\\n        fill: \").concat(isDark ? \"#1f2937\" : \"#ffffff\", \" !important;\\n      }\\n      \\n      /* NUCLEAR OPTION: Override ANY rect with black stroke in dark mode */\\n      \").concat(isDark ? '\\n        rect[stroke=\"#000000\"],\\n        rect[stroke=\"black\"],\\n        rect[stroke=\"rgb(0, 0, 0)\"],\\n        rect[style*=\"stroke: rgb(0, 0, 0)\"],\\n        rect[style*=\"stroke:#000000\"],\\n        rect[style*=\"stroke: #000000\"],\\n        rect[style*=\"stroke:black\"] {\\n          stroke: #ffffff !important;\\n          stroke-opacity: 1 !important;\\n        }\\n        \\n        /* SUPER NUCLEAR: Target Tasks by ANY means necessary */\\n        g[data-element-id*=\"Task\"] rect,\\n        g[data-element-id*=\"Activity\"] rect,\\n        .djs-group[data-element-id*=\"Task\"] rect,\\n        g.djs-element rect,\\n        g.djs-shape rect,\\n        svg rect:not([fill=\"none\"]):not([fill=\"transparent\"]) {\\n          stroke: #ffffff !important;\\n          stroke-opacity: 1 !important;\\n          stroke-width: 2px !important;\\n        }\\n        \\n        /* Target the visual rect specifically */\\n        g[data-element-id*=\"Task\"] > .djs-visual > rect,\\n        g[data-element-id*=\"Activity\"] > .djs-visual > rect {\\n          stroke: #ffffff !important;\\n          fill: #1f2937 !important;\\n          stroke-opacity: 1 !important;\\n        }\\n      ' : \"\", '\\n      \\n      /* Task type icons (user, service, script, etc) */\\n      .djs-element[data-element-id*=\"Task\"] .djs-visual > path,\\n      .djs-element[data-element-id*=\"Task\"] .djs-visual > g > path {\\n        stroke: ').concat(isDark ? \"#ffffff\" : \"#000000\", \" !important;\\n        fill: \").concat(isDark ? \"#ffffff\" : \"#000000\", ' !important;\\n      }\\n      \\n      /* Sub-process markers (+) */\\n      .djs-element[data-element-id*=\"SubProcess\"] .djs-visual > path {\\n        stroke: ').concat(isDark ? \"#ffffff\" : \"#000000\", \" !important;\\n        fill: none !important;\\n      }\\n      \\n      /* === EVENTS === */\\n      \\n      /* Event circles (outer) */\\n      .djs-shape .djs-visual > circle {\\n        stroke: \").concat(isDark ? \"#ffffff\" : \"#000000\", \" !important;\\n        stroke-width: 2px !important;\\n        fill: \").concat(isDark ? \"#1f2937\" : \"#ffffff\", \" !important;\\n      }\\n      \\n      /* All circle elements in shapes (fallback) */\\n      .djs-shape circle {\\n        stroke: \").concat(isDark ? \"#ffffff\" : \"#000000\", \" !important;\\n        fill: \").concat(isDark ? \"#1f2937\" : \"#ffffff\", \" !important;\\n      }\\n      \\n      /* Event inner circles (for intermediate/boundary) */\\n      .djs-shape .djs-visual > g > circle {\\n        stroke: \").concat(isDark ? \"#ffffff\" : \"#000000\", \" !important;\\n        fill: \").concat(isDark ? \"#1f2937\" : \"#ffffff\", ' !important;\\n      }\\n      \\n      /* Event type icons (message, timer, error, signal, etc) */\\n      .djs-element[data-element-id*=\"Event\"] .djs-visual > g > path,\\n      .djs-element[data-element-id*=\"Event\"] .djs-visual > path {\\n        stroke: ').concat(isDark ? \"#ffffff\" : \"#000000\", \" !important;\\n        fill: \").concat(isDark ? \"#ffffff\" : \"#000000\", ' !important;\\n        stroke-width: 1px !important;\\n      }\\n      \\n      /* Boundary events (attached to activities) */\\n      .djs-element[data-element-id*=\"BoundaryEvent\"] .djs-visual > circle {\\n        stroke: ').concat(isDark ? \"#ffffff\" : \"#000000\", \" !important;\\n        fill: \").concat(isDark ? \"#1f2937\" : \"#ffffff\", \" !important;\\n      }\\n      \\n      /* === GATEWAYS === */\\n      \\n      /* Gateway diamonds */\\n      .djs-shape .djs-visual > polygon {\\n        stroke: \").concat(isDark ? \"#ffffff\" : \"#000000\", \" !important;\\n        stroke-width: 2px !important;\\n        fill: \").concat(isDark ? \"#1f2937\" : \"#ffffff\", \" !important;\\n      }\\n      \\n      /* All polygon elements in shapes (fallback) */\\n      .djs-shape polygon {\\n        stroke: \").concat(isDark ? \"#ffffff\" : \"#000000\", \" !important;\\n        fill: \").concat(isDark ? \"#1f2937\" : \"#ffffff\", ' !important;\\n      }\\n      \\n      /* Gateway symbols (X, +, O, etc) */\\n      .djs-element[data-element-id*=\"Gateway\"] .djs-visual > g > path,\\n      .djs-element[data-element-id*=\"Gateway\"] .djs-visual > path {\\n        stroke: ').concat(isDark ? \"#ffffff\" : \"#000000\", ' !important;\\n        fill: none !important;\\n        stroke-width: 2px !important;\\n      }\\n      \\n      /* Complex gateway star */\\n      .djs-element[data-element-id*=\"ComplexGateway\"] .djs-visual > path {\\n        fill: ').concat(isDark ? \"#ffffff\" : \"#000000\", \" !important;\\n        stroke: \").concat(isDark ? \"#ffffff\" : \"#000000\", ' !important;\\n      }\\n      \\n      /* === DATA OBJECTS === */\\n      \\n      /* Data object shapes */\\n      .djs-element[data-element-id*=\"DataObject\"] .djs-visual > path,\\n      .djs-element[data-element-id*=\"DataStore\"] .djs-visual > path {\\n        stroke: ').concat(isDark ? \"#ffffff\" : \"#000000\", \" !important;\\n        fill: \").concat(isDark ? \"#1f2937\" : \"#ffffff\", ' !important;\\n      }\\n      \\n      /* Data collection markers */\\n      .djs-element[data-element-id*=\"DataObject\"] .djs-visual > g > path {\\n        stroke: ').concat(isDark ? \"#ffffff\" : \"#000000\", ' !important;\\n        fill: none !important;\\n      }\\n      \\n      /* === PARTICIPANTS (Pools/Lanes) === */\\n      \\n      /* Pool/Lane containers */\\n      .djs-element[data-element-id*=\"Participant\"] .djs-visual > rect,\\n      .djs-element[data-element-id*=\"Lane\"] .djs-visual > rect {\\n        stroke: ').concat(isDark ? \"#ffffff\" : \"#000000\", \" !important;\\n        fill: \").concat(isDark ? \"#1f2937\" : \"#ffffff\", ' !important;\\n      }\\n      \\n      /* Pool/Lane headers */\\n      .djs-element[data-element-id*=\"Participant\"] .djs-visual > g > rect:first-child,\\n      .djs-element[data-element-id*=\"Lane\"] .djs-visual > g > rect:first-child {\\n        fill: ').concat(isDark ? \"#374151\" : \"#e5e7eb\", \" !important;\\n      }\\n      \\n      /* === CONNECTIONS === */\\n      \\n      /* Sequence flows and message flows */\\n      .djs-connection .djs-visual > path {\\n        stroke: \").concat(isDark ? \"#ffffff\" : \"#000000\", \" !important;\\n        fill: none !important;\\n      }\\n      \\n      /* Arrow heads */\\n      .djs-connection .djs-visual > polyline,\\n      .djs-connection .djs-visual > polygon {\\n        stroke: \").concat(isDark ? \"#ffffff\" : \"#000000\", \" !important;\\n        fill: \").concat(isDark ? \"#ffffff\" : \"#000000\", ' !important;\\n      }\\n      \\n      /* Association/Data association (dotted lines) */\\n      .djs-connection[data-element-id*=\"Association\"] .djs-visual > path {\\n        stroke: ').concat(isDark ? \"#ffffff\" : \"#000000\", ' !important;\\n        stroke-dasharray: 5, 5 !important;\\n      }\\n      \\n      /* Message flows (dashed lines) */\\n      .djs-connection[data-element-id*=\"MessageFlow\"] .djs-visual > path {\\n        stroke: ').concat(isDark ? \"#ffffff\" : \"#000000\", ' !important;\\n        stroke-dasharray: 10, 5 !important;\\n      }\\n      \\n      /* === ARTIFACTS === */\\n      \\n      /* Text annotations */\\n      .djs-element[data-element-id*=\"TextAnnotation\"] .djs-visual > rect {\\n        stroke: ').concat(isDark ? \"#ffffff\" : \"#000000\", ' !important;\\n        fill: none !important;\\n        stroke-dasharray: 5, 5 !important;\\n      }\\n      \\n      /* Groups */\\n      .djs-element[data-element-id*=\"Group\"] .djs-visual > rect {\\n        stroke: ').concat(isDark ? \"#ffffff\" : \"#000000\", \" !important;\\n        fill: none !important;\\n        stroke-dasharray: 8, 3, 1, 3 !important;\\n        stroke-width: 1px !important;\\n      }\\n      \\n      /* === TEXT LABELS === */\\n      \\n      /* All text elements */\\n      .djs-label,\\n      .djs-shape .djs-visual text,\\n      .djs-element text,\\n      text {\\n        fill: \").concat(isDark ? \"#ffffff\" : \"#000000\", \" !important;\\n      }\\n      \\n      /* Label backgrounds should be transparent */\\n      .djs-label .djs-visual rect {\\n        fill: transparent !important;\\n        stroke: none !important;\\n      }\\n      \\n      /* === GENERIC FALLBACKS === */\\n      \\n      /* Any other path elements */\\n      .djs-shape .djs-visual > path {\\n        stroke: \").concat(isDark ? \"#ffffff\" : \"#000000\", ' !important;\\n      }\\n      \\n      /* All paths with stroke attribute */\\n      path[stroke]:not([stroke=\"none\"]) {\\n        stroke: ').concat(isDark ? \"#ffffff\" : \"#000000\", \" !important;\\n      }\\n      \\n      /* All ellipse elements */\\n      ellipse {\\n        stroke: \").concat(isDark ? \"#ffffff\" : \"#000000\", \" !important;\\n        fill: \").concat(isDark ? \"#1f2937\" : \"#ffffff\", \" !important;\\n      }\\n      \\n      /* All line elements */\\n      line {\\n        stroke: \").concat(isDark ? \"#ffffff\" : \"#000000\", ' !important;\\n      }\\n      \\n      /* Filled path elements (icons, markers) */\\n      .djs-shape .djs-visual > g > path[fill]:not([fill=\"none\"]) {\\n        fill: ').concat(isDark ? \"#ffffff\" : \"#000000\", ' !important;\\n      }\\n      \\n      /* Catch all SVG shapes that might have black stroke in light mode */\\n      .djs-visual > *[stroke=\"#000000\"],\\n      .djs-visual > *[stroke=\"black\"],\\n      .djs-visual > *[stroke=\"rgb(0,0,0)\"],\\n      .djs-visual > *[stroke=\"rgb(0, 0, 0)\"] {\\n        stroke: ').concat(isDark ? \"#ffffff\" : \"#000000\", ' !important;\\n      }\\n      \\n      /* Catch all nested elements with black stroke */\\n      .djs-visual *[stroke=\"#000000\"],\\n      .djs-visual *[stroke=\"black\"],\\n      .djs-visual *[stroke=\"rgb(0,0,0)\"],\\n      .djs-visual *[stroke=\"rgb(0, 0, 0)\"] {\\n        stroke: ').concat(isDark ? \"#ffffff\" : \"#000000\", ' !important;\\n      }\\n      \\n      /* Catch all SVG shapes that might have white fill in light mode */\\n      .djs-visual > *[fill=\"#ffffff\"],\\n      .djs-visual > *[fill=\"white\"],\\n      .djs-visual > *[fill=\"rgb(255,255,255)\"],\\n      .djs-visual > *[fill=\"rgb(255, 255, 255)\"] {\\n        fill: ').concat(isDark ? \"#1f2937\" : \"#ffffff\", ' !important;\\n      }\\n      \\n      /* Catch all nested elements with white fill */\\n      .djs-visual *[fill=\"#ffffff\"],\\n      .djs-visual *[fill=\"white\"],\\n      .djs-visual *[fill=\"rgb(255,255,255)\"],\\n      .djs-visual *[fill=\"rgb(255, 255, 255)\"] {\\n        fill: ').concat(isDark ? \"#1f2937\" : \"#ffffff\", \" !important;\\n      }\\n      \\n      /* Direct editing text */\\n      .djs-direct-editing-parent {\\n        color: \").concat(isDark ? \"#ffffff\" : \"#000000\", \" !important;\\n        background: transparent !important;\\n      }\\n      \\n      .djs-direct-editing-content {\\n        color: \").concat(isDark ? \"#ffffff\" : \"#000000\", \" !important;\\n        background: transparent !important;\\n        caret-color: \").concat(isDark ? \"#ffffff\" : \"#000000\", ' !important;\\n      }\\n      \\n      /* Ensure the editing box itself is transparent */\\n      .djs-direct-editing-parent > div {\\n        background: transparent !important;\\n      }\\n      \\n      /* Contenteditable elements should be transparent */\\n      [contenteditable=\"true\"] {\\n        background: transparent !important;\\n        outline: none !important;\\n      }\\n      \\n      /* Focus state for editing */\\n      .djs-direct-editing-content:focus {\\n        background: transparent !important;\\n        outline: 1px dotted ').concat(isDark ? \"#60a5fa\" : \"#2563eb\", \" !important;\\n      }\\n      \\n      /* === SELECTION VISIBILITY FIX === */\\n      \\n      /* Selected element outline - make it highly visible */\\n      .djs-outline {\\n        stroke: \").concat(isDark ? \"#60a5fa\" : \"#2563eb\", \" !important;\\n        stroke-width: 3px !important;\\n        stroke-dasharray: 5, 5 !important;\\n        fill: none !important;\\n        fill-opacity: 0 !important;\\n        opacity: 1 !important;\\n      }\\n      \\n      /* Outline paths and polygons must be transparent */\\n      .djs-outline path,\\n      .djs-outline polygon,\\n      .djs-outline polyline,\\n      .djs-outline rect,\\n      .djs-outline circle,\\n      .djs-outline ellipse {\\n        fill: none !important;\\n        fill-opacity: 0 !important;\\n      }\\n      \\n      /* Selection box overlay - MUST BE TRANSPARENT */\\n      .djs-lasso-overlay {\\n        stroke: \").concat(isDark ? \"#60a5fa\" : \"#2563eb\", \" !important;\\n        stroke-width: 2px !important;\\n        fill: \").concat(isDark ? \"rgba(96, 165, 250, 0.1)\" : \"rgba(37, 99, 235, 0.1)\", \" !important;\\n        opacity: 1 !important;\\n      }\\n      \\n      /* Multi-select marquee - transparent background */\\n      .djs-marquee {\\n        fill: \").concat(isDark ? \"rgba(96, 165, 250, 0.1)\" : \"rgba(37, 99, 235, 0.1)\", \" !important;\\n        stroke: \").concat(isDark ? \"#60a5fa\" : \"#2563eb\", \" !important;\\n        stroke-width: 1px !important;\\n        stroke-dasharray: 5, 5 !important;\\n      }\\n      \\n      /* Selected elements get a highlight */\\n      .djs-element.selected .djs-outline {\\n        stroke: \").concat(isDark ? \"#60a5fa\" : \"#2563eb\", \" !important;\\n        stroke-width: 3px !important;\\n        opacity: 1 !important;\\n      }\\n      \\n      /* Hover state for better visibility */\\n      .djs-element.hover .djs-outline {\\n        stroke: \").concat(isDark ? \"#93c5fd\" : \"#60a5fa\", \" !important;\\n        stroke-width: 2px !important;\\n        opacity: 0.8 !important;\\n      }\\n      \\n      /* Selection frame around elements */\\n      .djs-select-visual {\\n        stroke: \").concat(isDark ? \"#60a5fa\" : \"#2563eb\", \" !important;\\n        stroke-width: 2px !important;\\n        stroke-dasharray: 5, 5 !important;\\n        fill: none !important;\\n      }\\n      \\n      /* Multi-selection visual */\\n      .djs-multiselect-visual {\\n        stroke: \").concat(isDark ? \"#60a5fa\" : \"#2563eb\", \" !important;\\n        stroke-width: 2px !important;\\n        fill: \").concat(isDark ? \"rgba(96, 165, 250, 0.05)\" : \"rgba(37, 99, 235, 0.05)\", \" !important;\\n      }\\n      \\n      /* Resize handles - small corner squares */\\n      .djs-resizer-visual,\\n      .djs-resizer-hit {\\n        stroke: \").concat(isDark ? \"#60a5fa\" : \"#2563eb\", \" !important;\\n        fill: transparent !important;\\n        opacity: 1 !important;\\n      }\\n      \\n      /* Resize handle corners - the actual squares */\\n      .djs-resizer-visual rect,\\n      .djs-resizer-hit rect {\\n        fill: \").concat(isDark ? \"#60a5fa\" : \"#2563eb\", \" !important;\\n        stroke: \").concat(isDark ? \"#ffffff\" : \"#000000\", \" !important;\\n        stroke-width: 1px !important;\\n        width: 6px !important;\\n        height: 6px !important;\\n      }\\n      \\n      /* Selection frame - MUST BE TRANSPARENT */\\n      .djs-selection-frame {\\n        fill: transparent !important;\\n        stroke: \").concat(isDark ? \"#60a5fa\" : \"#2563eb\", \" !important;\\n        stroke-width: 2px !important;\\n        stroke-dasharray: 5, 5 !important;\\n      }\\n      \\n      /* Selection visual box - TRANSPARENT BACKGROUND */\\n      .djs-selection-visual {\\n        fill: transparent !important;\\n        stroke: \").concat(isDark ? \"#60a5fa\" : \"#2563eb\", \" !important;\\n      }\\n      \\n      /* Selection overlay background - CRITICAL FIX */\\n      .djs-overlay-container .djs-overlay {\\n        background: transparent !important;\\n      }\\n      \\n      /* Any selection-related overlays must be transparent */\\n      .djs-overlay-container > * {\\n        background: transparent !important;\\n      }\\n      \\n      /* Lasso selection area */\\n      .djs-lasso-overlay rect {\\n        fill: \").concat(isDark ? \"rgba(96, 165, 250, 0.1)\" : \"rgba(37, 99, 235, 0.1)\", \" !important;\\n        stroke: \").concat(isDark ? \"#60a5fa\" : \"#2563eb\", \" !important;\\n      }\\n      \\n      /* Drag selection marquee box */\\n      .djs-drag-marquee {\\n        fill: \").concat(isDark ? \"rgba(96, 165, 250, 0.1)\" : \"rgba(37, 99, 235, 0.1)\", \" !important;\\n        stroke: \").concat(isDark ? \"#60a5fa\" : \"#2563eb\", \" !important;\\n        stroke-width: 1px !important;\\n        stroke-dasharray: 5, 5 !important;\\n      }\\n      \\n      /* Group selection frame */\\n      .djs-group-selector {\\n        fill: transparent !important;\\n        stroke: \").concat(isDark ? \"#60a5fa\" : \"#2563eb\", \" !important;\\n        stroke-width: 2px !important;\\n        stroke-dasharray: 5, 5 !important;\\n      }\\n      \\n      /* Selected state visual feedback */\\n      .selected > .djs-visual {\\n        filter: \").concat(isDark ? \"drop-shadow(0 0 4px rgba(96, 165, 250, 0.5))\" : \"drop-shadow(0 0 4px rgba(37, 99, 235, 0.3))\", \" !important;\\n      }\\n      \\n      /* Make sure selection doesn't hide elements */\\n      .djs-overlay {\\n        pointer-events: none !important;\\n      }\\n      \\n      .djs-overlay.djs-lasso-overlay {\\n        pointer-events: all !important;\\n      }\\n      \\n      /* AGGRESSIVE FIX: Force ALL selection rectangles to be transparent */\\n      .selected rect:not(.djs-visual rect) {\\n        fill: transparent !important;\\n      }\\n      \\n      /* Selection indicators should only be outlines */\\n      .djs-outline rect,\\n      .djs-selection rect,\\n      .djs-select rect {\\n        fill: transparent !important;\\n        stroke: \").concat(isDark ? \"#60a5fa\" : \"#2563eb\", ' !important;\\n        stroke-width: 2px !important;\\n      }\\n      \\n      /* Ensure no background on selection visuals */\\n      [class*=\"select\"] rect:not(.djs-visual rect) {\\n        fill: transparent !important;\\n      }\\n      \\n      /* Remove any fill from selection frames */\\n      .djs-frame rect {\\n        fill: transparent !important;\\n      }\\n      \\n      /* Canvas background - target multiple selectors for better coverage */\\n      .djs-container,\\n      .djs-container svg,\\n      .djs-viewport,\\n      .djs-plane {\\n        background-color: ').concat(isDark ? \"#111827\" : \"#f9fafb\", \" !important;\\n      }\\n      \\n      /* Grid pattern background */\\n      .grid-background {\\n        background-image: \\n          linear-gradient(\").concat(isDark ? \"rgba(255,255,255,0.03)\" : \"rgba(0,0,0,0.03)\", \" 1px, transparent 1px),\\n          linear-gradient(90deg, \").concat(isDark ? \"rgba(255,255,255,0.03)\" : \"rgba(0,0,0,0.03)\", \" 1px, transparent 1px);\\n        background-size: 20px 20px;\\n        background-position: 0 0, 0 0;\\n      }\\n      \\n      /* Apply grid to canvas when enabled */\\n      .djs-container.show-grid > svg {\\n        background-image: \\n          linear-gradient(\").concat(isDark ? \"rgba(255,255,255,0.05)\" : \"rgba(0,0,0,0.05)\", \" 1px, transparent 1px),\\n          linear-gradient(90deg, \").concat(isDark ? \"rgba(255,255,255,0.05)\" : \"rgba(0,0,0,0.05)\", \" 1px, transparent 1px);\\n        background-size: 20px 20px;\\n        background-position: 0 0, 0 0;\\n        background-color: \").concat(isDark ? \"#111827\" : \"#f9fafb\", \" !important;\\n      }\\n      \\n      /* Ensure the SVG itself has the right background */\\n      .djs-container > svg {\\n        background-color: \").concat(isDark ? \"#111827\" : \"#f9fafb\", \" !important;\\n      }\\n      \\n      /* Hide native BPMN.js palette since we use custom */\\n      .djs-palette {\\n        display: none !important;\\n      }\\n      \\n      /* === ULTIMATE FALLBACK - Catch ANY element that might be missed === */\\n      \\n      /* AGGRESSIVE: Force all strokes in djs elements */\\n      .djs-container svg * {\\n        stroke: \").concat(isDark ? \"#ffffff\" : \"#000000\", ' !important;\\n      }\\n      \\n      /* But preserve transparent strokes */\\n      .djs-container svg *[stroke=\"none\"],\\n      .djs-container svg *[stroke=\"transparent\"],\\n      .djs-container svg *[stroke-opacity=\"0\"] {\\n        stroke: transparent !important;\\n      }\\n      \\n      /* Force proper fills on basic shapes */\\n      .djs-container svg rect:not([fill=\"none\"]):not([fill=\"transparent\"]),\\n      .djs-container svg circle:not([fill=\"none\"]):not([fill=\"transparent\"]),\\n      .djs-container svg ellipse:not([fill=\"none\"]):not([fill=\"transparent\"]),\\n      .djs-container svg polygon:not([fill=\"none\"]):not([fill=\"transparent\"]) {\\n        fill: ').concat(isDark ? \"#1f2937\" : \"#ffffff\", \" !important;\\n      }\\n      \\n      /* Ensure text is always visible */\\n      .djs-container svg text,\\n      .djs-container svg tspan {\\n        fill: \").concat(isDark ? \"#ffffff\" : \"#000000\", \" !important;\\n      }\\n      \\n      /* SUPER AGGRESSIVE: Override ANY stroke attribute in dark mode */\\n      \").concat(isDark ? '\\n        .djs-container svg *:not([stroke=\"none\"]):not([stroke=\"transparent\"]) {\\n          stroke: #ffffff !important;\\n        }\\n        \\n        .djs-container svg path:not([stroke=\"none\"]):not([stroke=\"transparent\"]) {\\n          stroke: #ffffff !important;\\n        }\\n        \\n        .djs-container svg line:not([stroke=\"none\"]):not([stroke=\"transparent\"]) {\\n          stroke: #ffffff !important;\\n        }\\n        \\n        .djs-container svg polyline:not([stroke=\"none\"]):not([stroke=\"transparent\"]) {\\n          stroke: #ffffff !important;\\n        }\\n        \\n        .djs-container svg rect:not([stroke=\"none\"]):not([stroke=\"transparent\"]) {\\n          stroke: #ffffff !important;\\n        }\\n        \\n        .djs-container svg circle:not([stroke=\"none\"]):not([stroke=\"transparent\"]) {\\n          stroke: #ffffff !important;\\n        }\\n        \\n        .djs-container svg ellipse:not([stroke=\"none\"]):not([stroke=\"transparent\"]) {\\n          stroke: #ffffff !important;\\n        }\\n        \\n        .djs-container svg polygon:not([stroke=\"none\"]):not([stroke=\"transparent\"]) {\\n          stroke: #ffffff !important;\\n        }\\n      ' : '\\n        .djs-container svg *:not([stroke=\"none\"]):not([stroke=\"transparent\"]) {\\n          stroke: #000000 !important;\\n        }\\n      ', \"\\n    \");\n            // Only append if not already in DOM\n            if (!style.parentNode) {\n                document.head.appendChild(style);\n            }\n            // Also add class to the canvas container for CSS targeting\n            if (container) {\n                if (isDark) {\n                    container.classList.add(\"dark-mode\");\n                    container.classList.remove(\"light-mode\");\n                } else {\n                    container.classList.add(\"light-mode\");\n                    container.classList.remove(\"dark-mode\");\n                }\n                // Directly set background on container and SVG\n                container.style.backgroundColor = isDark ? \"#111827\" : \"#f9fafb\";\n                const svgElement = container.querySelector(\"svg\");\n                if (svgElement) {\n                    svgElement.style.backgroundColor = isDark ? \"#111827\" : \"#f9fafb\";\n                }\n            }\n            // Force a redraw - but check if eventBus exists\n            const eventBus = modeler.get(\"eventBus\");\n            if (eventBus) {\n                eventBus.fire(\"canvas.viewbox.changed\");\n            }\n            // AGGRESSIVE FALLBACK: Force color updates on ALL elements\n            const forceColorUpdate = ()=>{\n                const svgElements = document.querySelectorAll(\".djs-container svg *\");\n                svgElements.forEach((el)=>{\n                    var _el_tagName;\n                    const tagName = (_el_tagName = el.tagName) === null || _el_tagName === void 0 ? void 0 : _el_tagName.toLowerCase();\n                    // FORCE stroke colors\n                    if (el.hasAttribute(\"stroke\") || el.style.stroke) {\n                        const currentStroke = el.getAttribute(\"stroke\") || el.style.stroke;\n                        if (currentStroke && currentStroke !== \"none\" && currentStroke !== \"transparent\") {\n                            // Check if it's a black stroke in dark mode or white in light mode (needs fixing)\n                            const needsFix = isDark && (currentStroke === \"#000000\" || currentStroke === \"black\" || currentStroke === \"rgb(0, 0, 0)\") || !isDark && (currentStroke === \"#ffffff\" || currentStroke === \"white\" || currentStroke === \"rgb(255, 255, 255)\");\n                            if (needsFix || tagName === \"rect\" || tagName === \"circle\" || tagName === \"polygon\" || tagName === \"path\" || tagName === \"line\") {\n                                const newStroke = isDark ? \"#ffffff\" : \"#000000\";\n                                el.setAttribute(\"stroke\", newStroke);\n                                el.style.stroke = newStroke;\n                                el.style.strokeOpacity = \"1\";\n                            }\n                        }\n                    }\n                    // FORCE fill colors for shapes\n                    if (tagName === \"rect\" || tagName === \"circle\" || tagName === \"ellipse\" || tagName === \"polygon\") {\n                        const currentFill = el.getAttribute(\"fill\") || el.style.fill;\n                        if (currentFill && currentFill !== \"none\" && currentFill !== \"transparent\") {\n                            // Skip selection boxes\n                            if (!el.closest(\".djs-outline\") && !el.closest(\".djs-selection\")) {\n                                const newFill = isDark ? \"#1f2937\" : \"#ffffff\";\n                                el.setAttribute(\"fill\", newFill);\n                                el.style.fill = newFill;\n                            }\n                        }\n                    }\n                    // Text and icons\n                    if (tagName === \"text\" || tagName === \"tspan\") {\n                        const newColor = isDark ? \"#ffffff\" : \"#000000\";\n                        el.setAttribute(\"fill\", newColor);\n                        el.style.fill = newColor;\n                    }\n                });\n            };\n            // Run multiple times to catch all updates\n            forceColorUpdate();\n            setTimeout(forceColorUpdate, 50);\n            setTimeout(forceColorUpdate, 100);\n            setTimeout(forceColorUpdate, 200);\n            setTimeout(forceColorUpdate, 500);\n        } catch (err) {\n            console.error(\"Error applying BPMN styles:\", err);\n        }\n    }, []);\n    // Initialize BPMN Modeler\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        let mounted = true;\n        let modeler = null;\n        let observer = null;\n        const initBpmn = async ()=>{\n            const container = containerRef.current;\n            if (!container || !mounted) return;\n            try {\n                // Wait for container to have dimensions\n                if (container.offsetWidth === 0 || container.offsetHeight === 0) {\n                    setTimeout(initBpmn, 100);\n                    return;\n                }\n                // Create modeler with full default modules (including palette)\n                modeler = new bpmn_js_lib_Modeler__WEBPACK_IMPORTED_MODULE_6__[\"default\"]({\n                    container: container,\n                    keyboard: {\n                        bindTo: window\n                    },\n                    // Ensure all default modules are enabled\n                    additionalModules: [],\n                    moddleExtensions: {}\n                });\n                modelerRef.current = modeler;\n                // Import default diagram\n                await modeler.importXML(DEFAULT_BPMN);\n                // Wait a bit for canvas to be fully initialized\n                await new Promise((resolve)=>setTimeout(resolve, 50));\n                // Setup command stack listeners - with safety checks\n                const eventBus = modeler.get(\"eventBus\");\n                const commandStack = modeler.get(\"commandStack\");\n                if (!eventBus || !commandStack) {\n                    console.warn(\"BPMN modules not fully initialized, retrying...\");\n                    setTimeout(initBpmn, 100);\n                    return;\n                }\n                const updateUndoRedo = ()=>{\n                    if (!mounted) return;\n                    setCanUndo(commandStack.canUndo());\n                    setCanRedo(commandStack.canRedo());\n                };\n                eventBus.on(\"commandStack.changed\", updateUndoRedo);\n                updateUndoRedo();\n                // Track selection changes for alignment tools\n                const selection = modeler.get(\"selection\");\n                eventBus.on(\"selection.changed\", (e)=>{\n                    if (!mounted) return;\n                    const elements = e.newSelection || [];\n                    setSelectedElements(elements);\n                    // Apply visual feedback for selection\n                    if (elements.length > 0) {\n                        console.log(\"Selected \".concat(elements.length, \" element(s)\"));\n                        // FORCE TRANSPARENCY: Remove any opaque selection boxes\n                        setTimeout(()=>{\n                            const selectionBoxes = document.querySelectorAll('.djs-outline rect, .djs-selection rect, [class*=\"select\"] rect');\n                            selectionBoxes.forEach((box)=>{\n                                // Skip actual shape rectangles\n                                if (box.closest(\".djs-visual\")) return;\n                                // Force transparent fill\n                                box.style.fill = \"transparent\";\n                                box.style.fillOpacity = \"0\";\n                                box.setAttribute(\"fill\", \"none\");\n                                box.setAttribute(\"fill-opacity\", \"0\");\n                            });\n                            // Also check for any selection frames\n                            const frames = document.querySelectorAll(\".djs-frame, .djs-selection-frame, .djs-select-visual\");\n                            frames.forEach((frame)=>{\n                                if (frame.tagName === \"rect\" || frame.querySelector(\"rect\")) {\n                                    const rect = frame.tagName === \"rect\" ? frame : frame.querySelector(\"rect\");\n                                    if (rect && !rect.closest(\".djs-visual\")) {\n                                        rect.style.fill = \"transparent\";\n                                        rect.setAttribute(\"fill\", \"none\");\n                                    }\n                                }\n                            });\n                        }, 0);\n                    }\n                });\n                // Add keyboard shortcuts\n                const keyboard = modeler.get(\"keyboard\");\n                const editorActions = modeler.get(\"editorActions\");\n                if (keyboard && editorActions) {\n                    // Register Ctrl+A for select all\n                    editorActions.register(\"selectAll\", ()=>{\n                        const elementRegistry = modeler.get(\"elementRegistry\");\n                        const allElements = elementRegistry.filter((element)=>{\n                            return element.type !== \"label\" && element.type !== \"bpmn:SequenceFlow\" && element.id !== \"Process_1\" && !element.labelTarget;\n                        });\n                        selection.select(allElements);\n                        console.log(\"Selected all \".concat(allElements.length, \" elements\"));\n                    });\n                    // Register spacebar for replace menu\n                    editorActions.register(\"showReplaceMenu\", ()=>{\n                        const selectedElements = selection.get();\n                        if (selectedElements.length === 1) {\n                            const element = selectedElements[0];\n                            // Skip if it's the root element\n                            if (element.id === \"Process_1\" || element.type === \"bpmn:Process\") {\n                                return;\n                            }\n                            // Get the replace menu module\n                            const popupMenu = modeler.get(\"popupMenu\");\n                            const replaceMenuProvider = modeler.get(\"replaceMenuProvider\");\n                            if (popupMenu && replaceMenuProvider) {\n                                // Get the position of the selected element\n                                const elementRegistry = modeler.get(\"elementRegistry\");\n                                const elementShape = elementRegistry.get(element.id);\n                                if (elementShape) {\n                                    // Calculate position for the popup\n                                    const position = {\n                                        x: elementShape.x + (elementShape.width || 100) / 2,\n                                        y: elementShape.y - 10\n                                    };\n                                    // Get replace options for this element\n                                    const entries = replaceMenuProvider.getPopupMenuEntries(element);\n                                    if (entries && Object.keys(entries).length > 0) {\n                                        // Open the popup menu\n                                        popupMenu.open(element, \"bpmn-replace\", position, entries);\n                                        console.log(\"Replace menu opened for:\", element.type);\n                                    }\n                                }\n                            } else {\n                                // Fallback: Try to trigger the replace tool directly\n                                const replacePreview = modeler.get(\"replacePreview\");\n                                if (replacePreview) {\n                                    replacePreview.toggle();\n                                }\n                            }\n                        }\n                    });\n                    // Bind keyboard shortcuts\n                    keyboard.addListener((context)=>{\n                        const key = context.keyEvent.key;\n                        const ctrl = context.keyEvent.ctrlKey || context.keyEvent.metaKey;\n                        // Ctrl+A or Cmd+A for select all\n                        if (ctrl && key === \"a\") {\n                            editorActions.trigger(\"selectAll\");\n                            context.keyEvent.preventDefault();\n                            return true;\n                        }\n                        // Spacebar for replace menu\n                        if (key === \" \" && !ctrl && !context.keyEvent.shiftKey && !context.keyEvent.altKey) {\n                            // Check if we're not in a text input\n                            const activeElement = document.activeElement;\n                            if (activeElement && (activeElement.tagName === \"INPUT\" || activeElement.tagName === \"TEXTAREA\")) {\n                                return false;\n                            }\n                            editorActions.trigger(\"showReplaceMenu\");\n                            context.keyEvent.preventDefault();\n                            return true;\n                        }\n                        return false;\n                    });\n                }\n                // Apply initial styles\n                applyBpmnStyles(modeler, theme);\n                // Add a global keyboard listener for spacebar (fallback)\n                const handleGlobalKeydown = (e)=>{\n                    // Only handle spacebar when canvas is focused\n                    if (e.key === \" \" && !e.ctrlKey && !e.metaKey && !e.shiftKey && !e.altKey) {\n                        const activeElement = document.activeElement;\n                        // Skip if typing in an input\n                        if (activeElement && (activeElement.tagName === \"INPUT\" || activeElement.tagName === \"TEXTAREA\" || activeElement.getAttribute(\"contenteditable\") === \"true\")) {\n                            return;\n                        }\n                        // Check if the canvas or its container has focus\n                        const canvasElement = container.querySelector(\".djs-container\");\n                        if (canvasElement && (canvasElement.contains(activeElement) || activeElement === document.body)) {\n                            const selectedElements = selection.get();\n                            if (selectedElements.length === 1) {\n                                e.preventDefault();\n                                e.stopPropagation();\n                                const element = selectedElements[0];\n                                // Skip root element\n                                if (element.id === \"Process_1\" || element.type === \"bpmn:Process\") {\n                                    return;\n                                }\n                                console.log(\"Spacebar pressed with element selected:\", element.type);\n                                // Try to open replace menu\n                                const popupMenu = modeler.get(\"popupMenu\");\n                                const replaceMenuProvider = modeler.get(\"replaceMenuProvider\");\n                                if (popupMenu && replaceMenuProvider) {\n                                    const elementRegistry = modeler.get(\"elementRegistry\");\n                                    const elementShape = elementRegistry.get(element.id);\n                                    if (elementShape) {\n                                        const position = {\n                                            x: elementShape.x + (elementShape.width || 100) / 2,\n                                            y: elementShape.y - 10\n                                        };\n                                        const entries = replaceMenuProvider.getPopupMenuEntries(element);\n                                        if (entries && Object.keys(entries).length > 0) {\n                                            popupMenu.open(element, \"bpmn-replace\", position, entries);\n                                            console.log(\"Replace menu triggered via spacebar\");\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                };\n                // Attach the global listener\n                document.addEventListener(\"keydown\", handleGlobalKeydown);\n                // Store reference for cleanup\n                modelerRef.current._spacebarHandler = handleGlobalKeydown;\n                // Apply initial grid state\n                const canvas = modeler.get(\"canvas\");\n                const canvasContainer = canvas._container || canvas.getContainer();\n                if (canvasContainer && showGrid) {\n                    canvasContainer.classList.add(\"show-grid\");\n                }\n                // Set up MutationObserver to catch dynamically added elements\n                if (canvasContainer) {\n                    observer = new MutationObserver((mutations)=>{\n                        const currentTheme = document.documentElement.classList.contains(\"dark\") ? \"dark\" : \"light\";\n                        const isDarkMode = currentTheme === \"dark\";\n                        mutations.forEach((mutation)=>{\n                            // Process added nodes\n                            mutation.addedNodes.forEach((node)=>{\n                                if (node.nodeType === 1) {\n                                    // Process the node itself if it's an SVG element\n                                    if (node.tagName) {\n                                        const tagName = node.tagName.toLowerCase();\n                                        // IMMEDIATE fix for rectangles (Tasks)\n                                        if (tagName === \"rect\" || tagName === \"g\" || tagName === \"svg\") {\n                                            // Fix the node itself\n                                            if (tagName === \"rect\") {\n                                                node.style.stroke = isDarkMode ? \"#ffffff\" : \"#000000\";\n                                                node.setAttribute(\"stroke\", isDarkMode ? \"#ffffff\" : \"#000000\");\n                                                if (!node.closest(\".djs-outline\") && !node.closest(\".djs-selection\")) {\n                                                    node.style.fill = isDarkMode ? \"#1f2937\" : \"#ffffff\";\n                                                    node.setAttribute(\"fill\", isDarkMode ? \"#1f2937\" : \"#ffffff\");\n                                                }\n                                            }\n                                            // Fix all rect children\n                                            const rects = node.querySelectorAll ? node.querySelectorAll(\"rect\") : [];\n                                            rects.forEach((rect)=>{\n                                                rect.style.stroke = isDarkMode ? \"#ffffff\" : \"#000000\";\n                                                rect.setAttribute(\"stroke\", isDarkMode ? \"#ffffff\" : \"#000000\");\n                                                rect.style.strokeOpacity = \"1\";\n                                                if (!rect.closest(\".djs-outline\") && !rect.closest(\".djs-selection\")) {\n                                                    rect.style.fill = isDarkMode ? \"#1f2937\" : \"#ffffff\";\n                                                    rect.setAttribute(\"fill\", isDarkMode ? \"#1f2937\" : \"#ffffff\");\n                                                }\n                                            });\n                                        }\n                                        // Process all descendants\n                                        if (node.querySelectorAll) {\n                                            const elements = node.querySelectorAll(\"*\");\n                                            elements.forEach((el)=>{\n                                                var _el_tagName;\n                                                const elTag = (_el_tagName = el.tagName) === null || _el_tagName === void 0 ? void 0 : _el_tagName.toLowerCase();\n                                                // Force colors on all shape elements\n                                                if (elTag === \"rect\" || elTag === \"circle\" || elTag === \"polygon\" || elTag === \"path\" || elTag === \"line\") {\n                                                    if (el.hasAttribute(\"stroke\") || el.style.stroke) {\n                                                        el.style.stroke = isDarkMode ? \"#ffffff\" : \"#000000\";\n                                                        el.setAttribute(\"stroke\", isDarkMode ? \"#ffffff\" : \"#000000\");\n                                                        el.style.strokeOpacity = \"1\";\n                                                    }\n                                                    if ((elTag === \"rect\" || elTag === \"circle\" || elTag === \"polygon\") && !el.closest(\".djs-outline\") && !el.closest(\".djs-selection\")) {\n                                                        el.style.fill = isDarkMode ? \"#1f2937\" : \"#ffffff\";\n                                                        el.setAttribute(\"fill\", isDarkMode ? \"#1f2937\" : \"#ffffff\");\n                                                    }\n                                                }\n                                            });\n                                        }\n                                    }\n                                }\n                            });\n                            // Also check attribute changes for stroke/fill\n                            if (mutation.type === \"attributes\" && mutation.target) {\n                                const target = mutation.target;\n                                if (target.tagName) {\n                                    const tagName = target.tagName.toLowerCase();\n                                    if (tagName === \"rect\" && (mutation.attributeName === \"stroke\" || mutation.attributeName === \"style\")) {\n                                        // Force correct color if it was changed to wrong color\n                                        const currentStroke = target.getAttribute(\"stroke\") || target.style.stroke;\n                                        if (isDarkMode && (currentStroke === \"#000000\" || currentStroke === \"black\")) {\n                                            target.style.stroke = \"#ffffff\";\n                                            target.setAttribute(\"stroke\", \"#ffffff\");\n                                        }\n                                    }\n                                }\n                            }\n                        });\n                    });\n                    observer.observe(canvasContainer, {\n                        childList: true,\n                        subtree: true,\n                        attributes: true,\n                        attributeFilter: [\n                            \"stroke\",\n                            \"fill\",\n                            \"style\"\n                        ]\n                    });\n                }\n                setIsReady(true);\n                setError(null);\n            } catch (err) {\n                console.error(\"BPMN initialization error:\", err);\n                setError(err instanceof Error ? err.message : \"Failed to initialize\");\n            }\n        };\n        // Start initialization after a small delay\n        setTimeout(initBpmn, 100);\n        return ()=>{\n            mounted = false;\n            if (observer) {\n                observer.disconnect();\n            }\n            if (modeler) {\n                try {\n                    modeler.destroy();\n                } catch (e) {\n                // Ignore cleanup errors\n                }\n            }\n        };\n    }, [\n        theme,\n        applyBpmnStyles\n    ]);\n    // Re-apply styles when theme changes\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (modelerRef.current && isReady) {\n            applyBpmnStyles(modelerRef.current, theme);\n            // Also update grid if it's enabled\n            const canvas = modelerRef.current.get(\"canvas\");\n            const container = (canvas === null || canvas === void 0 ? void 0 : canvas._container) || (canvas === null || canvas === void 0 ? void 0 : canvas.getContainer());\n            if (container && showGrid) {\n                container.classList.add(\"show-grid\");\n            }\n            // AGGRESSIVE: Continuous Task fix for stubborn elements\n            const fixTaskColors = ()=>{\n                const isDark = theme === \"dark\";\n                const tasks = document.querySelectorAll('[data-element-id*=\"Task\"]');\n                tasks.forEach((task)=>{\n                    const rects = task.querySelectorAll(\"rect\");\n                    rects.forEach((rect)=>{\n                        // Check current color\n                        const currentStroke = rect.getAttribute(\"stroke\") || rect.style.stroke;\n                        const needsFix = isDark ? currentStroke === \"#000000\" || currentStroke === \"black\" || currentStroke === \"rgb(0, 0, 0)\" : currentStroke === \"#ffffff\" || currentStroke === \"white\" || currentStroke === \"rgb(255, 255, 255)\";\n                        if (needsFix) {\n                            console.log(\"Fixing Task stroke:\", currentStroke, \"→\", isDark ? \"#ffffff\" : \"#000000\");\n                            rect.setAttribute(\"stroke\", isDark ? \"#ffffff\" : \"#000000\");\n                            rect.style.stroke = isDark ? \"#ffffff\" : \"#000000\";\n                            rect.style.strokeOpacity = \"1\";\n                            if (!rect.closest(\".djs-outline\")) {\n                                rect.setAttribute(\"fill\", isDark ? \"#1f2937\" : \"#ffffff\");\n                                rect.style.fill = isDark ? \"#1f2937\" : \"#ffffff\";\n                            }\n                        }\n                    });\n                });\n            };\n            // Run multiple times to catch stubborn elements\n            const intervals = [\n                0,\n                100,\n                200,\n                500,\n                1000,\n                2000\n            ];\n            intervals.forEach((delay)=>{\n                setTimeout(fixTaskColors, delay);\n            });\n        }\n    }, [\n        theme,\n        isReady,\n        showGrid,\n        applyBpmnStyles\n    ]);\n    // Handlers\n    const handleSave = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(async ()=>{\n        if (!modelerRef.current) return;\n        setSaving(true);\n        try {\n            const { xml } = await modelerRef.current.saveXML({\n                format: true\n            });\n            localStorage.setItem(\"bpmn-diagram\", xml || \"\");\n            console.log(\"Saved to localStorage\");\n        } catch (err) {\n            console.error(\"Save error:\", err);\n        } finally{\n            setSaving(false);\n        }\n    }, []);\n    const handleExport = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(async ()=>{\n        if (!modelerRef.current) return;\n        try {\n            var _prompt;\n            const { xml } = await modelerRef.current.saveXML({\n                format: true\n            });\n            // Show export format options\n            const format = (_prompt = prompt(\"Export format: xml, json, or yaml?\", \"xml\")) === null || _prompt === void 0 ? void 0 : _prompt.toLowerCase();\n            let content = xml || \"\";\n            let filename = \"diagram.bpmn\";\n            let mimeType = \"text/xml\";\n            if (format === \"json\") {\n                var _xmlDoc_querySelector;\n                // Convert XML to JSON representation\n                const parser = new DOMParser();\n                const xmlDoc = parser.parseFromString(xml || \"\", \"text/xml\");\n                const jsonData = {\n                    type: \"bpmn:definitions\",\n                    process: ((_xmlDoc_querySelector = xmlDoc.querySelector(\"process\")) === null || _xmlDoc_querySelector === void 0 ? void 0 : _xmlDoc_querySelector.getAttribute(\"id\")) || \"Process_1\",\n                    elements: Array.from(xmlDoc.querySelectorAll(\"*[id]\")).map((el)=>({\n                            id: el.getAttribute(\"id\"),\n                            type: el.tagName,\n                            name: el.getAttribute(\"name\") || \"\"\n                        }))\n                };\n                content = JSON.stringify(jsonData, null, 2);\n                filename = \"diagram.json\";\n                mimeType = \"application/json\";\n            } else if (format === \"yaml\" || format === \"yml\") {\n                var _xmlDoc_querySelector1;\n                // Simple YAML conversion (would need proper library for production)\n                const parser = new DOMParser();\n                const xmlDoc = parser.parseFromString(xml || \"\", \"text/xml\");\n                let yamlContent = \"type: bpmn:definitions\\n\";\n                yamlContent += \"process: \".concat(((_xmlDoc_querySelector1 = xmlDoc.querySelector(\"process\")) === null || _xmlDoc_querySelector1 === void 0 ? void 0 : _xmlDoc_querySelector1.getAttribute(\"id\")) || \"Process_1\", \"\\n\");\n                yamlContent += \"elements:\\n\";\n                xmlDoc.querySelectorAll(\"*[id]\").forEach((el)=>{\n                    yamlContent += \"  - id: \".concat(el.getAttribute(\"id\"), \"\\n\");\n                    yamlContent += \"    type: \".concat(el.tagName, \"\\n\");\n                    const name = el.getAttribute(\"name\");\n                    if (name) yamlContent += \"    name: \".concat(name, \"\\n\");\n                });\n                content = yamlContent;\n                filename = \"diagram.yaml\";\n                mimeType = \"text/yaml\";\n            }\n            const blob = new Blob([\n                content\n            ], {\n                type: mimeType\n            });\n            const url = URL.createObjectURL(blob);\n            const a = document.createElement(\"a\");\n            a.href = url;\n            a.download = filename;\n            a.click();\n            URL.revokeObjectURL(url);\n        } catch (err) {\n            console.error(\"Export error:\", err);\n        }\n    }, []);\n    const handleImport = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((e)=>{\n        var _e_target_files;\n        const file = (_e_target_files = e.target.files) === null || _e_target_files === void 0 ? void 0 : _e_target_files[0];\n        if (!file || !modelerRef.current) return;\n        const reader = new FileReader();\n        reader.onload = async (event)=>{\n            try {\n                var _event_target, _file_name_split_pop, _modelerRef_current;\n                const content = (_event_target = event.target) === null || _event_target === void 0 ? void 0 : _event_target.result;\n                let xml = content;\n                // Check file extension to determine format\n                const ext = (_file_name_split_pop = file.name.split(\".\").pop()) === null || _file_name_split_pop === void 0 ? void 0 : _file_name_split_pop.toLowerCase();\n                if (ext === \"json\") {\n                    // Convert JSON back to BPMN XML (simplified)\n                    const jsonData = JSON.parse(content);\n                    xml = DEFAULT_BPMN // Start with default and modify\n                    ;\n                    console.log(\"Importing JSON format:\", jsonData);\n                    // Would need proper JSON to BPMN conversion\n                    alert(\"JSON import: Elements detected, using default template. Full JSON import requires custom parser.\");\n                } else if (ext === \"yaml\" || ext === \"yml\") {\n                    // Convert YAML back to BPMN XML (simplified)\n                    console.log(\"Importing YAML format\");\n                    xml = DEFAULT_BPMN // Start with default\n                    ;\n                    alert(\"YAML import: Using default template. Full YAML import requires yaml parser library.\");\n                }\n                await ((_modelerRef_current = modelerRef.current) === null || _modelerRef_current === void 0 ? void 0 : _modelerRef_current.importXML(xml));\n            } catch (err) {\n                console.error(\"Import error:\", err);\n                alert(\"Import failed: \" + (err instanceof Error ? err.message : \"Unknown error\"));\n            }\n        };\n        reader.readAsText(file);\n    }, []);\n    const handleUndo = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(()=>{\n        var _modelerRef_current;\n        const commandStack = (_modelerRef_current = modelerRef.current) === null || _modelerRef_current === void 0 ? void 0 : _modelerRef_current.get(\"commandStack\");\n        if (commandStack === null || commandStack === void 0 ? void 0 : commandStack.canUndo()) {\n            commandStack.undo();\n        }\n    }, []);\n    const handleRedo = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(()=>{\n        var _modelerRef_current;\n        const commandStack = (_modelerRef_current = modelerRef.current) === null || _modelerRef_current === void 0 ? void 0 : _modelerRef_current.get(\"commandStack\");\n        if (commandStack === null || commandStack === void 0 ? void 0 : commandStack.canRedo()) {\n            commandStack.redo();\n        }\n    }, []);\n    const handleZoomIn = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(()=>{\n        if (!modelerRef.current) return;\n        try {\n            var _canvas__container;\n            const canvas = modelerRef.current.get(\"canvas\");\n            if (!canvas) return;\n            // Ensure SVG context is available\n            const svg = canvas._svg || ((_canvas__container = canvas._container) === null || _canvas__container === void 0 ? void 0 : _canvas__container.querySelector(\"svg\"));\n            if (!svg || !svg.createSVGMatrix) {\n                console.warn(\"SVG not ready for zoom\");\n                return;\n            }\n            const currentZoom = canvas.zoom();\n            if (typeof currentZoom === \"number\") {\n                const newZoom = Math.min(currentZoom * 1.2, 4);\n                canvas.zoom(newZoom);\n                setZoomLevel(Math.round(newZoom * 100));\n            }\n        } catch (err) {\n            console.error(\"Zoom in error:\", err);\n        }\n    }, []);\n    const handleZoomOut = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(()=>{\n        if (!modelerRef.current) return;\n        try {\n            var _canvas__container;\n            const canvas = modelerRef.current.get(\"canvas\");\n            if (!canvas) return;\n            // Ensure SVG context is available\n            const svg = canvas._svg || ((_canvas__container = canvas._container) === null || _canvas__container === void 0 ? void 0 : _canvas__container.querySelector(\"svg\"));\n            if (!svg || !svg.createSVGMatrix) {\n                console.warn(\"SVG not ready for zoom\");\n                return;\n            }\n            const currentZoom = canvas.zoom();\n            if (typeof currentZoom === \"number\") {\n                const newZoom = Math.max(currentZoom / 1.2, 0.2);\n                canvas.zoom(newZoom);\n                setZoomLevel(Math.round(newZoom * 100));\n            }\n        } catch (err) {\n            console.error(\"Zoom out error:\", err);\n        }\n    }, []);\n    const handleZoomReset = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(()=>{\n        if (!modelerRef.current) return;\n        try {\n            var _canvas__container;\n            const canvas = modelerRef.current.get(\"canvas\");\n            if (!canvas) return;\n            // Ensure SVG context is available\n            const svg = canvas._svg || ((_canvas__container = canvas._container) === null || _canvas__container === void 0 ? void 0 : _canvas__container.querySelector(\"svg\"));\n            if (!svg || !svg.createSVGMatrix) {\n                console.warn(\"SVG not ready for zoom\");\n                return;\n            }\n            canvas.zoom(\"fit-viewport\");\n            setZoomLevel(100);\n        } catch (err) {\n            console.error(\"Zoom reset error:\", err);\n        }\n    }, []);\n    const handleClear = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(async ()=>{\n        if (!modelerRef.current) return;\n        if (confirm(\"Clear the entire diagram?\")) {\n            await modelerRef.current.importXML(DEFAULT_BPMN);\n        }\n    }, []);\n    const handleThemeToggle = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(()=>{\n        const newTheme = theme === \"light\" ? \"dark\" : \"light\";\n        console.log(\"Theme toggle:\", theme, \"->\", newTheme);\n        setTheme(newTheme) // ThemeProvider handles DOM manipulation\n        ;\n        // Re-apply BPMN styles with new theme\n        if (modelerRef.current) {\n            // Apply new styles (this will update the existing style element)\n            applyBpmnStyles(modelerRef.current, newTheme);\n            // IMMEDIATE: Force direct SVG manipulation for instant color change\n            const forceColorUpdate = ()=>{\n                const isDarkMode = newTheme === \"dark\";\n                const svgElements = document.querySelectorAll(\".djs-container svg *\");\n                svgElements.forEach((el)=>{\n                    // Update stroke attributes\n                    if (el.hasAttribute(\"stroke\")) {\n                        const stroke = el.getAttribute(\"stroke\");\n                        if (stroke && stroke !== \"none\" && stroke !== \"transparent\") {\n                            // Force white in dark mode, black in light mode\n                            el.style.stroke = isDarkMode ? \"#ffffff\" : \"#000000\";\n                            el.setAttribute(\"stroke\", isDarkMode ? \"#ffffff\" : \"#000000\");\n                        }\n                    }\n                    // Update fill attributes\n                    if (el.hasAttribute(\"fill\")) {\n                        const fill = el.getAttribute(\"fill\");\n                        if (fill && fill !== \"none\" && fill !== \"transparent\") {\n                            // Shapes get background color\n                            if (el.tagName === \"rect\" || el.tagName === \"circle\" || el.tagName === \"ellipse\" || el.tagName === \"polygon\") {\n                                el.style.fill = isDarkMode ? \"#1f2937\" : \"#ffffff\";\n                                el.setAttribute(\"fill\", isDarkMode ? \"#1f2937\" : \"#ffffff\");\n                            } else if (el.tagName === \"text\" || el.tagName === \"tspan\" || el.tagName === \"path\") {\n                                el.style.fill = isDarkMode ? \"#ffffff\" : \"#000000\";\n                                el.setAttribute(\"fill\", isDarkMode ? \"#ffffff\" : \"#000000\");\n                            }\n                        }\n                    }\n                    // Also set style attribute to override any inline styles\n                    if (el.tagName === \"rect\" || el.tagName === \"circle\" || el.tagName === \"ellipse\" || el.tagName === \"polygon\" || el.tagName === \"path\" || el.tagName === \"line\" || el.tagName === \"polyline\") {\n                        if (!el.getAttribute(\"stroke-opacity\") || el.getAttribute(\"stroke-opacity\") !== \"0\") {\n                            el.style.stroke = isDarkMode ? \"#ffffff\" : \"#000000\";\n                        }\n                    }\n                });\n            };\n            // Execute immediately and after a short delay\n            forceColorUpdate();\n            setTimeout(forceColorUpdate, 100);\n            setTimeout(forceColorUpdate, 300);\n            // Force a complete redraw using a safer method\n            try {\n                const canvas = modelerRef.current.get(\"canvas\");\n                const eventBus = modelerRef.current.get(\"eventBus\");\n                if (canvas && eventBus) {\n                    // Get the current viewbox to preserve position\n                    const viewbox = canvas.viewbox();\n                    // Directly update canvas container background\n                    const container = canvas._container || canvas.getContainer();\n                    if (container) {\n                        const bgColor = newTheme === \"dark\" ? \"#111827\" : \"#f9fafb\";\n                        container.style.backgroundColor = bgColor;\n                        // Update SVG background\n                        const svg = container.querySelector(\"svg\");\n                        if (svg) {\n                            svg.style.backgroundColor = bgColor;\n                        }\n                        // Update any viewport elements\n                        const viewport = container.querySelector(\".djs-viewport\");\n                        if (viewport) {\n                            viewport.style.backgroundColor = bgColor;\n                        }\n                        // Preserve grid state after theme change\n                        if (showGrid) {\n                            container.classList.add(\"show-grid\");\n                        }\n                    }\n                    // Simply trigger a canvas refresh without manipulating elements\n                    // The styles will be re-applied through the style element update\n                    requestAnimationFrame(()=>{\n                        if (eventBus) {\n                            // Just fire a viewbox change to refresh the rendering\n                            eventBus.fire(\"canvas.viewbox.changed\", viewbox);\n                        }\n                    });\n                }\n            } catch (err) {\n                console.error(\"Theme toggle redraw error:\", err);\n            }\n        }\n    }, [\n        theme,\n        applyBpmnStyles\n    ]);\n    // Alignment handlers\n    const handleAlignLeft = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(()=>{\n        if (!modelerRef.current || selectedElements.length < 2) return;\n        const modeling = modelerRef.current.get(\"modeling\");\n        const canvas = modelerRef.current.get(\"canvas\");\n        // Find leftmost element\n        const leftMost = selectedElements.reduce((min, el)=>el.x < min.x ? el : min, selectedElements[0]);\n        // Align all elements to leftmost\n        selectedElements.forEach((el)=>{\n            if (el.id !== leftMost.id) {\n                modeling.moveElements([\n                    el\n                ], {\n                    x: leftMost.x - el.x,\n                    y: 0\n                });\n            }\n        });\n    }, [\n        selectedElements\n    ]);\n    const handleAlignCenter = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(()=>{\n        if (!modelerRef.current || selectedElements.length < 2) return;\n        const modeling = modelerRef.current.get(\"modeling\");\n        // Calculate center position\n        const centerX = selectedElements.reduce((sum, el)=>sum + el.x + el.width / 2, 0) / selectedElements.length;\n        // Align all elements to center\n        selectedElements.forEach((el)=>{\n            const targetX = centerX - el.width / 2;\n            modeling.moveElements([\n                el\n            ], {\n                x: targetX - el.x,\n                y: 0\n            });\n        });\n    }, [\n        selectedElements\n    ]);\n    const handleAlignRight = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(()=>{\n        if (!modelerRef.current || selectedElements.length < 2) return;\n        const modeling = modelerRef.current.get(\"modeling\");\n        // Find rightmost element\n        const rightMost = selectedElements.reduce((max, el)=>el.x + el.width > max.x + max.width ? el : max, selectedElements[0]);\n        const rightEdge = rightMost.x + rightMost.width;\n        // Align all elements to rightmost\n        selectedElements.forEach((el)=>{\n            if (el.id !== rightMost.id) {\n                const targetX = rightEdge - el.width;\n                modeling.moveElements([\n                    el\n                ], {\n                    x: targetX - el.x,\n                    y: 0\n                });\n            }\n        });\n    }, [\n        selectedElements\n    ]);\n    const handleAlignTop = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(()=>{\n        if (!modelerRef.current || selectedElements.length < 2) return;\n        const modeling = modelerRef.current.get(\"modeling\");\n        // Find topmost element\n        const topMost = selectedElements.reduce((min, el)=>el.y < min.y ? el : min, selectedElements[0]);\n        // Align all elements to topmost\n        selectedElements.forEach((el)=>{\n            if (el.id !== topMost.id) {\n                modeling.moveElements([\n                    el\n                ], {\n                    x: 0,\n                    y: topMost.y - el.y\n                });\n            }\n        });\n    }, [\n        selectedElements\n    ]);\n    const handleAlignMiddle = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(()=>{\n        if (!modelerRef.current || selectedElements.length < 2) return;\n        const modeling = modelerRef.current.get(\"modeling\");\n        // Calculate middle position\n        const middleY = selectedElements.reduce((sum, el)=>sum + el.y + el.height / 2, 0) / selectedElements.length;\n        // Align all elements to middle\n        selectedElements.forEach((el)=>{\n            const targetY = middleY - el.height / 2;\n            modeling.moveElements([\n                el\n            ], {\n                x: 0,\n                y: targetY - el.y\n            });\n        });\n    }, [\n        selectedElements\n    ]);\n    const handleAlignBottom = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(()=>{\n        if (!modelerRef.current || selectedElements.length < 2) return;\n        const modeling = modelerRef.current.get(\"modeling\");\n        // Find bottommost element\n        const bottomMost = selectedElements.reduce((max, el)=>el.y + el.height > max.y + max.height ? el : max, selectedElements[0]);\n        const bottomEdge = bottomMost.y + bottomMost.height;\n        // Align all elements to bottommost\n        selectedElements.forEach((el)=>{\n            if (el.id !== bottomMost.id) {\n                const targetY = bottomEdge - el.height;\n                modeling.moveElements([\n                    el\n                ], {\n                    x: 0,\n                    y: targetY - el.y\n                });\n            }\n        });\n    }, [\n        selectedElements\n    ]);\n    // Preview handler - opens XML viewer modal\n    const handlePreview = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(async ()=>{\n        if (!modelerRef.current) return;\n        try {\n            const { xml } = await modelerRef.current.saveXML({\n                format: true\n            });\n            setCurrentXml(xml || \"\");\n            setShowXmlViewer(true);\n        } catch (err) {\n            console.error(\"Preview error:\", err);\n        }\n    }, []);\n    // Handle XML save from viewer\n    const handleXmlSave = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(async (newXml)=>{\n        if (!modelerRef.current) return;\n        try {\n            await modelerRef.current.importXML(newXml);\n            setShowXmlViewer(false);\n        } catch (err) {\n            console.error(\"XML import error:\", err);\n            alert(\"Failed to apply XML changes: \" + (err instanceof Error ? err.message : \"Unknown error\"));\n        }\n    }, []);\n    // Run Process handler (simulation)\n    const handleRunProcess = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(()=>{\n        if (!modelerRef.current) return;\n        console.log(\"Starting process simulation...\");\n        // This would integrate with a BPMN engine for execution\n        alert(\"Process simulation would start here. This requires integration with a BPMN engine.\");\n    }, []);\n    // Meeting/Presentation Mode handler\n    const handleMeetingMode = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(()=>{\n        setIsMeetingMode(!isMeetingMode);\n        if (!isMeetingMode) {\n            // Enter presentation mode - hide palette, maximize canvas\n            document.documentElement.requestFullscreen();\n        } else {\n            // Exit presentation mode\n            if (document.fullscreenElement) {\n                document.exitFullscreen();\n            }\n        }\n    }, [\n        isMeetingMode\n    ]);\n    // Minimap toggle handler\n    const handleToggleMinimap = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(()=>{\n        setIsMinimapOpen(!isMinimapOpen);\n        // BPMN.js doesn't have built-in minimap, would need custom implementation\n        console.log(\"Minimap toggle:\", !isMinimapOpen);\n    }, [\n        isMinimapOpen\n    ]);\n    // Language toggle handler\n    const handleToggleLanguage = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(()=>{\n        // Would implement i18n here\n        console.log(\"Language toggle - would implement i18n\");\n        alert(\"Language switching would be implemented with i18n library\");\n    }, []);\n    // Grid toggle handler\n    const handleToggleGrid = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(()=>{\n        setShowGrid((prev)=>{\n            const newValue = !prev;\n            // Apply or remove grid class to canvas container\n            if (modelerRef.current) {\n                const canvas = modelerRef.current.get(\"canvas\");\n                const container = canvas._container || canvas.getContainer();\n                if (container) {\n                    if (newValue) {\n                        container.classList.add(\"show-grid\");\n                    } else {\n                        container.classList.remove(\"show-grid\");\n                    }\n                }\n            }\n            return newValue;\n        });\n    }, []);\n    // Handle palette actions\n    const handlePaletteAction = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((action, event)=>{\n        if (!modelerRef.current) return;\n        console.log(\"Palette action:\", action);\n        // Handle tool actions\n        if (action.endsWith(\"-tool\")) {\n            setActiveTool(action.replace(\"-tool\", \"\"));\n            // Activate the tool in BPMN.js\n            const handTool = modelerRef.current.get(\"handTool\");\n            const lassoTool = modelerRef.current.get(\"lassoTool\");\n            const spaceTool = modelerRef.current.get(\"spaceTool\");\n            const globalConnect = modelerRef.current.get(\"globalConnect\");\n            switch(action){\n                case \"hand-tool\":\n                    handTool === null || handTool === void 0 ? void 0 : handTool.activateHand(event);\n                    break;\n                case \"lasso-tool\":\n                    lassoTool === null || lassoTool === void 0 ? void 0 : lassoTool.activateSelection(event);\n                    break;\n                case \"space-tool\":\n                    spaceTool === null || spaceTool === void 0 ? void 0 : spaceTool.activateSelection(event);\n                    break;\n                case \"global-connect-tool\":\n                    globalConnect === null || globalConnect === void 0 ? void 0 : globalConnect.toggle(event);\n                    break;\n            }\n            return;\n        }\n        // Handle element creation\n        if (action.startsWith(\"create.\")) {\n            const elementFactory = modelerRef.current.get(\"elementFactory\");\n            const create = modelerRef.current.get(\"create\");\n            const canvas = modelerRef.current.get(\"canvas\");\n            const modeling = modelerRef.current.get(\"modeling\");\n            // Parse the element type from action (keep original format)\n            const elementType = action.replace(\"create.\", \"\");\n            console.log(\"Creating element type:\", elementType);\n            let type = \"bpmn:Task\" // default\n            ;\n            let eventDefinitionType = undefined;\n            // Map all possible actions to BPMN types (matching registry actions)\n            const typeMap = {\n                // Start Events\n                \"start-event\": {\n                    type: \"bpmn:StartEvent\"\n                },\n                \"start-event-message\": {\n                    type: \"bpmn:StartEvent\",\n                    eventDefinitionType: \"bpmn:MessageEventDefinition\"\n                },\n                \"start-event-timer\": {\n                    type: \"bpmn:StartEvent\",\n                    eventDefinitionType: \"bpmn:TimerEventDefinition\"\n                },\n                \"start-event-conditional\": {\n                    type: \"bpmn:StartEvent\",\n                    eventDefinitionType: \"bpmn:ConditionalEventDefinition\"\n                },\n                \"start-event-signal\": {\n                    type: \"bpmn:StartEvent\",\n                    eventDefinitionType: \"bpmn:SignalEventDefinition\"\n                },\n                // End Events\n                \"end-event\": {\n                    type: \"bpmn:EndEvent\"\n                },\n                \"end-event-message\": {\n                    type: \"bpmn:EndEvent\",\n                    eventDefinitionType: \"bpmn:MessageEventDefinition\"\n                },\n                \"end-event-escalation\": {\n                    type: \"bpmn:EndEvent\",\n                    eventDefinitionType: \"bpmn:EscalationEventDefinition\"\n                },\n                \"end-event-error\": {\n                    type: \"bpmn:EndEvent\",\n                    eventDefinitionType: \"bpmn:ErrorEventDefinition\"\n                },\n                \"end-event-cancel\": {\n                    type: \"bpmn:EndEvent\",\n                    eventDefinitionType: \"bpmn:CancelEventDefinition\"\n                },\n                \"end-event-compensation\": {\n                    type: \"bpmn:EndEvent\",\n                    eventDefinitionType: \"bpmn:CompensateEventDefinition\"\n                },\n                \"end-event-signal\": {\n                    type: \"bpmn:EndEvent\",\n                    eventDefinitionType: \"bpmn:SignalEventDefinition\"\n                },\n                \"end-event-terminate\": {\n                    type: \"bpmn:EndEvent\",\n                    eventDefinitionType: \"bpmn:TerminateEventDefinition\"\n                },\n                // Intermediate Events\n                \"intermediate-event\": {\n                    type: \"bpmn:IntermediateThrowEvent\"\n                },\n                \"intermediate-event-message\": {\n                    type: \"bpmn:IntermediateThrowEvent\",\n                    eventDefinitionType: \"bpmn:MessageEventDefinition\"\n                },\n                \"intermediate-event-timer\": {\n                    type: \"bpmn:IntermediateCatchEvent\",\n                    eventDefinitionType: \"bpmn:TimerEventDefinition\"\n                },\n                \"intermediate-event-escalation\": {\n                    type: \"bpmn:IntermediateThrowEvent\",\n                    eventDefinitionType: \"bpmn:EscalationEventDefinition\"\n                },\n                \"intermediate-event-conditional\": {\n                    type: \"bpmn:IntermediateCatchEvent\",\n                    eventDefinitionType: \"bpmn:ConditionalEventDefinition\"\n                },\n                \"intermediate-event-link\": {\n                    type: \"bpmn:IntermediateThrowEvent\",\n                    eventDefinitionType: \"bpmn:LinkEventDefinition\"\n                },\n                \"intermediate-event-compensation\": {\n                    type: \"bpmn:IntermediateThrowEvent\",\n                    eventDefinitionType: \"bpmn:CompensateEventDefinition\"\n                },\n                \"intermediate-event-signal\": {\n                    type: \"bpmn:IntermediateThrowEvent\",\n                    eventDefinitionType: \"bpmn:SignalEventDefinition\"\n                },\n                // Tasks\n                \"task\": {\n                    type: \"bpmn:Task\"\n                },\n                \"user-task\": {\n                    type: \"bpmn:UserTask\"\n                },\n                \"service-task\": {\n                    type: \"bpmn:ServiceTask\"\n                },\n                \"script-task\": {\n                    type: \"bpmn:ScriptTask\"\n                },\n                \"business-rule-task\": {\n                    type: \"bpmn:BusinessRuleTask\"\n                },\n                \"send-task\": {\n                    type: \"bpmn:SendTask\"\n                },\n                \"receive-task\": {\n                    type: \"bpmn:ReceiveTask\"\n                },\n                \"manual-task\": {\n                    type: \"bpmn:ManualTask\"\n                },\n                // Gateways\n                \"exclusive-gateway\": {\n                    type: \"bpmn:ExclusiveGateway\"\n                },\n                \"parallel-gateway\": {\n                    type: \"bpmn:ParallelGateway\"\n                },\n                \"inclusive-gateway\": {\n                    type: \"bpmn:InclusiveGateway\"\n                },\n                \"event-based-gateway\": {\n                    type: \"bpmn:EventBasedGateway\"\n                },\n                \"complex-gateway\": {\n                    type: \"bpmn:ComplexGateway\"\n                },\n                // Sub Process\n                \"subprocess-expanded\": {\n                    type: \"bpmn:SubProcess\",\n                    isExpanded: true\n                },\n                \"subprocess-collapsed\": {\n                    type: \"bpmn:SubProcess\",\n                    isExpanded: false\n                },\n                \"event-subprocess\": {\n                    type: \"bpmn:SubProcess\",\n                    triggeredByEvent: true\n                },\n                \"transaction\": {\n                    type: \"bpmn:Transaction\"\n                },\n                \"call-activity\": {\n                    type: \"bpmn:CallActivity\"\n                },\n                // Data\n                \"data-object\": {\n                    type: \"bpmn:DataObjectReference\"\n                },\n                \"data-store\": {\n                    type: \"bpmn:DataStoreReference\"\n                },\n                \"data-input\": {\n                    type: \"bpmn:DataInput\"\n                },\n                \"data-output\": {\n                    type: \"bpmn:DataOutput\"\n                },\n                // Participants\n                \"participant-expanded\": {\n                    type: \"bpmn:Participant\"\n                },\n                \"participant\": {\n                    type: \"bpmn:Participant\"\n                },\n                \"lane\": {\n                    type: \"bpmn:Lane\"\n                },\n                // Artifacts\n                \"group\": {\n                    type: \"bpmn:Group\"\n                },\n                \"text-annotation\": {\n                    type: \"bpmn:TextAnnotation\"\n                }\n            };\n            const elementConfig = typeMap[elementType] || {\n                type: \"bpmn:Task\"\n            };\n            // Create the shape with proper configuration\n            const shapeConfig = {\n                type: elementConfig.type\n            };\n            // Add event definition if needed\n            if (elementConfig.eventDefinitionType) {\n                const bpmnFactory = modelerRef.current.get(\"bpmnFactory\");\n                const eventDefinition = bpmnFactory.create(elementConfig.eventDefinitionType);\n                shapeConfig.eventDefinitionType = elementConfig.eventDefinitionType;\n                shapeConfig.businessObject = bpmnFactory.create(elementConfig.type, {\n                    eventDefinitions: [\n                        eventDefinition\n                    ]\n                });\n            }\n            // Handle expanded/collapsed state\n            if (\"isExpanded\" in elementConfig) {\n                shapeConfig.isExpanded = elementConfig.isExpanded;\n            }\n            if (\"triggeredByEvent\" in elementConfig) {\n                shapeConfig.triggeredByEvent = elementConfig.triggeredByEvent;\n            }\n            const shape = elementFactory.createShape(shapeConfig);\n            // If it's a drag event, use drag coordinates\n            if (event instanceof DragEvent) {\n                console.log(\"Starting drag create for:\", elementType);\n                // For drag events, we need to let BPMN.js handle the drop\n                // The create module expects the drag event to continue\n                create.start(event, shape);\n            } else {\n                // For click events, directly create the shape at a position\n                console.log(\"Creating element via click:\", elementType);\n                const rootElement = canvas.getRootElement();\n                const viewport = canvas.viewbox();\n                // Calculate center position accounting for current zoom\n                const centerX = viewport.x + viewport.width / 2;\n                const centerY = viewport.y + viewport.height / 2;\n                // Directly create the shape using modeling\n                modeling.createShape(shape, {\n                    x: centerX,\n                    y: centerY\n                }, rootElement);\n            }\n        }\n    }, []);\n    if (error) {\n        return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n            className: \"h-screen flex items-center justify-center bg-gray-50\",\n            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"text-center\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h2\", {\n                        className: \"text-xl font-semibold text-red-600 mb-2\",\n                        children: \"Error Loading Studio\"\n                    }, void 0, false, {\n                        fileName: \"/Users/home/Desktop/mvp/components/bpmn/BpmnStudioFixed.tsx\",\n                        lineNumber: 1866,\n                        columnNumber: 11\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                        className: \"text-gray-600\",\n                        children: error\n                    }, void 0, false, {\n                        fileName: \"/Users/home/Desktop/mvp/components/bpmn/BpmnStudioFixed.tsx\",\n                        lineNumber: 1867,\n                        columnNumber: 11\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                        onClick: ()=>window.location.reload(),\n                        className: \"mt-4 px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700\",\n                        children: \"Reload Page\"\n                    }, void 0, false, {\n                        fileName: \"/Users/home/Desktop/mvp/components/bpmn/BpmnStudioFixed.tsx\",\n                        lineNumber: 1868,\n                        columnNumber: 11\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/home/Desktop/mvp/components/bpmn/BpmnStudioFixed.tsx\",\n                lineNumber: 1865,\n                columnNumber: 9\n            }, this)\n        }, void 0, false, {\n            fileName: \"/Users/home/Desktop/mvp/components/bpmn/BpmnStudioFixed.tsx\",\n            lineNumber: 1864,\n            columnNumber: 7\n        }, this);\n    }\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"h-screen flex flex-col bg-background\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_bpmn_toolbar__WEBPACK_IMPORTED_MODULE_2__.BpmnToolbar, {\n                onSave: handleSave,\n                onExport: handleExport,\n                onImport: ()=>{\n                    var _fileInputRef_current;\n                    return (_fileInputRef_current = fileInputRef.current) === null || _fileInputRef_current === void 0 ? void 0 : _fileInputRef_current.click();\n                },\n                onUndo: handleUndo,\n                onRedo: handleRedo,\n                onZoomIn: handleZoomIn,\n                onZoomOut: handleZoomOut,\n                onFitToViewport: handleZoomReset,\n                onClear: handleClear,\n                onToggleTheme: handleThemeToggle,\n                onAlignLeft: handleAlignLeft,\n                onAlignCenter: handleAlignCenter,\n                onAlignRight: handleAlignRight,\n                onAlignTop: handleAlignTop,\n                onAlignMiddle: handleAlignMiddle,\n                onAlignBottom: handleAlignBottom,\n                onPreview: handlePreview,\n                onRun: handleRunProcess,\n                onMeetingMode: handleMeetingMode,\n                onToggleMinimap: handleToggleMinimap,\n                onToggleLanguage: handleToggleLanguage,\n                onToggleGrid: handleToggleGrid,\n                theme: theme,\n                zoomLevel: zoomLevel,\n                canUndo: canUndo,\n                canRedo: canRedo,\n                disabled: saving,\n                isMeetingMode: isMeetingMode,\n                isMinimapOpen: isMinimapOpen,\n                showGrid: showGrid\n            }, void 0, false, {\n                fileName: \"/Users/home/Desktop/mvp/components/bpmn/BpmnStudioFixed.tsx\",\n                lineNumber: 1882,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"flex-1 flex overflow-hidden\",\n                children: [\n                    !isMeetingMode && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_bpmn_elements_palette__WEBPACK_IMPORTED_MODULE_3__.BpmnElementsPalette, {\n                        onAction: handlePaletteAction,\n                        activeTool: activeTool\n                    }, void 0, false, {\n                        fileName: \"/Users/home/Desktop/mvp/components/bpmn/BpmnStudioFixed.tsx\",\n                        lineNumber: 1919,\n                        columnNumber: 11\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"flex-1 relative bg-gray-50 dark:bg-gray-900\",\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                ref: containerRef,\n                                className: \"w-full h-full\",\n                                style: {\n                                    position: \"absolute\",\n                                    top: 0,\n                                    left: 0,\n                                    right: 0,\n                                    bottom: 0\n                                }\n                            }, void 0, false, {\n                                fileName: \"/Users/home/Desktop/mvp/components/bpmn/BpmnStudioFixed.tsx\",\n                                lineNumber: 1927,\n                                columnNumber: 11\n                            }, this),\n                            !isReady && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"absolute inset-0 flex items-center justify-center bg-gray-50/90 dark:bg-gray-900/90 pointer-events-none\",\n                                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                    className: \"text-center\",\n                                    children: [\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                            className: \"animate-spin rounded-full h-12 w-12 border-b-2 border-blue-600 mx-auto\"\n                                        }, void 0, false, {\n                                            fileName: \"/Users/home/Desktop/mvp/components/bpmn/BpmnStudioFixed.tsx\",\n                                            lineNumber: 1941,\n                                            columnNumber: 17\n                                        }, this),\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                            className: \"mt-4 text-gray-600 dark:text-gray-400\",\n                                            children: \"Initializing BPMN Studio...\"\n                                        }, void 0, false, {\n                                            fileName: \"/Users/home/Desktop/mvp/components/bpmn/BpmnStudioFixed.tsx\",\n                                            lineNumber: 1942,\n                                            columnNumber: 17\n                                        }, this)\n                                    ]\n                                }, void 0, true, {\n                                    fileName: \"/Users/home/Desktop/mvp/components/bpmn/BpmnStudioFixed.tsx\",\n                                    lineNumber: 1940,\n                                    columnNumber: 15\n                                }, this)\n                            }, void 0, false, {\n                                fileName: \"/Users/home/Desktop/mvp/components/bpmn/BpmnStudioFixed.tsx\",\n                                lineNumber: 1939,\n                                columnNumber: 13\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/Users/home/Desktop/mvp/components/bpmn/BpmnStudioFixed.tsx\",\n                        lineNumber: 1926,\n                        columnNumber: 9\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/home/Desktop/mvp/components/bpmn/BpmnStudioFixed.tsx\",\n                lineNumber: 1916,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                ref: fileInputRef,\n                type: \"file\",\n                accept: \".bpmn,.xml\",\n                onChange: handleImport,\n                className: \"hidden\"\n            }, void 0, false, {\n                fileName: \"/Users/home/Desktop/mvp/components/bpmn/BpmnStudioFixed.tsx\",\n                lineNumber: 1950,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_XmlViewerModal__WEBPACK_IMPORTED_MODULE_4__.XmlViewerModal, {\n                isOpen: showXmlViewer,\n                onClose: ()=>setShowXmlViewer(false),\n                xml: currentXml,\n                onSave: handleXmlSave,\n                readOnly: false\n            }, void 0, false, {\n                fileName: \"/Users/home/Desktop/mvp/components/bpmn/BpmnStudioFixed.tsx\",\n                lineNumber: 1959,\n                columnNumber: 7\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/home/Desktop/mvp/components/bpmn/BpmnStudioFixed.tsx\",\n        lineNumber: 1880,\n        columnNumber: 5\n    }, this);\n}\n_s(BpmnStudioFixed, \"5Zl8qrJMddFoghqgo2Pl6g6tzYk=\", false, function() {\n    return [\n        _components_theme_provider__WEBPACK_IMPORTED_MODULE_5__.useTheme\n    ];\n});\n_c = BpmnStudioFixed;\nvar _c;\n$RefreshReg$(_c, \"BpmnStudioFixed\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2NvbXBvbmVudHMvYnBtbi9CcG1uU3R1ZGlvRml4ZWQudHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBRWdFO0FBQ25CO0FBQ0Q7QUFDaUI7QUFDWjtBQUNLO0FBRXRELGdEQUFnRDtBQUVoRCxNQUFNUyxlQUFnQjtBQW9CZixTQUFTQzs7SUFDZCxNQUFNQyxlQUFlViw2Q0FBTUEsQ0FBaUI7SUFDNUMsTUFBTVcsYUFBYVgsNkNBQU1BLENBQXFCO0lBQzlDLE1BQU1ZLGVBQWVaLDZDQUFNQSxDQUFtQjtJQUU5QyxNQUFNLENBQUNhLFNBQVNDLFdBQVcsR0FBR2IsK0NBQVFBLENBQUM7SUFDdkMsTUFBTSxDQUFDYyxPQUFPQyxTQUFTLEdBQUdmLCtDQUFRQSxDQUFnQjtJQUNsRCxNQUFNLENBQUNnQixTQUFTQyxXQUFXLEdBQUdqQiwrQ0FBUUEsQ0FBQztJQUN2QyxNQUFNLENBQUNrQixTQUFTQyxXQUFXLEdBQUduQiwrQ0FBUUEsQ0FBQztJQUN2QyxNQUFNLEVBQUVvQixLQUFLLEVBQUVDLFFBQVEsRUFBRSxHQUFHZixvRUFBUUE7SUFDcEMsTUFBTWdCLGtCQUFrQnZCLDZDQUFNQSxDQUEwQjtJQUN4RCxNQUFNLENBQUN3QixXQUFXQyxhQUFhLEdBQUd4QiwrQ0FBUUEsQ0FBQztJQUMzQyxNQUFNLENBQUN5QixRQUFRQyxVQUFVLEdBQUcxQiwrQ0FBUUEsQ0FBQztJQUNyQyxNQUFNLENBQUMyQixZQUFZQyxjQUFjLEdBQUc1QiwrQ0FBUUEsQ0FBcUI2QjtJQUNqRSxNQUFNLENBQUNDLGVBQWVDLGlCQUFpQixHQUFHL0IsK0NBQVFBLENBQUM7SUFDbkQsTUFBTSxDQUFDZ0MsZUFBZUMsaUJBQWlCLEdBQUdqQywrQ0FBUUEsQ0FBQztJQUNuRCxNQUFNLENBQUNrQyxVQUFVQyxZQUFZLEdBQUduQywrQ0FBUUEsQ0FBQztJQUN6QyxNQUFNLENBQUNvQyxhQUFhQyxlQUFlLEdBQUdyQywrQ0FBUUEsQ0FBQztJQUMvQyxN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UixPQUFPQTtnQkFDUEcsV0FBV0E7Z0JBQ1hQLFNBQVNBO2dCQUNURSxTQUFTQTtnQkFDVHFWLFVBQVU5VTtnQkFDVkssZUFBZUE7Z0JBQ2ZFLGVBQWVBO2dCQUNmRSxVQUFVQTs7Ozs7OzBCQUlaLDhEQUFDdVM7Z0JBQUlDLFdBQVU7O29CQUVaLENBQUM1UywrQkFDQSw4REFBQzFCLHVFQUFtQkE7d0JBQ2xCb1csVUFBVTlEO3dCQUNWL1EsWUFBWUE7Ozs7OztrQ0FLaEIsOERBQUM4Uzt3QkFBSUMsV0FBVTs7MENBQ2IsOERBQUNEO2dDQUNDZ0MsS0FBS2hXO2dDQUNMaVUsV0FBVTtnQ0FDVi9RLE9BQU87b0NBQ0w4RSxVQUFVO29DQUNWaU8sS0FBSztvQ0FDTEMsTUFBTTtvQ0FDTkMsT0FBTztvQ0FDUEMsUUFBUTtnQ0FDVjs7Ozs7OzRCQUVELENBQUNqVyx5QkFDQSw4REFBQzZUO2dDQUFJQyxXQUFVOzBDQUNiLDRFQUFDRDtvQ0FBSUMsV0FBVTs7c0RBQ2IsOERBQUNEOzRDQUFJQyxXQUFVOzs7Ozs7c0RBQ2YsOERBQUNFOzRDQUFFRixXQUFVO3NEQUF3Qzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7MEJBUS9ELDhEQUFDb0M7Z0JBQ0NMLEtBQUs5VjtnQkFDTHdILE1BQUs7Z0JBQ0w0TyxRQUFPO2dCQUNQQyxVQUFVNUk7Z0JBQ1ZzRyxXQUFVOzs7Ozs7MEJBSVosOERBQUNyVSwyREFBY0E7Z0JBQ2I0VyxRQUFRM1U7Z0JBQ1I0VSxTQUFTLElBQU0zVSxpQkFBaUI7Z0JBQ2hDNEosS0FBSzNKO2dCQUNMeVMsUUFBUW5EO2dCQUNScUYsVUFBVTs7Ozs7Ozs7Ozs7O0FBSWxCO0dBaDVEZ0IzVzs7UUFTY0YsZ0VBQVFBOzs7S0FUdEJFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2NvbXBvbmVudHMvYnBtbi9CcG1uU3R1ZGlvRml4ZWQudHN4P2M5NmMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnXG5cbmltcG9ydCB7IHVzZUVmZmVjdCwgdXNlUmVmLCB1c2VTdGF0ZSwgdXNlQ2FsbGJhY2sgfSBmcm9tICdyZWFjdCdcbmltcG9ydCBCcG1uTW9kZWxlciBmcm9tICdicG1uLWpzL2xpYi9Nb2RlbGVyJ1xuaW1wb3J0IHsgQnBtblRvb2xiYXIgfSBmcm9tICcuL2JwbW4tdG9vbGJhcidcbmltcG9ydCB7IEJwbW5FbGVtZW50c1BhbGV0dGUgfSBmcm9tICcuL2JwbW4tZWxlbWVudHMtcGFsZXR0ZSdcbmltcG9ydCB7IFhtbFZpZXdlck1vZGFsIH0gZnJvbSAnLi9YbWxWaWV3ZXJNb2RhbCdcbmltcG9ydCB7IHVzZVRoZW1lIH0gZnJvbSAnQC9jb21wb25lbnRzL3RoZW1lLXByb3ZpZGVyJ1xuXG4vLyBOTyBDU1MgaW1wb3J0cyBoZXJlIC0gdGhleSBhcmUgaW4gZ2xvYmFscy5jc3NcblxuY29uc3QgREVGQVVMVF9CUE1OID0gYDw/eG1sIHZlcnNpb249XCIxLjBcIiBlbmNvZGluZz1cIlVURi04XCI/PlxuPGJwbW4yOmRlZmluaXRpb25zIHhtbG5zOnhzaT1cImh0dHA6Ly93d3cudzMub3JnLzIwMDEvWE1MU2NoZW1hLWluc3RhbmNlXCIgXG4gIHhtbG5zOmJwbW4yPVwiaHR0cDovL3d3dy5vbWcub3JnL3NwZWMvQlBNTi8yMDEwMDUyNC9NT0RFTFwiIFxuICB4bWxuczpicG1uZGk9XCJodHRwOi8vd3d3Lm9tZy5vcmcvc3BlYy9CUE1OLzIwMTAwNTI0L0RJXCIgXG4gIHhtbG5zOmRjPVwiaHR0cDovL3d3dy5vbWcub3JnL3NwZWMvREQvMjAxMDA1MjQvRENcIiBcbiAgeG1sbnM6ZGk9XCJodHRwOi8vd3d3Lm9tZy5vcmcvc3BlYy9ERC8yMDEwMDUyNC9ESVwiIFxuICBpZD1cInNhbXBsZS1kaWFncmFtXCIgXG4gIHRhcmdldE5hbWVzcGFjZT1cImh0dHA6Ly9icG1uLmlvL3NjaGVtYS9icG1uXCI+XG4gIDxicG1uMjpwcm9jZXNzIGlkPVwiUHJvY2Vzc18xXCIgaXNFeGVjdXRhYmxlPVwiZmFsc2VcIj5cbiAgICA8YnBtbjI6c3RhcnRFdmVudCBpZD1cIlN0YXJ0RXZlbnRfMVwiIG5hbWU9XCJTdGFydFwiLz5cbiAgPC9icG1uMjpwcm9jZXNzPlxuICA8YnBtbmRpOkJQTU5EaWFncmFtIGlkPVwiQlBNTkRpYWdyYW1fMVwiPlxuICAgIDxicG1uZGk6QlBNTlBsYW5lIGlkPVwiQlBNTlBsYW5lXzFcIiBicG1uRWxlbWVudD1cIlByb2Nlc3NfMVwiPlxuICAgICAgPGJwbW5kaTpCUE1OU2hhcGUgaWQ9XCJfQlBNTlNoYXBlX1N0YXJ0RXZlbnRfMlwiIGJwbW5FbGVtZW50PVwiU3RhcnRFdmVudF8xXCI+XG4gICAgICAgIDxkYzpCb3VuZHMgaGVpZ2h0PVwiMzYuMFwiIHdpZHRoPVwiMzYuMFwiIHg9XCI0MTIuMFwiIHk9XCIyNDAuMFwiLz5cbiAgICAgIDwvYnBtbmRpOkJQTU5TaGFwZT5cbiAgICA8L2JwbW5kaTpCUE1OUGxhbmU+XG4gIDwvYnBtbmRpOkJQTU5EaWFncmFtPlxuPC9icG1uMjpkZWZpbml0aW9ucz5gXG5cbmV4cG9ydCBmdW5jdGlvbiBCcG1uU3R1ZGlvRml4ZWQoKSB7XG4gIGNvbnN0IGNvbnRhaW5lclJlZiA9IHVzZVJlZjxIVE1MRGl2RWxlbWVudD4obnVsbClcbiAgY29uc3QgbW9kZWxlclJlZiA9IHVzZVJlZjxCcG1uTW9kZWxlciB8IG51bGw+KG51bGwpXG4gIGNvbnN0IGZpbGVJbnB1dFJlZiA9IHVzZVJlZjxIVE1MSW5wdXRFbGVtZW50PihudWxsKVxuICBcbiAgY29uc3QgW2lzUmVhZHksIHNldElzUmVhZHldID0gdXNlU3RhdGUoZmFsc2UpXG4gIGNvbnN0IFtlcnJvciwgc2V0RXJyb3JdID0gdXNlU3RhdGU8c3RyaW5nIHwgbnVsbD4obnVsbClcbiAgY29uc3QgW2NhblVuZG8sIHNldENhblVuZG9dID0gdXNlU3RhdGUoZmFsc2UpXG4gIGNvbnN0IFtjYW5SZWRvLCBzZXRDYW5SZWRvXSA9IHVzZVN0YXRlKGZhbHNlKVxuICBjb25zdCB7IHRoZW1lLCBzZXRUaGVtZSB9ID0gdXNlVGhlbWUoKVxuICBjb25zdCBzdHlsZUVsZW1lbnRSZWYgPSB1c2VSZWY8SFRNTFN0eWxlRWxlbWVudCB8IG51bGw+KG51bGwpXG4gIGNvbnN0IFt6b29tTGV2ZWwsIHNldFpvb21MZXZlbF0gPSB1c2VTdGF0ZSgxMDApXG4gIGNvbnN0IFtzYXZpbmcsIHNldFNhdmluZ10gPSB1c2VTdGF0ZShmYWxzZSlcbiAgY29uc3QgW2FjdGl2ZVRvb2wsIHNldEFjdGl2ZVRvb2xdID0gdXNlU3RhdGU8c3RyaW5nIHwgdW5kZWZpbmVkPih1bmRlZmluZWQpXG4gIGNvbnN0IFtpc01lZXRpbmdNb2RlLCBzZXRJc01lZXRpbmdNb2RlXSA9IHVzZVN0YXRlKGZhbHNlKVxuICBjb25zdCBbaXNNaW5pbWFwT3Blbiwgc2V0SXNNaW5pbWFwT3Blbl0gPSB1c2VTdGF0ZShmYWxzZSlcbiAgY29uc3QgW3Nob3dHcmlkLCBzZXRTaG93R3JpZF0gPSB1c2VTdGF0ZSh0cnVlKVxuICBjb25zdCBbc2hvd1ByZXZpZXcsIHNldFNob3dQcmV2aWV3XSA9IHVzZVN0YXRlKGZhbHNlKVxuICBjb25zdCBbc2hvd1htbFZpZXdlciwgc2V0U2hvd1htbFZpZXdlcl0gPSB1c2VTdGF0ZShmYWxzZSlcbiAgY29uc3QgW2N1cnJlbnRYbWwsIHNldEN1cnJlbnRYbWxdID0gdXNlU3RhdGUoJycpXG4gIGNvbnN0IFtzZWxlY3RlZEVsZW1lbnRzLCBzZXRTZWxlY3RlZEVsZW1lbnRzXSA9IHVzZVN0YXRlPGFueVtdPihbXSlcblxuICAvLyBIZWxwZXIgZnVuY3Rpb24gdG8gYXBwbHkgc3R5bGVzIChuZWVkcyB0byBiZSBkZWZpbmVkIGJlZm9yZSB1c2VFZmZlY3QpXG4gIGNvbnN0IGFwcGx5QnBtblN0eWxlcyA9IHVzZUNhbGxiYWNrKChtb2RlbGVyOiBCcG1uTW9kZWxlciB8IG51bGwsIGN1cnJlbnRUaGVtZTogJ2xpZ2h0JyB8ICdkYXJrJykgPT4ge1xuICAgIGlmICghbW9kZWxlcikgcmV0dXJuXG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGNhbnZhcyA9IG1vZGVsZXIuZ2V0KCdjYW52YXMnKSBhcyBhbnlcbiAgICAgIGlmICghY2FudmFzKSByZXR1cm5cbiAgICAgIFxuICAgICAgLy8gR2V0IHRoZSBjb250YWluZXIgYW5kIGVuc3VyZSBTVkcgaXMgYXZhaWxhYmxlXG4gICAgICBjb25zdCBjb250YWluZXIgPSBjYW52YXMuX2NvbnRhaW5lciB8fCBjYW52YXMuZ2V0Q29udGFpbmVyKClcbiAgICAgIGNvbnN0IHN2ZyA9IGNvbnRhaW5lcj8ucXVlcnlTZWxlY3Rvcignc3ZnJykgfHwgY2FudmFzLl9zdmdcbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgaWYgU1ZHIGVsZW1lbnQgZXhpc3RzIGFuZCBoYXMgbmVjZXNzYXJ5IG1ldGhvZHNcbiAgICAgIGlmICghc3ZnIHx8IHR5cGVvZiBzdmcuY3JlYXRlU1ZHTWF0cml4ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignU1ZHIGVsZW1lbnQgbm90IHJlYWR5LCBkZWxheWluZyBzdHlsZSBhcHBsaWNhdGlvbicpXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4gYXBwbHlCcG1uU3R5bGVzKG1vZGVsZXIsIGN1cnJlbnRUaGVtZSksIDEwMClcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIFJldXNlIGV4aXN0aW5nIHN0eWxlIGVsZW1lbnQgb3IgY3JlYXRlIG5ldyBvbmVcbiAgICAgIGxldCBzdHlsZSA9IHN0eWxlRWxlbWVudFJlZi5jdXJyZW50XG4gICAgICBpZiAoIXN0eWxlKSB7XG4gICAgICAgIHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKVxuICAgICAgICBzdHlsZS5pZCA9ICdicG1uLWN1c3RvbS1zdHlsZXMnXG4gICAgICAgIHN0eWxlRWxlbWVudFJlZi5jdXJyZW50ID0gc3R5bGVcbiAgICAgIH1cbiAgICBcbiAgICAvLyBEZWZpbmUgc3R5bGVzIGJhc2VkIG9uIGN1cnJlbnQgdGhlbWVcbiAgICBjb25zdCBpc0RhcmsgPSBjdXJyZW50VGhlbWUgPT09ICdkYXJrJ1xuICAgIGNvbnNvbGUubG9nKCdBcHBseWluZyBCUE1OIHN0eWxlcyBmb3IgdGhlbWU6JywgY3VycmVudFRoZW1lLCAnaXNEYXJrOicsIGlzRGFyaylcbiAgICBcbiAgICBzdHlsZS50ZXh0Q29udGVudCA9IGBcbiAgICAgIC8qIEVuc3VyZSBwcm9wZXIgcG9pbnRlciBldmVudHMgZm9yIGRyYWcgYW5kIGRyb3AgKi9cbiAgICAgIC5kanMtY29udGFpbmVyIHtcbiAgICAgICAgcG9pbnRlci1ldmVudHM6IGF1dG8gIWltcG9ydGFudDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLmRqcy1lbGVtZW50ID4gKiB7XG4gICAgICAgIHBvaW50ZXItZXZlbnRzOiBhbGwgIWltcG9ydGFudDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLmRqcy1oaXQge1xuICAgICAgICBwb2ludGVyLWV2ZW50czogYWxsICFpbXBvcnRhbnQ7XG4gICAgICAgIGZpbGw6IHRyYW5zcGFyZW50ICFpbXBvcnRhbnQ7XG4gICAgICAgIHN0cm9rZTogdHJhbnNwYXJlbnQgIWltcG9ydGFudDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLmRqcy1zaGFwZSAuZGpzLWhpdCB7XG4gICAgICAgIGZpbGw6IHRyYW5zcGFyZW50ICFpbXBvcnRhbnQ7XG4gICAgICAgIHBvaW50ZXItZXZlbnRzOiBhbGwgIWltcG9ydGFudDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLmRqcy1kcmFnLWFjdGl2ZSB7XG4gICAgICAgIHBvaW50ZXItZXZlbnRzOiBhbGwgIWltcG9ydGFudDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLyogPT09IEFDVElWSVRJRVMgKFRhc2tzLCBTdWItcHJvY2Vzc2VzKSA9PT0gKi9cbiAgICAgIFxuICAgICAgLyogVGFzayByZWN0YW5nbGVzIC0gTUFYSU1VTSBTUEVDSUZJQ0lUWSAqL1xuICAgICAgLmRqcy1zaGFwZSAuZGpzLXZpc3VhbCA+IHJlY3QsXG4gICAgICAuZGpzLWVsZW1lbnRbZGF0YS1lbGVtZW50LWlkKj1cIlRhc2tcIl0gcmVjdCxcbiAgICAgIC5kanMtZWxlbWVudFtkYXRhLWVsZW1lbnQtaWQqPVwiQWN0aXZpdHlcIl0gcmVjdCxcbiAgICAgIHJlY3QuZGpzLWhpdCxcbiAgICAgIHJlY3QuZGpzLW91dGxpbmUge1xuICAgICAgICBzdHJva2U6ICR7aXNEYXJrID8gJyNmZmZmZmYnIDogJyMwMDAwMDAnfSAhaW1wb3J0YW50O1xuICAgICAgICBzdHJva2UtZGFzaGFycmF5OiBub25lICFpbXBvcnRhbnQ7XG4gICAgICAgIHN0cm9rZS13aWR0aDogMnB4ICFpbXBvcnRhbnQ7XG4gICAgICAgIGZpbGw6ICR7aXNEYXJrID8gJyMxZjI5MzcnIDogJyNmZmZmZmYnfSAhaW1wb3J0YW50O1xuICAgICAgfVxuICAgICAgXG4gICAgICAvKiBBbGwgcmVjdCBlbGVtZW50cyBpbiBzaGFwZXMgKGZhbGxiYWNrKSAqL1xuICAgICAgLmRqcy1zaGFwZSByZWN0IHtcbiAgICAgICAgc3Ryb2tlOiAke2lzRGFyayA/ICcjZmZmZmZmJyA6ICcjMDAwMDAwJ30gIWltcG9ydGFudDtcbiAgICAgICAgZmlsbDogJHtpc0RhcmsgPyAnIzFmMjkzNycgOiAnI2ZmZmZmZid9ICFpbXBvcnRhbnQ7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8qIE5VQ0xFQVIgT1BUSU9OOiBPdmVycmlkZSBBTlkgcmVjdCB3aXRoIGJsYWNrIHN0cm9rZSBpbiBkYXJrIG1vZGUgKi9cbiAgICAgICR7aXNEYXJrID8gYFxuICAgICAgICByZWN0W3N0cm9rZT1cIiMwMDAwMDBcIl0sXG4gICAgICAgIHJlY3Rbc3Ryb2tlPVwiYmxhY2tcIl0sXG4gICAgICAgIHJlY3Rbc3Ryb2tlPVwicmdiKDAsIDAsIDApXCJdLFxuICAgICAgICByZWN0W3N0eWxlKj1cInN0cm9rZTogcmdiKDAsIDAsIDApXCJdLFxuICAgICAgICByZWN0W3N0eWxlKj1cInN0cm9rZTojMDAwMDAwXCJdLFxuICAgICAgICByZWN0W3N0eWxlKj1cInN0cm9rZTogIzAwMDAwMFwiXSxcbiAgICAgICAgcmVjdFtzdHlsZSo9XCJzdHJva2U6YmxhY2tcIl0ge1xuICAgICAgICAgIHN0cm9rZTogI2ZmZmZmZiAhaW1wb3J0YW50O1xuICAgICAgICAgIHN0cm9rZS1vcGFjaXR5OiAxICFpbXBvcnRhbnQ7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8qIFNVUEVSIE5VQ0xFQVI6IFRhcmdldCBUYXNrcyBieSBBTlkgbWVhbnMgbmVjZXNzYXJ5ICovXG4gICAgICAgIGdbZGF0YS1lbGVtZW50LWlkKj1cIlRhc2tcIl0gcmVjdCxcbiAgICAgICAgZ1tkYXRhLWVsZW1lbnQtaWQqPVwiQWN0aXZpdHlcIl0gcmVjdCxcbiAgICAgICAgLmRqcy1ncm91cFtkYXRhLWVsZW1lbnQtaWQqPVwiVGFza1wiXSByZWN0LFxuICAgICAgICBnLmRqcy1lbGVtZW50IHJlY3QsXG4gICAgICAgIGcuZGpzLXNoYXBlIHJlY3QsXG4gICAgICAgIHN2ZyByZWN0Om5vdChbZmlsbD1cIm5vbmVcIl0pOm5vdChbZmlsbD1cInRyYW5zcGFyZW50XCJdKSB7XG4gICAgICAgICAgc3Ryb2tlOiAjZmZmZmZmICFpbXBvcnRhbnQ7XG4gICAgICAgICAgc3Ryb2tlLW9wYWNpdHk6IDEgIWltcG9ydGFudDtcbiAgICAgICAgICBzdHJva2Utd2lkdGg6IDJweCAhaW1wb3J0YW50O1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvKiBUYXJnZXQgdGhlIHZpc3VhbCByZWN0IHNwZWNpZmljYWxseSAqL1xuICAgICAgICBnW2RhdGEtZWxlbWVudC1pZCo9XCJUYXNrXCJdID4gLmRqcy12aXN1YWwgPiByZWN0LFxuICAgICAgICBnW2RhdGEtZWxlbWVudC1pZCo9XCJBY3Rpdml0eVwiXSA+IC5kanMtdmlzdWFsID4gcmVjdCB7XG4gICAgICAgICAgc3Ryb2tlOiAjZmZmZmZmICFpbXBvcnRhbnQ7XG4gICAgICAgICAgZmlsbDogIzFmMjkzNyAhaW1wb3J0YW50O1xuICAgICAgICAgIHN0cm9rZS1vcGFjaXR5OiAxICFpbXBvcnRhbnQ7XG4gICAgICAgIH1cbiAgICAgIGAgOiAnJ31cbiAgICAgIFxuICAgICAgLyogVGFzayB0eXBlIGljb25zICh1c2VyLCBzZXJ2aWNlLCBzY3JpcHQsIGV0YykgKi9cbiAgICAgIC5kanMtZWxlbWVudFtkYXRhLWVsZW1lbnQtaWQqPVwiVGFza1wiXSAuZGpzLXZpc3VhbCA+IHBhdGgsXG4gICAgICAuZGpzLWVsZW1lbnRbZGF0YS1lbGVtZW50LWlkKj1cIlRhc2tcIl0gLmRqcy12aXN1YWwgPiBnID4gcGF0aCB7XG4gICAgICAgIHN0cm9rZTogJHtpc0RhcmsgPyAnI2ZmZmZmZicgOiAnIzAwMDAwMCd9ICFpbXBvcnRhbnQ7XG4gICAgICAgIGZpbGw6ICR7aXNEYXJrID8gJyNmZmZmZmYnIDogJyMwMDAwMDAnfSAhaW1wb3J0YW50O1xuICAgICAgfVxuICAgICAgXG4gICAgICAvKiBTdWItcHJvY2VzcyBtYXJrZXJzICgrKSAqL1xuICAgICAgLmRqcy1lbGVtZW50W2RhdGEtZWxlbWVudC1pZCo9XCJTdWJQcm9jZXNzXCJdIC5kanMtdmlzdWFsID4gcGF0aCB7XG4gICAgICAgIHN0cm9rZTogJHtpc0RhcmsgPyAnI2ZmZmZmZicgOiAnIzAwMDAwMCd9ICFpbXBvcnRhbnQ7XG4gICAgICAgIGZpbGw6IG5vbmUgIWltcG9ydGFudDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLyogPT09IEVWRU5UUyA9PT0gKi9cbiAgICAgIFxuICAgICAgLyogRXZlbnQgY2lyY2xlcyAob3V0ZXIpICovXG4gICAgICAuZGpzLXNoYXBlIC5kanMtdmlzdWFsID4gY2lyY2xlIHtcbiAgICAgICAgc3Ryb2tlOiAke2lzRGFyayA/ICcjZmZmZmZmJyA6ICcjMDAwMDAwJ30gIWltcG9ydGFudDtcbiAgICAgICAgc3Ryb2tlLXdpZHRoOiAycHggIWltcG9ydGFudDtcbiAgICAgICAgZmlsbDogJHtpc0RhcmsgPyAnIzFmMjkzNycgOiAnI2ZmZmZmZid9ICFpbXBvcnRhbnQ7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8qIEFsbCBjaXJjbGUgZWxlbWVudHMgaW4gc2hhcGVzIChmYWxsYmFjaykgKi9cbiAgICAgIC5kanMtc2hhcGUgY2lyY2xlIHtcbiAgICAgICAgc3Ryb2tlOiAke2lzRGFyayA/ICcjZmZmZmZmJyA6ICcjMDAwMDAwJ30gIWltcG9ydGFudDtcbiAgICAgICAgZmlsbDogJHtpc0RhcmsgPyAnIzFmMjkzNycgOiAnI2ZmZmZmZid9ICFpbXBvcnRhbnQ7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8qIEV2ZW50IGlubmVyIGNpcmNsZXMgKGZvciBpbnRlcm1lZGlhdGUvYm91bmRhcnkpICovXG4gICAgICAuZGpzLXNoYXBlIC5kanMtdmlzdWFsID4gZyA+IGNpcmNsZSB7XG4gICAgICAgIHN0cm9rZTogJHtpc0RhcmsgPyAnI2ZmZmZmZicgOiAnIzAwMDAwMCd9ICFpbXBvcnRhbnQ7XG4gICAgICAgIGZpbGw6ICR7aXNEYXJrID8gJyMxZjI5MzcnIDogJyNmZmZmZmYnfSAhaW1wb3J0YW50O1xuICAgICAgfVxuICAgICAgXG4gICAgICAvKiBFdmVudCB0eXBlIGljb25zIChtZXNzYWdlLCB0aW1lciwgZXJyb3IsIHNpZ25hbCwgZXRjKSAqL1xuICAgICAgLmRqcy1lbGVtZW50W2RhdGEtZWxlbWVudC1pZCo9XCJFdmVudFwiXSAuZGpzLXZpc3VhbCA+IGcgPiBwYXRoLFxuICAgICAgLmRqcy1lbGVtZW50W2RhdGEtZWxlbWVudC1pZCo9XCJFdmVudFwiXSAuZGpzLXZpc3VhbCA+IHBhdGgge1xuICAgICAgICBzdHJva2U6ICR7aXNEYXJrID8gJyNmZmZmZmYnIDogJyMwMDAwMDAnfSAhaW1wb3J0YW50O1xuICAgICAgICBmaWxsOiAke2lzRGFyayA/ICcjZmZmZmZmJyA6ICcjMDAwMDAwJ30gIWltcG9ydGFudDtcbiAgICAgICAgc3Ryb2tlLXdpZHRoOiAxcHggIWltcG9ydGFudDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLyogQm91bmRhcnkgZXZlbnRzIChhdHRhY2hlZCB0byBhY3Rpdml0aWVzKSAqL1xuICAgICAgLmRqcy1lbGVtZW50W2RhdGEtZWxlbWVudC1pZCo9XCJCb3VuZGFyeUV2ZW50XCJdIC5kanMtdmlzdWFsID4gY2lyY2xlIHtcbiAgICAgICAgc3Ryb2tlOiAke2lzRGFyayA/ICcjZmZmZmZmJyA6ICcjMDAwMDAwJ30gIWltcG9ydGFudDtcbiAgICAgICAgZmlsbDogJHtpc0RhcmsgPyAnIzFmMjkzNycgOiAnI2ZmZmZmZid9ICFpbXBvcnRhbnQ7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8qID09PSBHQVRFV0FZUyA9PT0gKi9cbiAgICAgIFxuICAgICAgLyogR2F0ZXdheSBkaWFtb25kcyAqL1xuICAgICAgLmRqcy1zaGFwZSAuZGpzLXZpc3VhbCA+IHBvbHlnb24ge1xuICAgICAgICBzdHJva2U6ICR7aXNEYXJrID8gJyNmZmZmZmYnIDogJyMwMDAwMDAnfSAhaW1wb3J0YW50O1xuICAgICAgICBzdHJva2Utd2lkdGg6IDJweCAhaW1wb3J0YW50O1xuICAgICAgICBmaWxsOiAke2lzRGFyayA/ICcjMWYyOTM3JyA6ICcjZmZmZmZmJ30gIWltcG9ydGFudDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLyogQWxsIHBvbHlnb24gZWxlbWVudHMgaW4gc2hhcGVzIChmYWxsYmFjaykgKi9cbiAgICAgIC5kanMtc2hhcGUgcG9seWdvbiB7XG4gICAgICAgIHN0cm9rZTogJHtpc0RhcmsgPyAnI2ZmZmZmZicgOiAnIzAwMDAwMCd9ICFpbXBvcnRhbnQ7XG4gICAgICAgIGZpbGw6ICR7aXNEYXJrID8gJyMxZjI5MzcnIDogJyNmZmZmZmYnfSAhaW1wb3J0YW50O1xuICAgICAgfVxuICAgICAgXG4gICAgICAvKiBHYXRld2F5IHN5bWJvbHMgKFgsICssIE8sIGV0YykgKi9cbiAgICAgIC5kanMtZWxlbWVudFtkYXRhLWVsZW1lbnQtaWQqPVwiR2F0ZXdheVwiXSAuZGpzLXZpc3VhbCA+IGcgPiBwYXRoLFxuICAgICAgLmRqcy1lbGVtZW50W2RhdGEtZWxlbWVudC1pZCo9XCJHYXRld2F5XCJdIC5kanMtdmlzdWFsID4gcGF0aCB7XG4gICAgICAgIHN0cm9rZTogJHtpc0RhcmsgPyAnI2ZmZmZmZicgOiAnIzAwMDAwMCd9ICFpbXBvcnRhbnQ7XG4gICAgICAgIGZpbGw6IG5vbmUgIWltcG9ydGFudDtcbiAgICAgICAgc3Ryb2tlLXdpZHRoOiAycHggIWltcG9ydGFudDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLyogQ29tcGxleCBnYXRld2F5IHN0YXIgKi9cbiAgICAgIC5kanMtZWxlbWVudFtkYXRhLWVsZW1lbnQtaWQqPVwiQ29tcGxleEdhdGV3YXlcIl0gLmRqcy12aXN1YWwgPiBwYXRoIHtcbiAgICAgICAgZmlsbDogJHtpc0RhcmsgPyAnI2ZmZmZmZicgOiAnIzAwMDAwMCd9ICFpbXBvcnRhbnQ7XG4gICAgICAgIHN0cm9rZTogJHtpc0RhcmsgPyAnI2ZmZmZmZicgOiAnIzAwMDAwMCd9ICFpbXBvcnRhbnQ7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8qID09PSBEQVRBIE9CSkVDVFMgPT09ICovXG4gICAgICBcbiAgICAgIC8qIERhdGEgb2JqZWN0IHNoYXBlcyAqL1xuICAgICAgLmRqcy1lbGVtZW50W2RhdGEtZWxlbWVudC1pZCo9XCJEYXRhT2JqZWN0XCJdIC5kanMtdmlzdWFsID4gcGF0aCxcbiAgICAgIC5kanMtZWxlbWVudFtkYXRhLWVsZW1lbnQtaWQqPVwiRGF0YVN0b3JlXCJdIC5kanMtdmlzdWFsID4gcGF0aCB7XG4gICAgICAgIHN0cm9rZTogJHtpc0RhcmsgPyAnI2ZmZmZmZicgOiAnIzAwMDAwMCd9ICFpbXBvcnRhbnQ7XG4gICAgICAgIGZpbGw6ICR7aXNEYXJrID8gJyMxZjI5MzcnIDogJyNmZmZmZmYnfSAhaW1wb3J0YW50O1xuICAgICAgfVxuICAgICAgXG4gICAgICAvKiBEYXRhIGNvbGxlY3Rpb24gbWFya2VycyAqL1xuICAgICAgLmRqcy1lbGVtZW50W2RhdGEtZWxlbWVudC1pZCo9XCJEYXRhT2JqZWN0XCJdIC5kanMtdmlzdWFsID4gZyA+IHBhdGgge1xuICAgICAgICBzdHJva2U6ICR7aXNEYXJrID8gJyNmZmZmZmYnIDogJyMwMDAwMDAnfSAhaW1wb3J0YW50O1xuICAgICAgICBmaWxsOiBub25lICFpbXBvcnRhbnQ7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8qID09PSBQQVJUSUNJUEFOVFMgKFBvb2xzL0xhbmVzKSA9PT0gKi9cbiAgICAgIFxuICAgICAgLyogUG9vbC9MYW5lIGNvbnRhaW5lcnMgKi9cbiAgICAgIC5kanMtZWxlbWVudFtkYXRhLWVsZW1lbnQtaWQqPVwiUGFydGljaXBhbnRcIl0gLmRqcy12aXN1YWwgPiByZWN0LFxuICAgICAgLmRqcy1lbGVtZW50W2RhdGEtZWxlbWVudC1pZCo9XCJMYW5lXCJdIC5kanMtdmlzdWFsID4gcmVjdCB7XG4gICAgICAgIHN0cm9rZTogJHtpc0RhcmsgPyAnI2ZmZmZmZicgOiAnIzAwMDAwMCd9ICFpbXBvcnRhbnQ7XG4gICAgICAgIGZpbGw6ICR7aXNEYXJrID8gJyMxZjI5MzcnIDogJyNmZmZmZmYnfSAhaW1wb3J0YW50O1xuICAgICAgfVxuICAgICAgXG4gICAgICAvKiBQb29sL0xhbmUgaGVhZGVycyAqL1xuICAgICAgLmRqcy1lbGVtZW50W2RhdGEtZWxlbWVudC1pZCo9XCJQYXJ0aWNpcGFudFwiXSAuZGpzLXZpc3VhbCA+IGcgPiByZWN0OmZpcnN0LWNoaWxkLFxuICAgICAgLmRqcy1lbGVtZW50W2RhdGEtZWxlbWVudC1pZCo9XCJMYW5lXCJdIC5kanMtdmlzdWFsID4gZyA+IHJlY3Q6Zmlyc3QtY2hpbGQge1xuICAgICAgICBmaWxsOiAke2lzRGFyayA/ICcjMzc0MTUxJyA6ICcjZTVlN2ViJ30gIWltcG9ydGFudDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLyogPT09IENPTk5FQ1RJT05TID09PSAqL1xuICAgICAgXG4gICAgICAvKiBTZXF1ZW5jZSBmbG93cyBhbmQgbWVzc2FnZSBmbG93cyAqL1xuICAgICAgLmRqcy1jb25uZWN0aW9uIC5kanMtdmlzdWFsID4gcGF0aCB7XG4gICAgICAgIHN0cm9rZTogJHtpc0RhcmsgPyAnI2ZmZmZmZicgOiAnIzAwMDAwMCd9ICFpbXBvcnRhbnQ7XG4gICAgICAgIGZpbGw6IG5vbmUgIWltcG9ydGFudDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLyogQXJyb3cgaGVhZHMgKi9cbiAgICAgIC5kanMtY29ubmVjdGlvbiAuZGpzLXZpc3VhbCA+IHBvbHlsaW5lLFxuICAgICAgLmRqcy1jb25uZWN0aW9uIC5kanMtdmlzdWFsID4gcG9seWdvbiB7XG4gICAgICAgIHN0cm9rZTogJHtpc0RhcmsgPyAnI2ZmZmZmZicgOiAnIzAwMDAwMCd9ICFpbXBvcnRhbnQ7XG4gICAgICAgIGZpbGw6ICR7aXNEYXJrID8gJyNmZmZmZmYnIDogJyMwMDAwMDAnfSAhaW1wb3J0YW50O1xuICAgICAgfVxuICAgICAgXG4gICAgICAvKiBBc3NvY2lhdGlvbi9EYXRhIGFzc29jaWF0aW9uIChkb3R0ZWQgbGluZXMpICovXG4gICAgICAuZGpzLWNvbm5lY3Rpb25bZGF0YS1lbGVtZW50LWlkKj1cIkFzc29jaWF0aW9uXCJdIC5kanMtdmlzdWFsID4gcGF0aCB7XG4gICAgICAgIHN0cm9rZTogJHtpc0RhcmsgPyAnI2ZmZmZmZicgOiAnIzAwMDAwMCd9ICFpbXBvcnRhbnQ7XG4gICAgICAgIHN0cm9rZS1kYXNoYXJyYXk6IDUsIDUgIWltcG9ydGFudDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLyogTWVzc2FnZSBmbG93cyAoZGFzaGVkIGxpbmVzKSAqL1xuICAgICAgLmRqcy1jb25uZWN0aW9uW2RhdGEtZWxlbWVudC1pZCo9XCJNZXNzYWdlRmxvd1wiXSAuZGpzLXZpc3VhbCA+IHBhdGgge1xuICAgICAgICBzdHJva2U6ICR7aXNEYXJrID8gJyNmZmZmZmYnIDogJyMwMDAwMDAnfSAhaW1wb3J0YW50O1xuICAgICAgICBzdHJva2UtZGFzaGFycmF5OiAxMCwgNSAhaW1wb3J0YW50O1xuICAgICAgfVxuICAgICAgXG4gICAgICAvKiA9PT0gQVJUSUZBQ1RTID09PSAqL1xuICAgICAgXG4gICAgICAvKiBUZXh0IGFubm90YXRpb25zICovXG4gICAgICAuZGpzLWVsZW1lbnRbZGF0YS1lbGVtZW50LWlkKj1cIlRleHRBbm5vdGF0aW9uXCJdIC5kanMtdmlzdWFsID4gcmVjdCB7XG4gICAgICAgIHN0cm9rZTogJHtpc0RhcmsgPyAnI2ZmZmZmZicgOiAnIzAwMDAwMCd9ICFpbXBvcnRhbnQ7XG4gICAgICAgIGZpbGw6IG5vbmUgIWltcG9ydGFudDtcbiAgICAgICAgc3Ryb2tlLWRhc2hhcnJheTogNSwgNSAhaW1wb3J0YW50O1xuICAgICAgfVxuICAgICAgXG4gICAgICAvKiBHcm91cHMgKi9cbiAgICAgIC5kanMtZWxlbWVudFtkYXRhLWVsZW1lbnQtaWQqPVwiR3JvdXBcIl0gLmRqcy12aXN1YWwgPiByZWN0IHtcbiAgICAgICAgc3Ryb2tlOiAke2lzRGFyayA/ICcjZmZmZmZmJyA6ICcjMDAwMDAwJ30gIWltcG9ydGFudDtcbiAgICAgICAgZmlsbDogbm9uZSAhaW1wb3J0YW50O1xuICAgICAgICBzdHJva2UtZGFzaGFycmF5OiA4LCAzLCAxLCAzICFpbXBvcnRhbnQ7XG4gICAgICAgIHN0cm9rZS13aWR0aDogMXB4ICFpbXBvcnRhbnQ7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8qID09PSBURVhUIExBQkVMUyA9PT0gKi9cbiAgICAgIFxuICAgICAgLyogQWxsIHRleHQgZWxlbWVudHMgKi9cbiAgICAgIC5kanMtbGFiZWwsXG4gICAgICAuZGpzLXNoYXBlIC5kanMtdmlzdWFsIHRleHQsXG4gICAgICAuZGpzLWVsZW1lbnQgdGV4dCxcbiAgICAgIHRleHQge1xuICAgICAgICBmaWxsOiAke2lzRGFyayA/ICcjZmZmZmZmJyA6ICcjMDAwMDAwJ30gIWltcG9ydGFudDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLyogTGFiZWwgYmFja2dyb3VuZHMgc2hvdWxkIGJlIHRyYW5zcGFyZW50ICovXG4gICAgICAuZGpzLWxhYmVsIC5kanMtdmlzdWFsIHJlY3Qge1xuICAgICAgICBmaWxsOiB0cmFuc3BhcmVudCAhaW1wb3J0YW50O1xuICAgICAgICBzdHJva2U6IG5vbmUgIWltcG9ydGFudDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLyogPT09IEdFTkVSSUMgRkFMTEJBQ0tTID09PSAqL1xuICAgICAgXG4gICAgICAvKiBBbnkgb3RoZXIgcGF0aCBlbGVtZW50cyAqL1xuICAgICAgLmRqcy1zaGFwZSAuZGpzLXZpc3VhbCA+IHBhdGgge1xuICAgICAgICBzdHJva2U6ICR7aXNEYXJrID8gJyNmZmZmZmYnIDogJyMwMDAwMDAnfSAhaW1wb3J0YW50O1xuICAgICAgfVxuICAgICAgXG4gICAgICAvKiBBbGwgcGF0aHMgd2l0aCBzdHJva2UgYXR0cmlidXRlICovXG4gICAgICBwYXRoW3N0cm9rZV06bm90KFtzdHJva2U9XCJub25lXCJdKSB7XG4gICAgICAgIHN0cm9rZTogJHtpc0RhcmsgPyAnI2ZmZmZmZicgOiAnIzAwMDAwMCd9ICFpbXBvcnRhbnQ7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8qIEFsbCBlbGxpcHNlIGVsZW1lbnRzICovXG4gICAgICBlbGxpcHNlIHtcbiAgICAgICAgc3Ryb2tlOiAke2lzRGFyayA/ICcjZmZmZmZmJyA6ICcjMDAwMDAwJ30gIWltcG9ydGFudDtcbiAgICAgICAgZmlsbDogJHtpc0RhcmsgPyAnIzFmMjkzNycgOiAnI2ZmZmZmZid9ICFpbXBvcnRhbnQ7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8qIEFsbCBsaW5lIGVsZW1lbnRzICovXG4gICAgICBsaW5lIHtcbiAgICAgICAgc3Ryb2tlOiAke2lzRGFyayA/ICcjZmZmZmZmJyA6ICcjMDAwMDAwJ30gIWltcG9ydGFudDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLyogRmlsbGVkIHBhdGggZWxlbWVudHMgKGljb25zLCBtYXJrZXJzKSAqL1xuICAgICAgLmRqcy1zaGFwZSAuZGpzLXZpc3VhbCA+IGcgPiBwYXRoW2ZpbGxdOm5vdChbZmlsbD1cIm5vbmVcIl0pIHtcbiAgICAgICAgZmlsbDogJHtpc0RhcmsgPyAnI2ZmZmZmZicgOiAnIzAwMDAwMCd9ICFpbXBvcnRhbnQ7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8qIENhdGNoIGFsbCBTVkcgc2hhcGVzIHRoYXQgbWlnaHQgaGF2ZSBibGFjayBzdHJva2UgaW4gbGlnaHQgbW9kZSAqL1xuICAgICAgLmRqcy12aXN1YWwgPiAqW3N0cm9rZT1cIiMwMDAwMDBcIl0sXG4gICAgICAuZGpzLXZpc3VhbCA+ICpbc3Ryb2tlPVwiYmxhY2tcIl0sXG4gICAgICAuZGpzLXZpc3VhbCA+ICpbc3Ryb2tlPVwicmdiKDAsMCwwKVwiXSxcbiAgICAgIC5kanMtdmlzdWFsID4gKltzdHJva2U9XCJyZ2IoMCwgMCwgMClcIl0ge1xuICAgICAgICBzdHJva2U6ICR7aXNEYXJrID8gJyNmZmZmZmYnIDogJyMwMDAwMDAnfSAhaW1wb3J0YW50O1xuICAgICAgfVxuICAgICAgXG4gICAgICAvKiBDYXRjaCBhbGwgbmVzdGVkIGVsZW1lbnRzIHdpdGggYmxhY2sgc3Ryb2tlICovXG4gICAgICAuZGpzLXZpc3VhbCAqW3N0cm9rZT1cIiMwMDAwMDBcIl0sXG4gICAgICAuZGpzLXZpc3VhbCAqW3N0cm9rZT1cImJsYWNrXCJdLFxuICAgICAgLmRqcy12aXN1YWwgKltzdHJva2U9XCJyZ2IoMCwwLDApXCJdLFxuICAgICAgLmRqcy12aXN1YWwgKltzdHJva2U9XCJyZ2IoMCwgMCwgMClcIl0ge1xuICAgICAgICBzdHJva2U6ICR7aXNEYXJrID8gJyNmZmZmZmYnIDogJyMwMDAwMDAnfSAhaW1wb3J0YW50O1xuICAgICAgfVxuICAgICAgXG4gICAgICAvKiBDYXRjaCBhbGwgU1ZHIHNoYXBlcyB0aGF0IG1pZ2h0IGhhdmUgd2hpdGUgZmlsbCBpbiBsaWdodCBtb2RlICovXG4gICAgICAuZGpzLXZpc3VhbCA+ICpbZmlsbD1cIiNmZmZmZmZcIl0sXG4gICAgICAuZGpzLXZpc3VhbCA+ICpbZmlsbD1cIndoaXRlXCJdLFxuICAgICAgLmRqcy12aXN1YWwgPiAqW2ZpbGw9XCJyZ2IoMjU1LDI1NSwyNTUpXCJdLFxuICAgICAgLmRqcy12aXN1YWwgPiAqW2ZpbGw9XCJyZ2IoMjU1LCAyNTUsIDI1NSlcIl0ge1xuICAgICAgICBmaWxsOiAke2lzRGFyayA/ICcjMWYyOTM3JyA6ICcjZmZmZmZmJ30gIWltcG9ydGFudDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLyogQ2F0Y2ggYWxsIG5lc3RlZCBlbGVtZW50cyB3aXRoIHdoaXRlIGZpbGwgKi9cbiAgICAgIC5kanMtdmlzdWFsICpbZmlsbD1cIiNmZmZmZmZcIl0sXG4gICAgICAuZGpzLXZpc3VhbCAqW2ZpbGw9XCJ3aGl0ZVwiXSxcbiAgICAgIC5kanMtdmlzdWFsICpbZmlsbD1cInJnYigyNTUsMjU1LDI1NSlcIl0sXG4gICAgICAuZGpzLXZpc3VhbCAqW2ZpbGw9XCJyZ2IoMjU1LCAyNTUsIDI1NSlcIl0ge1xuICAgICAgICBmaWxsOiAke2lzRGFyayA/ICcjMWYyOTM3JyA6ICcjZmZmZmZmJ30gIWltcG9ydGFudDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLyogRGlyZWN0IGVkaXRpbmcgdGV4dCAqL1xuICAgICAgLmRqcy1kaXJlY3QtZWRpdGluZy1wYXJlbnQge1xuICAgICAgICBjb2xvcjogJHtpc0RhcmsgPyAnI2ZmZmZmZicgOiAnIzAwMDAwMCd9ICFpbXBvcnRhbnQ7XG4gICAgICAgIGJhY2tncm91bmQ6IHRyYW5zcGFyZW50ICFpbXBvcnRhbnQ7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC5kanMtZGlyZWN0LWVkaXRpbmctY29udGVudCB7XG4gICAgICAgIGNvbG9yOiAke2lzRGFyayA/ICcjZmZmZmZmJyA6ICcjMDAwMDAwJ30gIWltcG9ydGFudDtcbiAgICAgICAgYmFja2dyb3VuZDogdHJhbnNwYXJlbnQgIWltcG9ydGFudDtcbiAgICAgICAgY2FyZXQtY29sb3I6ICR7aXNEYXJrID8gJyNmZmZmZmYnIDogJyMwMDAwMDAnfSAhaW1wb3J0YW50O1xuICAgICAgfVxuICAgICAgXG4gICAgICAvKiBFbnN1cmUgdGhlIGVkaXRpbmcgYm94IGl0c2VsZiBpcyB0cmFuc3BhcmVudCAqL1xuICAgICAgLmRqcy1kaXJlY3QtZWRpdGluZy1wYXJlbnQgPiBkaXYge1xuICAgICAgICBiYWNrZ3JvdW5kOiB0cmFuc3BhcmVudCAhaW1wb3J0YW50O1xuICAgICAgfVxuICAgICAgXG4gICAgICAvKiBDb250ZW50ZWRpdGFibGUgZWxlbWVudHMgc2hvdWxkIGJlIHRyYW5zcGFyZW50ICovXG4gICAgICBbY29udGVudGVkaXRhYmxlPVwidHJ1ZVwiXSB7XG4gICAgICAgIGJhY2tncm91bmQ6IHRyYW5zcGFyZW50ICFpbXBvcnRhbnQ7XG4gICAgICAgIG91dGxpbmU6IG5vbmUgIWltcG9ydGFudDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLyogRm9jdXMgc3RhdGUgZm9yIGVkaXRpbmcgKi9cbiAgICAgIC5kanMtZGlyZWN0LWVkaXRpbmctY29udGVudDpmb2N1cyB7XG4gICAgICAgIGJhY2tncm91bmQ6IHRyYW5zcGFyZW50ICFpbXBvcnRhbnQ7XG4gICAgICAgIG91dGxpbmU6IDFweCBkb3R0ZWQgJHtpc0RhcmsgPyAnIzYwYTVmYScgOiAnIzI1NjNlYid9ICFpbXBvcnRhbnQ7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8qID09PSBTRUxFQ1RJT04gVklTSUJJTElUWSBGSVggPT09ICovXG4gICAgICBcbiAgICAgIC8qIFNlbGVjdGVkIGVsZW1lbnQgb3V0bGluZSAtIG1ha2UgaXQgaGlnaGx5IHZpc2libGUgKi9cbiAgICAgIC5kanMtb3V0bGluZSB7XG4gICAgICAgIHN0cm9rZTogJHtpc0RhcmsgPyAnIzYwYTVmYScgOiAnIzI1NjNlYid9ICFpbXBvcnRhbnQ7XG4gICAgICAgIHN0cm9rZS13aWR0aDogM3B4ICFpbXBvcnRhbnQ7XG4gICAgICAgIHN0cm9rZS1kYXNoYXJyYXk6IDUsIDUgIWltcG9ydGFudDtcbiAgICAgICAgZmlsbDogbm9uZSAhaW1wb3J0YW50O1xuICAgICAgICBmaWxsLW9wYWNpdHk6IDAgIWltcG9ydGFudDtcbiAgICAgICAgb3BhY2l0eTogMSAhaW1wb3J0YW50O1xuICAgICAgfVxuICAgICAgXG4gICAgICAvKiBPdXRsaW5lIHBhdGhzIGFuZCBwb2x5Z29ucyBtdXN0IGJlIHRyYW5zcGFyZW50ICovXG4gICAgICAuZGpzLW91dGxpbmUgcGF0aCxcbiAgICAgIC5kanMtb3V0bGluZSBwb2x5Z29uLFxuICAgICAgLmRqcy1vdXRsaW5lIHBvbHlsaW5lLFxuICAgICAgLmRqcy1vdXRsaW5lIHJlY3QsXG4gICAgICAuZGpzLW91dGxpbmUgY2lyY2xlLFxuICAgICAgLmRqcy1vdXRsaW5lIGVsbGlwc2Uge1xuICAgICAgICBmaWxsOiBub25lICFpbXBvcnRhbnQ7XG4gICAgICAgIGZpbGwtb3BhY2l0eTogMCAhaW1wb3J0YW50O1xuICAgICAgfVxuICAgICAgXG4gICAgICAvKiBTZWxlY3Rpb24gYm94IG92ZXJsYXkgLSBNVVNUIEJFIFRSQU5TUEFSRU5UICovXG4gICAgICAuZGpzLWxhc3NvLW92ZXJsYXkge1xuICAgICAgICBzdHJva2U6ICR7aXNEYXJrID8gJyM2MGE1ZmEnIDogJyMyNTYzZWInfSAhaW1wb3J0YW50O1xuICAgICAgICBzdHJva2Utd2lkdGg6IDJweCAhaW1wb3J0YW50O1xuICAgICAgICBmaWxsOiAke2lzRGFyayA/ICdyZ2JhKDk2LCAxNjUsIDI1MCwgMC4xKScgOiAncmdiYSgzNywgOTksIDIzNSwgMC4xKSd9ICFpbXBvcnRhbnQ7XG4gICAgICAgIG9wYWNpdHk6IDEgIWltcG9ydGFudDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLyogTXVsdGktc2VsZWN0IG1hcnF1ZWUgLSB0cmFuc3BhcmVudCBiYWNrZ3JvdW5kICovXG4gICAgICAuZGpzLW1hcnF1ZWUge1xuICAgICAgICBmaWxsOiAke2lzRGFyayA/ICdyZ2JhKDk2LCAxNjUsIDI1MCwgMC4xKScgOiAncmdiYSgzNywgOTksIDIzNSwgMC4xKSd9ICFpbXBvcnRhbnQ7XG4gICAgICAgIHN0cm9rZTogJHtpc0RhcmsgPyAnIzYwYTVmYScgOiAnIzI1NjNlYid9ICFpbXBvcnRhbnQ7XG4gICAgICAgIHN0cm9rZS13aWR0aDogMXB4ICFpbXBvcnRhbnQ7XG4gICAgICAgIHN0cm9rZS1kYXNoYXJyYXk6IDUsIDUgIWltcG9ydGFudDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLyogU2VsZWN0ZWQgZWxlbWVudHMgZ2V0IGEgaGlnaGxpZ2h0ICovXG4gICAgICAuZGpzLWVsZW1lbnQuc2VsZWN0ZWQgLmRqcy1vdXRsaW5lIHtcbiAgICAgICAgc3Ryb2tlOiAke2lzRGFyayA/ICcjNjBhNWZhJyA6ICcjMjU2M2ViJ30gIWltcG9ydGFudDtcbiAgICAgICAgc3Ryb2tlLXdpZHRoOiAzcHggIWltcG9ydGFudDtcbiAgICAgICAgb3BhY2l0eTogMSAhaW1wb3J0YW50O1xuICAgICAgfVxuICAgICAgXG4gICAgICAvKiBIb3ZlciBzdGF0ZSBmb3IgYmV0dGVyIHZpc2liaWxpdHkgKi9cbiAgICAgIC5kanMtZWxlbWVudC5ob3ZlciAuZGpzLW91dGxpbmUge1xuICAgICAgICBzdHJva2U6ICR7aXNEYXJrID8gJyM5M2M1ZmQnIDogJyM2MGE1ZmEnfSAhaW1wb3J0YW50O1xuICAgICAgICBzdHJva2Utd2lkdGg6IDJweCAhaW1wb3J0YW50O1xuICAgICAgICBvcGFjaXR5OiAwLjggIWltcG9ydGFudDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLyogU2VsZWN0aW9uIGZyYW1lIGFyb3VuZCBlbGVtZW50cyAqL1xuICAgICAgLmRqcy1zZWxlY3QtdmlzdWFsIHtcbiAgICAgICAgc3Ryb2tlOiAke2lzRGFyayA/ICcjNjBhNWZhJyA6ICcjMjU2M2ViJ30gIWltcG9ydGFudDtcbiAgICAgICAgc3Ryb2tlLXdpZHRoOiAycHggIWltcG9ydGFudDtcbiAgICAgICAgc3Ryb2tlLWRhc2hhcnJheTogNSwgNSAhaW1wb3J0YW50O1xuICAgICAgICBmaWxsOiBub25lICFpbXBvcnRhbnQ7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8qIE11bHRpLXNlbGVjdGlvbiB2aXN1YWwgKi9cbiAgICAgIC5kanMtbXVsdGlzZWxlY3QtdmlzdWFsIHtcbiAgICAgICAgc3Ryb2tlOiAke2lzRGFyayA/ICcjNjBhNWZhJyA6ICcjMjU2M2ViJ30gIWltcG9ydGFudDtcbiAgICAgICAgc3Ryb2tlLXdpZHRoOiAycHggIWltcG9ydGFudDtcbiAgICAgICAgZmlsbDogJHtpc0RhcmsgPyAncmdiYSg5NiwgMTY1LCAyNTAsIDAuMDUpJyA6ICdyZ2JhKDM3LCA5OSwgMjM1LCAwLjA1KSd9ICFpbXBvcnRhbnQ7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8qIFJlc2l6ZSBoYW5kbGVzIC0gc21hbGwgY29ybmVyIHNxdWFyZXMgKi9cbiAgICAgIC5kanMtcmVzaXplci12aXN1YWwsXG4gICAgICAuZGpzLXJlc2l6ZXItaGl0IHtcbiAgICAgICAgc3Ryb2tlOiAke2lzRGFyayA/ICcjNjBhNWZhJyA6ICcjMjU2M2ViJ30gIWltcG9ydGFudDtcbiAgICAgICAgZmlsbDogdHJhbnNwYXJlbnQgIWltcG9ydGFudDtcbiAgICAgICAgb3BhY2l0eTogMSAhaW1wb3J0YW50O1xuICAgICAgfVxuICAgICAgXG4gICAgICAvKiBSZXNpemUgaGFuZGxlIGNvcm5lcnMgLSB0aGUgYWN0dWFsIHNxdWFyZXMgKi9cbiAgICAgIC5kanMtcmVzaXplci12aXN1YWwgcmVjdCxcbiAgICAgIC5kanMtcmVzaXplci1oaXQgcmVjdCB7XG4gICAgICAgIGZpbGw6ICR7aXNEYXJrID8gJyM2MGE1ZmEnIDogJyMyNTYzZWInfSAhaW1wb3J0YW50O1xuICAgICAgICBzdHJva2U6ICR7aXNEYXJrID8gJyNmZmZmZmYnIDogJyMwMDAwMDAnfSAhaW1wb3J0YW50O1xuICAgICAgICBzdHJva2Utd2lkdGg6IDFweCAhaW1wb3J0YW50O1xuICAgICAgICB3aWR0aDogNnB4ICFpbXBvcnRhbnQ7XG4gICAgICAgIGhlaWdodDogNnB4ICFpbXBvcnRhbnQ7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8qIFNlbGVjdGlvbiBmcmFtZSAtIE1VU1QgQkUgVFJBTlNQQVJFTlQgKi9cbiAgICAgIC5kanMtc2VsZWN0aW9uLWZyYW1lIHtcbiAgICAgICAgZmlsbDogdHJhbnNwYXJlbnQgIWltcG9ydGFudDtcbiAgICAgICAgc3Ryb2tlOiAke2lzRGFyayA/ICcjNjBhNWZhJyA6ICcjMjU2M2ViJ30gIWltcG9ydGFudDtcbiAgICAgICAgc3Ryb2tlLXdpZHRoOiAycHggIWltcG9ydGFudDtcbiAgICAgICAgc3Ryb2tlLWRhc2hhcnJheTogNSwgNSAhaW1wb3J0YW50O1xuICAgICAgfVxuICAgICAgXG4gICAgICAvKiBTZWxlY3Rpb24gdmlzdWFsIGJveCAtIFRSQU5TUEFSRU5UIEJBQ0tHUk9VTkQgKi9cbiAgICAgIC5kanMtc2VsZWN0aW9uLXZpc3VhbCB7XG4gICAgICAgIGZpbGw6IHRyYW5zcGFyZW50ICFpbXBvcnRhbnQ7XG4gICAgICAgIHN0cm9rZTogJHtpc0RhcmsgPyAnIzYwYTVmYScgOiAnIzI1NjNlYid9ICFpbXBvcnRhbnQ7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8qIFNlbGVjdGlvbiBvdmVybGF5IGJhY2tncm91bmQgLSBDUklUSUNBTCBGSVggKi9cbiAgICAgIC5kanMtb3ZlcmxheS1jb250YWluZXIgLmRqcy1vdmVybGF5IHtcbiAgICAgICAgYmFja2dyb3VuZDogdHJhbnNwYXJlbnQgIWltcG9ydGFudDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLyogQW55IHNlbGVjdGlvbi1yZWxhdGVkIG92ZXJsYXlzIG11c3QgYmUgdHJhbnNwYXJlbnQgKi9cbiAgICAgIC5kanMtb3ZlcmxheS1jb250YWluZXIgPiAqIHtcbiAgICAgICAgYmFja2dyb3VuZDogdHJhbnNwYXJlbnQgIWltcG9ydGFudDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLyogTGFzc28gc2VsZWN0aW9uIGFyZWEgKi9cbiAgICAgIC5kanMtbGFzc28tb3ZlcmxheSByZWN0IHtcbiAgICAgICAgZmlsbDogJHtpc0RhcmsgPyAncmdiYSg5NiwgMTY1LCAyNTAsIDAuMSknIDogJ3JnYmEoMzcsIDk5LCAyMzUsIDAuMSknfSAhaW1wb3J0YW50O1xuICAgICAgICBzdHJva2U6ICR7aXNEYXJrID8gJyM2MGE1ZmEnIDogJyMyNTYzZWInfSAhaW1wb3J0YW50O1xuICAgICAgfVxuICAgICAgXG4gICAgICAvKiBEcmFnIHNlbGVjdGlvbiBtYXJxdWVlIGJveCAqL1xuICAgICAgLmRqcy1kcmFnLW1hcnF1ZWUge1xuICAgICAgICBmaWxsOiAke2lzRGFyayA/ICdyZ2JhKDk2LCAxNjUsIDI1MCwgMC4xKScgOiAncmdiYSgzNywgOTksIDIzNSwgMC4xKSd9ICFpbXBvcnRhbnQ7XG4gICAgICAgIHN0cm9rZTogJHtpc0RhcmsgPyAnIzYwYTVmYScgOiAnIzI1NjNlYid9ICFpbXBvcnRhbnQ7XG4gICAgICAgIHN0cm9rZS13aWR0aDogMXB4ICFpbXBvcnRhbnQ7XG4gICAgICAgIHN0cm9rZS1kYXNoYXJyYXk6IDUsIDUgIWltcG9ydGFudDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLyogR3JvdXAgc2VsZWN0aW9uIGZyYW1lICovXG4gICAgICAuZGpzLWdyb3VwLXNlbGVjdG9yIHtcbiAgICAgICAgZmlsbDogdHJhbnNwYXJlbnQgIWltcG9ydGFudDtcbiAgICAgICAgc3Ryb2tlOiAke2lzRGFyayA/ICcjNjBhNWZhJyA6ICcjMjU2M2ViJ30gIWltcG9ydGFudDtcbiAgICAgICAgc3Ryb2tlLXdpZHRoOiAycHggIWltcG9ydGFudDtcbiAgICAgICAgc3Ryb2tlLWRhc2hhcnJheTogNSwgNSAhaW1wb3J0YW50O1xuICAgICAgfVxuICAgICAgXG4gICAgICAvKiBTZWxlY3RlZCBzdGF0ZSB2aXN1YWwgZmVlZGJhY2sgKi9cbiAgICAgIC5zZWxlY3RlZCA+IC5kanMtdmlzdWFsIHtcbiAgICAgICAgZmlsdGVyOiAke2lzRGFyayA/ICdkcm9wLXNoYWRvdygwIDAgNHB4IHJnYmEoOTYsIDE2NSwgMjUwLCAwLjUpKScgOiAnZHJvcC1zaGFkb3coMCAwIDRweCByZ2JhKDM3LCA5OSwgMjM1LCAwLjMpKSd9ICFpbXBvcnRhbnQ7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8qIE1ha2Ugc3VyZSBzZWxlY3Rpb24gZG9lc24ndCBoaWRlIGVsZW1lbnRzICovXG4gICAgICAuZGpzLW92ZXJsYXkge1xuICAgICAgICBwb2ludGVyLWV2ZW50czogbm9uZSAhaW1wb3J0YW50O1xuICAgICAgfVxuICAgICAgXG4gICAgICAuZGpzLW92ZXJsYXkuZGpzLWxhc3NvLW92ZXJsYXkge1xuICAgICAgICBwb2ludGVyLWV2ZW50czogYWxsICFpbXBvcnRhbnQ7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8qIEFHR1JFU1NJVkUgRklYOiBGb3JjZSBBTEwgc2VsZWN0aW9uIHJlY3RhbmdsZXMgdG8gYmUgdHJhbnNwYXJlbnQgKi9cbiAgICAgIC5zZWxlY3RlZCByZWN0Om5vdCguZGpzLXZpc3VhbCByZWN0KSB7XG4gICAgICAgIGZpbGw6IHRyYW5zcGFyZW50ICFpbXBvcnRhbnQ7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8qIFNlbGVjdGlvbiBpbmRpY2F0b3JzIHNob3VsZCBvbmx5IGJlIG91dGxpbmVzICovXG4gICAgICAuZGpzLW91dGxpbmUgcmVjdCxcbiAgICAgIC5kanMtc2VsZWN0aW9uIHJlY3QsXG4gICAgICAuZGpzLXNlbGVjdCByZWN0IHtcbiAgICAgICAgZmlsbDogdHJhbnNwYXJlbnQgIWltcG9ydGFudDtcbiAgICAgICAgc3Ryb2tlOiAke2lzRGFyayA/ICcjNjBhNWZhJyA6ICcjMjU2M2ViJ30gIWltcG9ydGFudDtcbiAgICAgICAgc3Ryb2tlLXdpZHRoOiAycHggIWltcG9ydGFudDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLyogRW5zdXJlIG5vIGJhY2tncm91bmQgb24gc2VsZWN0aW9uIHZpc3VhbHMgKi9cbiAgICAgIFtjbGFzcyo9XCJzZWxlY3RcIl0gcmVjdDpub3QoLmRqcy12aXN1YWwgcmVjdCkge1xuICAgICAgICBmaWxsOiB0cmFuc3BhcmVudCAhaW1wb3J0YW50O1xuICAgICAgfVxuICAgICAgXG4gICAgICAvKiBSZW1vdmUgYW55IGZpbGwgZnJvbSBzZWxlY3Rpb24gZnJhbWVzICovXG4gICAgICAuZGpzLWZyYW1lIHJlY3Qge1xuICAgICAgICBmaWxsOiB0cmFuc3BhcmVudCAhaW1wb3J0YW50O1xuICAgICAgfVxuICAgICAgXG4gICAgICAvKiBDYW52YXMgYmFja2dyb3VuZCAtIHRhcmdldCBtdWx0aXBsZSBzZWxlY3RvcnMgZm9yIGJldHRlciBjb3ZlcmFnZSAqL1xuICAgICAgLmRqcy1jb250YWluZXIsXG4gICAgICAuZGpzLWNvbnRhaW5lciBzdmcsXG4gICAgICAuZGpzLXZpZXdwb3J0LFxuICAgICAgLmRqcy1wbGFuZSB7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6ICR7aXNEYXJrID8gJyMxMTE4MjcnIDogJyNmOWZhZmInfSAhaW1wb3J0YW50O1xuICAgICAgfVxuICAgICAgXG4gICAgICAvKiBHcmlkIHBhdHRlcm4gYmFja2dyb3VuZCAqL1xuICAgICAgLmdyaWQtYmFja2dyb3VuZCB7XG4gICAgICAgIGJhY2tncm91bmQtaW1hZ2U6IFxuICAgICAgICAgIGxpbmVhci1ncmFkaWVudCgke2lzRGFyayA/ICdyZ2JhKDI1NSwyNTUsMjU1LDAuMDMpJyA6ICdyZ2JhKDAsMCwwLDAuMDMpJ30gMXB4LCB0cmFuc3BhcmVudCAxcHgpLFxuICAgICAgICAgIGxpbmVhci1ncmFkaWVudCg5MGRlZywgJHtpc0RhcmsgPyAncmdiYSgyNTUsMjU1LDI1NSwwLjAzKScgOiAncmdiYSgwLDAsMCwwLjAzKSd9IDFweCwgdHJhbnNwYXJlbnQgMXB4KTtcbiAgICAgICAgYmFja2dyb3VuZC1zaXplOiAyMHB4IDIwcHg7XG4gICAgICAgIGJhY2tncm91bmQtcG9zaXRpb246IDAgMCwgMCAwO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvKiBBcHBseSBncmlkIHRvIGNhbnZhcyB3aGVuIGVuYWJsZWQgKi9cbiAgICAgIC5kanMtY29udGFpbmVyLnNob3ctZ3JpZCA+IHN2ZyB7XG4gICAgICAgIGJhY2tncm91bmQtaW1hZ2U6IFxuICAgICAgICAgIGxpbmVhci1ncmFkaWVudCgke2lzRGFyayA/ICdyZ2JhKDI1NSwyNTUsMjU1LDAuMDUpJyA6ICdyZ2JhKDAsMCwwLDAuMDUpJ30gMXB4LCB0cmFuc3BhcmVudCAxcHgpLFxuICAgICAgICAgIGxpbmVhci1ncmFkaWVudCg5MGRlZywgJHtpc0RhcmsgPyAncmdiYSgyNTUsMjU1LDI1NSwwLjA1KScgOiAncmdiYSgwLDAsMCwwLjA1KSd9IDFweCwgdHJhbnNwYXJlbnQgMXB4KTtcbiAgICAgICAgYmFja2dyb3VuZC1zaXplOiAyMHB4IDIwcHg7XG4gICAgICAgIGJhY2tncm91bmQtcG9zaXRpb246IDAgMCwgMCAwO1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAke2lzRGFyayA/ICcjMTExODI3JyA6ICcjZjlmYWZiJ30gIWltcG9ydGFudDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLyogRW5zdXJlIHRoZSBTVkcgaXRzZWxmIGhhcyB0aGUgcmlnaHQgYmFja2dyb3VuZCAqL1xuICAgICAgLmRqcy1jb250YWluZXIgPiBzdmcge1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAke2lzRGFyayA/ICcjMTExODI3JyA6ICcjZjlmYWZiJ30gIWltcG9ydGFudDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLyogSGlkZSBuYXRpdmUgQlBNTi5qcyBwYWxldHRlIHNpbmNlIHdlIHVzZSBjdXN0b20gKi9cbiAgICAgIC5kanMtcGFsZXR0ZSB7XG4gICAgICAgIGRpc3BsYXk6IG5vbmUgIWltcG9ydGFudDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLyogPT09IFVMVElNQVRFIEZBTExCQUNLIC0gQ2F0Y2ggQU5ZIGVsZW1lbnQgdGhhdCBtaWdodCBiZSBtaXNzZWQgPT09ICovXG4gICAgICBcbiAgICAgIC8qIEFHR1JFU1NJVkU6IEZvcmNlIGFsbCBzdHJva2VzIGluIGRqcyBlbGVtZW50cyAqL1xuICAgICAgLmRqcy1jb250YWluZXIgc3ZnICoge1xuICAgICAgICBzdHJva2U6ICR7aXNEYXJrID8gJyNmZmZmZmYnIDogJyMwMDAwMDAnfSAhaW1wb3J0YW50O1xuICAgICAgfVxuICAgICAgXG4gICAgICAvKiBCdXQgcHJlc2VydmUgdHJhbnNwYXJlbnQgc3Ryb2tlcyAqL1xuICAgICAgLmRqcy1jb250YWluZXIgc3ZnICpbc3Ryb2tlPVwibm9uZVwiXSxcbiAgICAgIC5kanMtY29udGFpbmVyIHN2ZyAqW3N0cm9rZT1cInRyYW5zcGFyZW50XCJdLFxuICAgICAgLmRqcy1jb250YWluZXIgc3ZnICpbc3Ryb2tlLW9wYWNpdHk9XCIwXCJdIHtcbiAgICAgICAgc3Ryb2tlOiB0cmFuc3BhcmVudCAhaW1wb3J0YW50O1xuICAgICAgfVxuICAgICAgXG4gICAgICAvKiBGb3JjZSBwcm9wZXIgZmlsbHMgb24gYmFzaWMgc2hhcGVzICovXG4gICAgICAuZGpzLWNvbnRhaW5lciBzdmcgcmVjdDpub3QoW2ZpbGw9XCJub25lXCJdKTpub3QoW2ZpbGw9XCJ0cmFuc3BhcmVudFwiXSksXG4gICAgICAuZGpzLWNvbnRhaW5lciBzdmcgY2lyY2xlOm5vdChbZmlsbD1cIm5vbmVcIl0pOm5vdChbZmlsbD1cInRyYW5zcGFyZW50XCJdKSxcbiAgICAgIC5kanMtY29udGFpbmVyIHN2ZyBlbGxpcHNlOm5vdChbZmlsbD1cIm5vbmVcIl0pOm5vdChbZmlsbD1cInRyYW5zcGFyZW50XCJdKSxcbiAgICAgIC5kanMtY29udGFpbmVyIHN2ZyBwb2x5Z29uOm5vdChbZmlsbD1cIm5vbmVcIl0pOm5vdChbZmlsbD1cInRyYW5zcGFyZW50XCJdKSB7XG4gICAgICAgIGZpbGw6ICR7aXNEYXJrID8gJyMxZjI5MzcnIDogJyNmZmZmZmYnfSAhaW1wb3J0YW50O1xuICAgICAgfVxuICAgICAgXG4gICAgICAvKiBFbnN1cmUgdGV4dCBpcyBhbHdheXMgdmlzaWJsZSAqL1xuICAgICAgLmRqcy1jb250YWluZXIgc3ZnIHRleHQsXG4gICAgICAuZGpzLWNvbnRhaW5lciBzdmcgdHNwYW4ge1xuICAgICAgICBmaWxsOiAke2lzRGFyayA/ICcjZmZmZmZmJyA6ICcjMDAwMDAwJ30gIWltcG9ydGFudDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLyogU1VQRVIgQUdHUkVTU0lWRTogT3ZlcnJpZGUgQU5ZIHN0cm9rZSBhdHRyaWJ1dGUgaW4gZGFyayBtb2RlICovXG4gICAgICAke2lzRGFyayA/IGBcbiAgICAgICAgLmRqcy1jb250YWluZXIgc3ZnICo6bm90KFtzdHJva2U9XCJub25lXCJdKTpub3QoW3N0cm9rZT1cInRyYW5zcGFyZW50XCJdKSB7XG4gICAgICAgICAgc3Ryb2tlOiAjZmZmZmZmICFpbXBvcnRhbnQ7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC5kanMtY29udGFpbmVyIHN2ZyBwYXRoOm5vdChbc3Ryb2tlPVwibm9uZVwiXSk6bm90KFtzdHJva2U9XCJ0cmFuc3BhcmVudFwiXSkge1xuICAgICAgICAgIHN0cm9rZTogI2ZmZmZmZiAhaW1wb3J0YW50O1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAuZGpzLWNvbnRhaW5lciBzdmcgbGluZTpub3QoW3N0cm9rZT1cIm5vbmVcIl0pOm5vdChbc3Ryb2tlPVwidHJhbnNwYXJlbnRcIl0pIHtcbiAgICAgICAgICBzdHJva2U6ICNmZmZmZmYgIWltcG9ydGFudDtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLmRqcy1jb250YWluZXIgc3ZnIHBvbHlsaW5lOm5vdChbc3Ryb2tlPVwibm9uZVwiXSk6bm90KFtzdHJva2U9XCJ0cmFuc3BhcmVudFwiXSkge1xuICAgICAgICAgIHN0cm9rZTogI2ZmZmZmZiAhaW1wb3J0YW50O1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAuZGpzLWNvbnRhaW5lciBzdmcgcmVjdDpub3QoW3N0cm9rZT1cIm5vbmVcIl0pOm5vdChbc3Ryb2tlPVwidHJhbnNwYXJlbnRcIl0pIHtcbiAgICAgICAgICBzdHJva2U6ICNmZmZmZmYgIWltcG9ydGFudDtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLmRqcy1jb250YWluZXIgc3ZnIGNpcmNsZTpub3QoW3N0cm9rZT1cIm5vbmVcIl0pOm5vdChbc3Ryb2tlPVwidHJhbnNwYXJlbnRcIl0pIHtcbiAgICAgICAgICBzdHJva2U6ICNmZmZmZmYgIWltcG9ydGFudDtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLmRqcy1jb250YWluZXIgc3ZnIGVsbGlwc2U6bm90KFtzdHJva2U9XCJub25lXCJdKTpub3QoW3N0cm9rZT1cInRyYW5zcGFyZW50XCJdKSB7XG4gICAgICAgICAgc3Ryb2tlOiAjZmZmZmZmICFpbXBvcnRhbnQ7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC5kanMtY29udGFpbmVyIHN2ZyBwb2x5Z29uOm5vdChbc3Ryb2tlPVwibm9uZVwiXSk6bm90KFtzdHJva2U9XCJ0cmFuc3BhcmVudFwiXSkge1xuICAgICAgICAgIHN0cm9rZTogI2ZmZmZmZiAhaW1wb3J0YW50O1xuICAgICAgICB9XG4gICAgICBgIDogYFxuICAgICAgICAuZGpzLWNvbnRhaW5lciBzdmcgKjpub3QoW3N0cm9rZT1cIm5vbmVcIl0pOm5vdChbc3Ryb2tlPVwidHJhbnNwYXJlbnRcIl0pIHtcbiAgICAgICAgICBzdHJva2U6ICMwMDAwMDAgIWltcG9ydGFudDtcbiAgICAgICAgfVxuICAgICAgYH1cbiAgICBgXG4gICAgXG4gICAgICAvLyBPbmx5IGFwcGVuZCBpZiBub3QgYWxyZWFkeSBpbiBET01cbiAgICAgIGlmICghc3R5bGUucGFyZW50Tm9kZSkge1xuICAgICAgICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKHN0eWxlKVxuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBBbHNvIGFkZCBjbGFzcyB0byB0aGUgY2FudmFzIGNvbnRhaW5lciBmb3IgQ1NTIHRhcmdldGluZ1xuICAgICAgaWYgKGNvbnRhaW5lcikge1xuICAgICAgICBpZiAoaXNEYXJrKSB7XG4gICAgICAgICAgY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoJ2RhcmstbW9kZScpXG4gICAgICAgICAgY29udGFpbmVyLmNsYXNzTGlzdC5yZW1vdmUoJ2xpZ2h0LW1vZGUnKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKCdsaWdodC1tb2RlJylcbiAgICAgICAgICBjb250YWluZXIuY2xhc3NMaXN0LnJlbW92ZSgnZGFyay1tb2RlJylcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gRGlyZWN0bHkgc2V0IGJhY2tncm91bmQgb24gY29udGFpbmVyIGFuZCBTVkdcbiAgICAgICAgY29udGFpbmVyLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IGlzRGFyayA/ICcjMTExODI3JyA6ICcjZjlmYWZiJ1xuICAgICAgICBjb25zdCBzdmdFbGVtZW50ID0gY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoJ3N2ZycpXG4gICAgICAgIGlmIChzdmdFbGVtZW50KSB7XG4gICAgICAgICAgc3ZnRWxlbWVudC5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBpc0RhcmsgPyAnIzExMTgyNycgOiAnI2Y5ZmFmYidcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBGb3JjZSBhIHJlZHJhdyAtIGJ1dCBjaGVjayBpZiBldmVudEJ1cyBleGlzdHNcbiAgICAgIGNvbnN0IGV2ZW50QnVzID0gbW9kZWxlci5nZXQoJ2V2ZW50QnVzJykgYXMgYW55XG4gICAgICBpZiAoZXZlbnRCdXMpIHtcbiAgICAgICAgZXZlbnRCdXMuZmlyZSgnY2FudmFzLnZpZXdib3guY2hhbmdlZCcpXG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIEFHR1JFU1NJVkUgRkFMTEJBQ0s6IEZvcmNlIGNvbG9yIHVwZGF0ZXMgb24gQUxMIGVsZW1lbnRzXG4gICAgICBjb25zdCBmb3JjZUNvbG9yVXBkYXRlID0gKCkgPT4ge1xuICAgICAgICBjb25zdCBzdmdFbGVtZW50cyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5kanMtY29udGFpbmVyIHN2ZyAqJylcbiAgICAgICAgc3ZnRWxlbWVudHMuZm9yRWFjaCgoZWw6IGFueSkgPT4ge1xuICAgICAgICAgIGNvbnN0IHRhZ05hbWUgPSBlbC50YWdOYW1lPy50b0xvd2VyQ2FzZSgpXG4gICAgICAgICAgXG4gICAgICAgICAgLy8gRk9SQ0Ugc3Ryb2tlIGNvbG9yc1xuICAgICAgICAgIGlmIChlbC5oYXNBdHRyaWJ1dGUoJ3N0cm9rZScpIHx8IGVsLnN0eWxlLnN0cm9rZSkge1xuICAgICAgICAgICAgY29uc3QgY3VycmVudFN0cm9rZSA9IGVsLmdldEF0dHJpYnV0ZSgnc3Ryb2tlJykgfHwgZWwuc3R5bGUuc3Ryb2tlXG4gICAgICAgICAgICBpZiAoY3VycmVudFN0cm9rZSAmJiBjdXJyZW50U3Ryb2tlICE9PSAnbm9uZScgJiYgY3VycmVudFN0cm9rZSAhPT0gJ3RyYW5zcGFyZW50Jykge1xuICAgICAgICAgICAgICAvLyBDaGVjayBpZiBpdCdzIGEgYmxhY2sgc3Ryb2tlIGluIGRhcmsgbW9kZSBvciB3aGl0ZSBpbiBsaWdodCBtb2RlIChuZWVkcyBmaXhpbmcpXG4gICAgICAgICAgICAgIGNvbnN0IG5lZWRzRml4ID0gKGlzRGFyayAmJiAoY3VycmVudFN0cm9rZSA9PT0gJyMwMDAwMDAnIHx8IGN1cnJlbnRTdHJva2UgPT09ICdibGFjaycgfHwgY3VycmVudFN0cm9rZSA9PT0gJ3JnYigwLCAwLCAwKScpKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoIWlzRGFyayAmJiAoY3VycmVudFN0cm9rZSA9PT0gJyNmZmZmZmYnIHx8IGN1cnJlbnRTdHJva2UgPT09ICd3aGl0ZScgfHwgY3VycmVudFN0cm9rZSA9PT0gJ3JnYigyNTUsIDI1NSwgMjU1KScpKVxuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgaWYgKG5lZWRzRml4IHx8IHRhZ05hbWUgPT09ICdyZWN0JyB8fCB0YWdOYW1lID09PSAnY2lyY2xlJyB8fCB0YWdOYW1lID09PSAncG9seWdvbicgfHwgdGFnTmFtZSA9PT0gJ3BhdGgnIHx8IHRhZ05hbWUgPT09ICdsaW5lJykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5ld1N0cm9rZSA9IGlzRGFyayA/ICcjZmZmZmZmJyA6ICcjMDAwMDAwJ1xuICAgICAgICAgICAgICAgIGVsLnNldEF0dHJpYnV0ZSgnc3Ryb2tlJywgbmV3U3Ryb2tlKVxuICAgICAgICAgICAgICAgIGVsLnN0eWxlLnN0cm9rZSA9IG5ld1N0cm9rZVxuICAgICAgICAgICAgICAgIGVsLnN0eWxlLnN0cm9rZU9wYWNpdHkgPSAnMSdcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICAvLyBGT1JDRSBmaWxsIGNvbG9ycyBmb3Igc2hhcGVzXG4gICAgICAgICAgaWYgKHRhZ05hbWUgPT09ICdyZWN0JyB8fCB0YWdOYW1lID09PSAnY2lyY2xlJyB8fCB0YWdOYW1lID09PSAnZWxsaXBzZScgfHwgdGFnTmFtZSA9PT0gJ3BvbHlnb24nKSB7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50RmlsbCA9IGVsLmdldEF0dHJpYnV0ZSgnZmlsbCcpIHx8IGVsLnN0eWxlLmZpbGxcbiAgICAgICAgICAgIGlmIChjdXJyZW50RmlsbCAmJiBjdXJyZW50RmlsbCAhPT0gJ25vbmUnICYmIGN1cnJlbnRGaWxsICE9PSAndHJhbnNwYXJlbnQnKSB7XG4gICAgICAgICAgICAgIC8vIFNraXAgc2VsZWN0aW9uIGJveGVzXG4gICAgICAgICAgICAgIGlmICghZWwuY2xvc2VzdCgnLmRqcy1vdXRsaW5lJykgJiYgIWVsLmNsb3Nlc3QoJy5kanMtc2VsZWN0aW9uJykpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdGaWxsID0gaXNEYXJrID8gJyMxZjI5MzcnIDogJyNmZmZmZmYnXG4gICAgICAgICAgICAgICAgZWwuc2V0QXR0cmlidXRlKCdmaWxsJywgbmV3RmlsbClcbiAgICAgICAgICAgICAgICBlbC5zdHlsZS5maWxsID0gbmV3RmlsbFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIC8vIFRleHQgYW5kIGljb25zXG4gICAgICAgICAgaWYgKHRhZ05hbWUgPT09ICd0ZXh0JyB8fCB0YWdOYW1lID09PSAndHNwYW4nKSB7XG4gICAgICAgICAgICBjb25zdCBuZXdDb2xvciA9IGlzRGFyayA/ICcjZmZmZmZmJyA6ICcjMDAwMDAwJ1xuICAgICAgICAgICAgZWwuc2V0QXR0cmlidXRlKCdmaWxsJywgbmV3Q29sb3IpXG4gICAgICAgICAgICBlbC5zdHlsZS5maWxsID0gbmV3Q29sb3JcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIFJ1biBtdWx0aXBsZSB0aW1lcyB0byBjYXRjaCBhbGwgdXBkYXRlc1xuICAgICAgZm9yY2VDb2xvclVwZGF0ZSgpXG4gICAgICBzZXRUaW1lb3V0KGZvcmNlQ29sb3JVcGRhdGUsIDUwKVxuICAgICAgc2V0VGltZW91dChmb3JjZUNvbG9yVXBkYXRlLCAxMDApXG4gICAgICBzZXRUaW1lb3V0KGZvcmNlQ29sb3JVcGRhdGUsIDIwMClcbiAgICAgIHNldFRpbWVvdXQoZm9yY2VDb2xvclVwZGF0ZSwgNTAwKVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgYXBwbHlpbmcgQlBNTiBzdHlsZXM6JywgZXJyKVxuICAgIH1cbiAgfSwgW10pXG5cbiAgLy8gSW5pdGlhbGl6ZSBCUE1OIE1vZGVsZXJcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBsZXQgbW91bnRlZCA9IHRydWVcbiAgICBsZXQgbW9kZWxlcjogQnBtbk1vZGVsZXIgfCBudWxsID0gbnVsbFxuICAgIGxldCBvYnNlcnZlcjogTXV0YXRpb25PYnNlcnZlciB8IG51bGwgPSBudWxsXG5cbiAgICBjb25zdCBpbml0QnBtbiA9IGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGNvbnRhaW5lciA9IGNvbnRhaW5lclJlZi5jdXJyZW50XG4gICAgICBpZiAoIWNvbnRhaW5lciB8fCAhbW91bnRlZCkgcmV0dXJuXG5cbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIFdhaXQgZm9yIGNvbnRhaW5lciB0byBoYXZlIGRpbWVuc2lvbnNcbiAgICAgICAgaWYgKGNvbnRhaW5lci5vZmZzZXRXaWR0aCA9PT0gMCB8fCBjb250YWluZXIub2Zmc2V0SGVpZ2h0ID09PSAwKSB7XG4gICAgICAgICAgc2V0VGltZW91dChpbml0QnBtbiwgMTAwKVxuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ3JlYXRlIG1vZGVsZXIgd2l0aCBmdWxsIGRlZmF1bHQgbW9kdWxlcyAoaW5jbHVkaW5nIHBhbGV0dGUpXG4gICAgICAgIG1vZGVsZXIgPSBuZXcgQnBtbk1vZGVsZXIoe1xuICAgICAgICAgIGNvbnRhaW5lcjogY29udGFpbmVyLFxuICAgICAgICAgIGtleWJvYXJkOiB7XG4gICAgICAgICAgICBiaW5kVG86IHdpbmRvd1xuICAgICAgICAgIH0sXG4gICAgICAgICAgLy8gRW5zdXJlIGFsbCBkZWZhdWx0IG1vZHVsZXMgYXJlIGVuYWJsZWRcbiAgICAgICAgICBhZGRpdGlvbmFsTW9kdWxlczogW10sXG4gICAgICAgICAgbW9kZGxlRXh0ZW5zaW9uczoge31cbiAgICAgICAgfSlcbiAgICAgICAgXG4gICAgICAgIG1vZGVsZXJSZWYuY3VycmVudCA9IG1vZGVsZXJcblxuICAgICAgICAvLyBJbXBvcnQgZGVmYXVsdCBkaWFncmFtXG4gICAgICAgIGF3YWl0IG1vZGVsZXIuaW1wb3J0WE1MKERFRkFVTFRfQlBNTilcbiAgICAgICAgXG4gICAgICAgIC8vIFdhaXQgYSBiaXQgZm9yIGNhbnZhcyB0byBiZSBmdWxseSBpbml0aWFsaXplZFxuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgNTApKVxuXG4gICAgICAgIC8vIFNldHVwIGNvbW1hbmQgc3RhY2sgbGlzdGVuZXJzIC0gd2l0aCBzYWZldHkgY2hlY2tzXG4gICAgICAgIGNvbnN0IGV2ZW50QnVzID0gbW9kZWxlci5nZXQoJ2V2ZW50QnVzJykgYXMgYW55XG4gICAgICAgIGNvbnN0IGNvbW1hbmRTdGFjayA9IG1vZGVsZXIuZ2V0KCdjb21tYW5kU3RhY2snKSBhcyBhbnlcbiAgICAgICAgXG4gICAgICAgIGlmICghZXZlbnRCdXMgfHwgIWNvbW1hbmRTdGFjaykge1xuICAgICAgICAgIGNvbnNvbGUud2FybignQlBNTiBtb2R1bGVzIG5vdCBmdWxseSBpbml0aWFsaXplZCwgcmV0cnlpbmcuLi4nKVxuICAgICAgICAgIHNldFRpbWVvdXQoaW5pdEJwbW4sIDEwMClcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgY29uc3QgdXBkYXRlVW5kb1JlZG8gPSAoKSA9PiB7XG4gICAgICAgICAgaWYgKCFtb3VudGVkKSByZXR1cm5cbiAgICAgICAgICBzZXRDYW5VbmRvKGNvbW1hbmRTdGFjay5jYW5VbmRvKCkpXG4gICAgICAgICAgc2V0Q2FuUmVkbyhjb21tYW5kU3RhY2suY2FuUmVkbygpKVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBldmVudEJ1cy5vbignY29tbWFuZFN0YWNrLmNoYW5nZWQnLCB1cGRhdGVVbmRvUmVkbylcbiAgICAgICAgdXBkYXRlVW5kb1JlZG8oKVxuICAgICAgICBcbiAgICAgICAgLy8gVHJhY2sgc2VsZWN0aW9uIGNoYW5nZXMgZm9yIGFsaWdubWVudCB0b29sc1xuICAgICAgICBjb25zdCBzZWxlY3Rpb24gPSBtb2RlbGVyLmdldCgnc2VsZWN0aW9uJykgYXMgYW55XG4gICAgICAgIGV2ZW50QnVzLm9uKCdzZWxlY3Rpb24uY2hhbmdlZCcsIChlOiBhbnkpID0+IHtcbiAgICAgICAgICBpZiAoIW1vdW50ZWQpIHJldHVyblxuICAgICAgICAgIGNvbnN0IGVsZW1lbnRzID0gZS5uZXdTZWxlY3Rpb24gfHwgW11cbiAgICAgICAgICBzZXRTZWxlY3RlZEVsZW1lbnRzKGVsZW1lbnRzKVxuICAgICAgICAgIFxuICAgICAgICAgIC8vIEFwcGx5IHZpc3VhbCBmZWVkYmFjayBmb3Igc2VsZWN0aW9uXG4gICAgICAgICAgaWYgKGVsZW1lbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBTZWxlY3RlZCAke2VsZW1lbnRzLmxlbmd0aH0gZWxlbWVudChzKWApXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIEZPUkNFIFRSQU5TUEFSRU5DWTogUmVtb3ZlIGFueSBvcGFxdWUgc2VsZWN0aW9uIGJveGVzXG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgY29uc3Qgc2VsZWN0aW9uQm94ZXMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcuZGpzLW91dGxpbmUgcmVjdCwgLmRqcy1zZWxlY3Rpb24gcmVjdCwgW2NsYXNzKj1cInNlbGVjdFwiXSByZWN0JylcbiAgICAgICAgICAgICAgc2VsZWN0aW9uQm94ZXMuZm9yRWFjaCgoYm94OiBhbnkpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBTa2lwIGFjdHVhbCBzaGFwZSByZWN0YW5nbGVzXG4gICAgICAgICAgICAgICAgaWYgKGJveC5jbG9zZXN0KCcuZGpzLXZpc3VhbCcpKSByZXR1cm5cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvLyBGb3JjZSB0cmFuc3BhcmVudCBmaWxsXG4gICAgICAgICAgICAgICAgYm94LnN0eWxlLmZpbGwgPSAndHJhbnNwYXJlbnQnXG4gICAgICAgICAgICAgICAgYm94LnN0eWxlLmZpbGxPcGFjaXR5ID0gJzAnXG4gICAgICAgICAgICAgICAgYm94LnNldEF0dHJpYnV0ZSgnZmlsbCcsICdub25lJylcbiAgICAgICAgICAgICAgICBib3guc2V0QXR0cmlidXRlKCdmaWxsLW9wYWNpdHknLCAnMCcpXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAvLyBBbHNvIGNoZWNrIGZvciBhbnkgc2VsZWN0aW9uIGZyYW1lc1xuICAgICAgICAgICAgICBjb25zdCBmcmFtZXMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcuZGpzLWZyYW1lLCAuZGpzLXNlbGVjdGlvbi1mcmFtZSwgLmRqcy1zZWxlY3QtdmlzdWFsJylcbiAgICAgICAgICAgICAgZnJhbWVzLmZvckVhY2goKGZyYW1lOiBhbnkpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZnJhbWUudGFnTmFtZSA9PT0gJ3JlY3QnIHx8IGZyYW1lLnF1ZXJ5U2VsZWN0b3IoJ3JlY3QnKSkge1xuICAgICAgICAgICAgICAgICAgY29uc3QgcmVjdCA9IGZyYW1lLnRhZ05hbWUgPT09ICdyZWN0JyA/IGZyYW1lIDogZnJhbWUucXVlcnlTZWxlY3RvcigncmVjdCcpXG4gICAgICAgICAgICAgICAgICBpZiAocmVjdCAmJiAhcmVjdC5jbG9zZXN0KCcuZGpzLXZpc3VhbCcpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlY3Quc3R5bGUuZmlsbCA9ICd0cmFuc3BhcmVudCdcbiAgICAgICAgICAgICAgICAgICAgcmVjdC5zZXRBdHRyaWJ1dGUoJ2ZpbGwnLCAnbm9uZScpXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSwgMClcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICAgIFxuICAgICAgICAvLyBBZGQga2V5Ym9hcmQgc2hvcnRjdXRzXG4gICAgICAgIGNvbnN0IGtleWJvYXJkID0gbW9kZWxlci5nZXQoJ2tleWJvYXJkJykgYXMgYW55XG4gICAgICAgIGNvbnN0IGVkaXRvckFjdGlvbnMgPSBtb2RlbGVyLmdldCgnZWRpdG9yQWN0aW9ucycpIGFzIGFueVxuICAgICAgICBcbiAgICAgICAgaWYgKGtleWJvYXJkICYmIGVkaXRvckFjdGlvbnMpIHtcbiAgICAgICAgICAvLyBSZWdpc3RlciBDdHJsK0EgZm9yIHNlbGVjdCBhbGxcbiAgICAgICAgICBlZGl0b3JBY3Rpb25zLnJlZ2lzdGVyKCdzZWxlY3RBbGwnLCAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBlbGVtZW50UmVnaXN0cnkgPSBtb2RlbGVyLmdldCgnZWxlbWVudFJlZ2lzdHJ5JykgYXMgYW55XG4gICAgICAgICAgICBjb25zdCBhbGxFbGVtZW50cyA9IGVsZW1lbnRSZWdpc3RyeS5maWx0ZXIoKGVsZW1lbnQ6IGFueSkgPT4ge1xuICAgICAgICAgICAgICByZXR1cm4gZWxlbWVudC50eXBlICE9PSAnbGFiZWwnICYmIFxuICAgICAgICAgICAgICAgICAgICAgZWxlbWVudC50eXBlICE9PSAnYnBtbjpTZXF1ZW5jZUZsb3cnICYmXG4gICAgICAgICAgICAgICAgICAgICBlbGVtZW50LmlkICE9PSAnUHJvY2Vzc18xJyAmJlxuICAgICAgICAgICAgICAgICAgICAgIWVsZW1lbnQubGFiZWxUYXJnZXRcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICBzZWxlY3Rpb24uc2VsZWN0KGFsbEVsZW1lbnRzKVxuICAgICAgICAgICAgY29uc29sZS5sb2coYFNlbGVjdGVkIGFsbCAke2FsbEVsZW1lbnRzLmxlbmd0aH0gZWxlbWVudHNgKVxuICAgICAgICAgIH0pXG4gICAgICAgICAgXG4gICAgICAgICAgLy8gUmVnaXN0ZXIgc3BhY2ViYXIgZm9yIHJlcGxhY2UgbWVudVxuICAgICAgICAgIGVkaXRvckFjdGlvbnMucmVnaXN0ZXIoJ3Nob3dSZXBsYWNlTWVudScsICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHNlbGVjdGVkRWxlbWVudHMgPSBzZWxlY3Rpb24uZ2V0KClcbiAgICAgICAgICAgIGlmIChzZWxlY3RlZEVsZW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICBjb25zdCBlbGVtZW50ID0gc2VsZWN0ZWRFbGVtZW50c1swXVxuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgLy8gU2tpcCBpZiBpdCdzIHRoZSByb290IGVsZW1lbnRcbiAgICAgICAgICAgICAgaWYgKGVsZW1lbnQuaWQgPT09ICdQcm9jZXNzXzEnIHx8IGVsZW1lbnQudHlwZSA9PT0gJ2JwbW46UHJvY2VzcycpIHtcbiAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgLy8gR2V0IHRoZSByZXBsYWNlIG1lbnUgbW9kdWxlXG4gICAgICAgICAgICAgIGNvbnN0IHBvcHVwTWVudSA9IG1vZGVsZXIuZ2V0KCdwb3B1cE1lbnUnKSBhcyBhbnlcbiAgICAgICAgICAgICAgY29uc3QgcmVwbGFjZU1lbnVQcm92aWRlciA9IG1vZGVsZXIuZ2V0KCdyZXBsYWNlTWVudVByb3ZpZGVyJykgYXMgYW55XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICBpZiAocG9wdXBNZW51ICYmIHJlcGxhY2VNZW51UHJvdmlkZXIpIHtcbiAgICAgICAgICAgICAgICAvLyBHZXQgdGhlIHBvc2l0aW9uIG9mIHRoZSBzZWxlY3RlZCBlbGVtZW50XG4gICAgICAgICAgICAgICAgY29uc3QgZWxlbWVudFJlZ2lzdHJ5ID0gbW9kZWxlci5nZXQoJ2VsZW1lbnRSZWdpc3RyeScpIGFzIGFueVxuICAgICAgICAgICAgICAgIGNvbnN0IGVsZW1lbnRTaGFwZSA9IGVsZW1lbnRSZWdpc3RyeS5nZXQoZWxlbWVudC5pZClcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudFNoYXBlKSB7XG4gICAgICAgICAgICAgICAgICAvLyBDYWxjdWxhdGUgcG9zaXRpb24gZm9yIHRoZSBwb3B1cFxuICAgICAgICAgICAgICAgICAgY29uc3QgcG9zaXRpb24gPSB7XG4gICAgICAgICAgICAgICAgICAgIHg6IGVsZW1lbnRTaGFwZS54ICsgKGVsZW1lbnRTaGFwZS53aWR0aCB8fCAxMDApIC8gMixcbiAgICAgICAgICAgICAgICAgICAgeTogZWxlbWVudFNoYXBlLnkgLSAxMFxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAvLyBHZXQgcmVwbGFjZSBvcHRpb25zIGZvciB0aGlzIGVsZW1lbnRcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGVudHJpZXMgPSByZXBsYWNlTWVudVByb3ZpZGVyLmdldFBvcHVwTWVudUVudHJpZXMoZWxlbWVudClcbiAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgaWYgKGVudHJpZXMgJiYgT2JqZWN0LmtleXMoZW50cmllcykubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBPcGVuIHRoZSBwb3B1cCBtZW51XG4gICAgICAgICAgICAgICAgICAgIHBvcHVwTWVudS5vcGVuKGVsZW1lbnQsICdicG1uLXJlcGxhY2UnLCBwb3NpdGlvbiwgZW50cmllcylcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1JlcGxhY2UgbWVudSBvcGVuZWQgZm9yOicsIGVsZW1lbnQudHlwZSlcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gRmFsbGJhY2s6IFRyeSB0byB0cmlnZ2VyIHRoZSByZXBsYWNlIHRvb2wgZGlyZWN0bHlcbiAgICAgICAgICAgICAgICBjb25zdCByZXBsYWNlUHJldmlldyA9IG1vZGVsZXIuZ2V0KCdyZXBsYWNlUHJldmlldycpIGFzIGFueVxuICAgICAgICAgICAgICAgIGlmIChyZXBsYWNlUHJldmlldykge1xuICAgICAgICAgICAgICAgICAgcmVwbGFjZVByZXZpZXcudG9nZ2xlKClcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICAgIFxuICAgICAgICAgIC8vIEJpbmQga2V5Ym9hcmQgc2hvcnRjdXRzXG4gICAgICAgICAga2V5Ym9hcmQuYWRkTGlzdGVuZXIoKGNvbnRleHQ6IGFueSkgPT4ge1xuICAgICAgICAgICAgY29uc3Qga2V5ID0gY29udGV4dC5rZXlFdmVudC5rZXlcbiAgICAgICAgICAgIGNvbnN0IGN0cmwgPSBjb250ZXh0LmtleUV2ZW50LmN0cmxLZXkgfHwgY29udGV4dC5rZXlFdmVudC5tZXRhS2V5XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIEN0cmwrQSBvciBDbWQrQSBmb3Igc2VsZWN0IGFsbFxuICAgICAgICAgICAgaWYgKGN0cmwgJiYga2V5ID09PSAnYScpIHtcbiAgICAgICAgICAgICAgZWRpdG9yQWN0aW9ucy50cmlnZ2VyKCdzZWxlY3RBbGwnKVxuICAgICAgICAgICAgICBjb250ZXh0LmtleUV2ZW50LnByZXZlbnREZWZhdWx0KClcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gU3BhY2ViYXIgZm9yIHJlcGxhY2UgbWVudVxuICAgICAgICAgICAgaWYgKGtleSA9PT0gJyAnICYmICFjdHJsICYmICFjb250ZXh0LmtleUV2ZW50LnNoaWZ0S2V5ICYmICFjb250ZXh0LmtleUV2ZW50LmFsdEtleSkge1xuICAgICAgICAgICAgICAvLyBDaGVjayBpZiB3ZSdyZSBub3QgaW4gYSB0ZXh0IGlucHV0XG4gICAgICAgICAgICAgIGNvbnN0IGFjdGl2ZUVsZW1lbnQgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50XG4gICAgICAgICAgICAgIGlmIChhY3RpdmVFbGVtZW50ICYmIChhY3RpdmVFbGVtZW50LnRhZ05hbWUgPT09ICdJTlBVVCcgfHwgYWN0aXZlRWxlbWVudC50YWdOYW1lID09PSAnVEVYVEFSRUEnKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICBlZGl0b3JBY3Rpb25zLnRyaWdnZXIoJ3Nob3dSZXBsYWNlTWVudScpXG4gICAgICAgICAgICAgIGNvbnRleHQua2V5RXZlbnQucHJldmVudERlZmF1bHQoKVxuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gQXBwbHkgaW5pdGlhbCBzdHlsZXNcbiAgICAgICAgYXBwbHlCcG1uU3R5bGVzKG1vZGVsZXIsIHRoZW1lKVxuICAgICAgICBcbiAgICAgICAgLy8gQWRkIGEgZ2xvYmFsIGtleWJvYXJkIGxpc3RlbmVyIGZvciBzcGFjZWJhciAoZmFsbGJhY2spXG4gICAgICAgIGNvbnN0IGhhbmRsZUdsb2JhbEtleWRvd24gPSAoZTogS2V5Ym9hcmRFdmVudCkgPT4ge1xuICAgICAgICAgIC8vIE9ubHkgaGFuZGxlIHNwYWNlYmFyIHdoZW4gY2FudmFzIGlzIGZvY3VzZWRcbiAgICAgICAgICBpZiAoZS5rZXkgPT09ICcgJyAmJiAhZS5jdHJsS2V5ICYmICFlLm1ldGFLZXkgJiYgIWUuc2hpZnRLZXkgJiYgIWUuYWx0S2V5KSB7XG4gICAgICAgICAgICBjb25zdCBhY3RpdmVFbGVtZW50ID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudFxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBTa2lwIGlmIHR5cGluZyBpbiBhbiBpbnB1dFxuICAgICAgICAgICAgaWYgKGFjdGl2ZUVsZW1lbnQgJiYgXG4gICAgICAgICAgICAgICAgKGFjdGl2ZUVsZW1lbnQudGFnTmFtZSA9PT0gJ0lOUFVUJyB8fCBcbiAgICAgICAgICAgICAgICAgYWN0aXZlRWxlbWVudC50YWdOYW1lID09PSAnVEVYVEFSRUEnIHx8XG4gICAgICAgICAgICAgICAgIGFjdGl2ZUVsZW1lbnQuZ2V0QXR0cmlidXRlKCdjb250ZW50ZWRpdGFibGUnKSA9PT0gJ3RydWUnKSkge1xuICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIGNhbnZhcyBvciBpdHMgY29udGFpbmVyIGhhcyBmb2N1c1xuICAgICAgICAgICAgY29uc3QgY2FudmFzRWxlbWVudCA9IGNvbnRhaW5lci5xdWVyeVNlbGVjdG9yKCcuZGpzLWNvbnRhaW5lcicpXG4gICAgICAgICAgICBpZiAoY2FudmFzRWxlbWVudCAmJiAoY2FudmFzRWxlbWVudC5jb250YWlucyhhY3RpdmVFbGVtZW50KSB8fCBhY3RpdmVFbGVtZW50ID09PSBkb2N1bWVudC5ib2R5KSkge1xuICAgICAgICAgICAgICBjb25zdCBzZWxlY3RlZEVsZW1lbnRzID0gc2VsZWN0aW9uLmdldCgpXG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICBpZiAoc2VsZWN0ZWRFbGVtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KClcbiAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpXG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgY29uc3QgZWxlbWVudCA9IHNlbGVjdGVkRWxlbWVudHNbMF1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvLyBTa2lwIHJvb3QgZWxlbWVudFxuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50LmlkID09PSAnUHJvY2Vzc18xJyB8fCBlbGVtZW50LnR5cGUgPT09ICdicG1uOlByb2Nlc3MnKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1NwYWNlYmFyIHByZXNzZWQgd2l0aCBlbGVtZW50IHNlbGVjdGVkOicsIGVsZW1lbnQudHlwZSlcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvLyBUcnkgdG8gb3BlbiByZXBsYWNlIG1lbnVcbiAgICAgICAgICAgICAgICBjb25zdCBwb3B1cE1lbnUgPSBtb2RlbGVyLmdldCgncG9wdXBNZW51JykgYXMgYW55XG4gICAgICAgICAgICAgICAgY29uc3QgcmVwbGFjZU1lbnVQcm92aWRlciA9IG1vZGVsZXIuZ2V0KCdyZXBsYWNlTWVudVByb3ZpZGVyJykgYXMgYW55XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgaWYgKHBvcHVwTWVudSAmJiByZXBsYWNlTWVudVByb3ZpZGVyKSB7XG4gICAgICAgICAgICAgICAgICBjb25zdCBlbGVtZW50UmVnaXN0cnkgPSBtb2RlbGVyLmdldCgnZWxlbWVudFJlZ2lzdHJ5JykgYXMgYW55XG4gICAgICAgICAgICAgICAgICBjb25zdCBlbGVtZW50U2hhcGUgPSBlbGVtZW50UmVnaXN0cnkuZ2V0KGVsZW1lbnQuaWQpXG4gICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgIGlmIChlbGVtZW50U2hhcGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcG9zaXRpb24gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgeDogZWxlbWVudFNoYXBlLnggKyAoZWxlbWVudFNoYXBlLndpZHRoIHx8IDEwMCkgLyAyLFxuICAgICAgICAgICAgICAgICAgICAgIHk6IGVsZW1lbnRTaGFwZS55IC0gMTBcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZW50cmllcyA9IHJlcGxhY2VNZW51UHJvdmlkZXIuZ2V0UG9wdXBNZW51RW50cmllcyhlbGVtZW50KVxuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVudHJpZXMgJiYgT2JqZWN0LmtleXMoZW50cmllcykubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgIHBvcHVwTWVudS5vcGVuKGVsZW1lbnQsICdicG1uLXJlcGxhY2UnLCBwb3NpdGlvbiwgZW50cmllcylcbiAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnUmVwbGFjZSBtZW51IHRyaWdnZXJlZCB2aWEgc3BhY2ViYXInKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBBdHRhY2ggdGhlIGdsb2JhbCBsaXN0ZW5lclxuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgaGFuZGxlR2xvYmFsS2V5ZG93bilcbiAgICAgICAgXG4gICAgICAgIC8vIFN0b3JlIHJlZmVyZW5jZSBmb3IgY2xlYW51cFxuICAgICAgICBtb2RlbGVyUmVmLmN1cnJlbnQuX3NwYWNlYmFySGFuZGxlciA9IGhhbmRsZUdsb2JhbEtleWRvd25cbiAgICAgICAgXG4gICAgICAgIC8vIEFwcGx5IGluaXRpYWwgZ3JpZCBzdGF0ZVxuICAgICAgICBjb25zdCBjYW52YXMgPSBtb2RlbGVyLmdldCgnY2FudmFzJykgYXMgYW55XG4gICAgICAgIGNvbnN0IGNhbnZhc0NvbnRhaW5lciA9IGNhbnZhcy5fY29udGFpbmVyIHx8IGNhbnZhcy5nZXRDb250YWluZXIoKVxuICAgICAgICBpZiAoY2FudmFzQ29udGFpbmVyICYmIHNob3dHcmlkKSB7XG4gICAgICAgICAgY2FudmFzQ29udGFpbmVyLmNsYXNzTGlzdC5hZGQoJ3Nob3ctZ3JpZCcpXG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIFNldCB1cCBNdXRhdGlvbk9ic2VydmVyIHRvIGNhdGNoIGR5bmFtaWNhbGx5IGFkZGVkIGVsZW1lbnRzXG4gICAgICAgIGlmIChjYW52YXNDb250YWluZXIpIHtcbiAgICAgICAgICBvYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKChtdXRhdGlvbnMpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRUaGVtZSA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoJ2RhcmsnKSA/ICdkYXJrJyA6ICdsaWdodCdcbiAgICAgICAgICAgIGNvbnN0IGlzRGFya01vZGUgPSBjdXJyZW50VGhlbWUgPT09ICdkYXJrJ1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBtdXRhdGlvbnMuZm9yRWFjaCgobXV0YXRpb24pID0+IHtcbiAgICAgICAgICAgICAgLy8gUHJvY2VzcyBhZGRlZCBub2Rlc1xuICAgICAgICAgICAgICBtdXRhdGlvbi5hZGRlZE5vZGVzLmZvckVhY2goKG5vZGU6IGFueSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChub2RlLm5vZGVUeXBlID09PSAxKSB7IC8vIEVsZW1lbnQgbm9kZVxuICAgICAgICAgICAgICAgICAgLy8gUHJvY2VzcyB0aGUgbm9kZSBpdHNlbGYgaWYgaXQncyBhbiBTVkcgZWxlbWVudFxuICAgICAgICAgICAgICAgICAgaWYgKG5vZGUudGFnTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0YWdOYW1lID0gbm9kZS50YWdOYW1lLnRvTG93ZXJDYXNlKClcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIC8vIElNTUVESUFURSBmaXggZm9yIHJlY3RhbmdsZXMgKFRhc2tzKVxuICAgICAgICAgICAgICAgICAgICBpZiAodGFnTmFtZSA9PT0gJ3JlY3QnIHx8IHRhZ05hbWUgPT09ICdnJyB8fCB0YWdOYW1lID09PSAnc3ZnJykge1xuICAgICAgICAgICAgICAgICAgICAgIC8vIEZpeCB0aGUgbm9kZSBpdHNlbGZcbiAgICAgICAgICAgICAgICAgICAgICBpZiAodGFnTmFtZSA9PT0gJ3JlY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLnN0eWxlLnN0cm9rZSA9IGlzRGFya01vZGUgPyAnI2ZmZmZmZicgOiAnIzAwMDAwMCdcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKCdzdHJva2UnLCBpc0RhcmtNb2RlID8gJyNmZmZmZmYnIDogJyMwMDAwMDAnKVxuICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW5vZGUuY2xvc2VzdCgnLmRqcy1vdXRsaW5lJykgJiYgIW5vZGUuY2xvc2VzdCgnLmRqcy1zZWxlY3Rpb24nKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLnN0eWxlLmZpbGwgPSBpc0RhcmtNb2RlID8gJyMxZjI5MzcnIDogJyNmZmZmZmYnXG4gICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKCdmaWxsJywgaXNEYXJrTW9kZSA/ICcjMWYyOTM3JyA6ICcjZmZmZmZmJylcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgLy8gRml4IGFsbCByZWN0IGNoaWxkcmVuXG4gICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVjdHMgPSBub2RlLnF1ZXJ5U2VsZWN0b3JBbGwgPyBub2RlLnF1ZXJ5U2VsZWN0b3JBbGwoJ3JlY3QnKSA6IFtdXG4gICAgICAgICAgICAgICAgICAgICAgcmVjdHMuZm9yRWFjaCgocmVjdDogYW55KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWN0LnN0eWxlLnN0cm9rZSA9IGlzRGFya01vZGUgPyAnI2ZmZmZmZicgOiAnIzAwMDAwMCdcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlY3Quc2V0QXR0cmlidXRlKCdzdHJva2UnLCBpc0RhcmtNb2RlID8gJyNmZmZmZmYnIDogJyMwMDAwMDAnKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVjdC5zdHlsZS5zdHJva2VPcGFjaXR5ID0gJzEnXG4gICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcmVjdC5jbG9zZXN0KCcuZGpzLW91dGxpbmUnKSAmJiAhcmVjdC5jbG9zZXN0KCcuZGpzLXNlbGVjdGlvbicpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJlY3Quc3R5bGUuZmlsbCA9IGlzRGFya01vZGUgPyAnIzFmMjkzNycgOiAnI2ZmZmZmZidcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmVjdC5zZXRBdHRyaWJ1dGUoJ2ZpbGwnLCBpc0RhcmtNb2RlID8gJyMxZjI5MzcnIDogJyNmZmZmZmYnKVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIC8vIFByb2Nlc3MgYWxsIGRlc2NlbmRhbnRzXG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlLnF1ZXJ5U2VsZWN0b3JBbGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlbGVtZW50cyA9IG5vZGUucXVlcnlTZWxlY3RvckFsbCgnKicpXG4gICAgICAgICAgICAgICAgICAgICAgZWxlbWVudHMuZm9yRWFjaCgoZWw6IGFueSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZWxUYWcgPSBlbC50YWdOYW1lPy50b0xvd2VyQ2FzZSgpXG4gICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZvcmNlIGNvbG9ycyBvbiBhbGwgc2hhcGUgZWxlbWVudHNcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbFRhZyA9PT0gJ3JlY3QnIHx8IGVsVGFnID09PSAnY2lyY2xlJyB8fCBlbFRhZyA9PT0gJ3BvbHlnb24nIHx8IGVsVGFnID09PSAncGF0aCcgfHwgZWxUYWcgPT09ICdsaW5lJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZWwuaGFzQXR0cmlidXRlKCdzdHJva2UnKSB8fCBlbC5zdHlsZS5zdHJva2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbC5zdHlsZS5zdHJva2UgPSBpc0RhcmtNb2RlID8gJyNmZmZmZmYnIDogJyMwMDAwMDAnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWwuc2V0QXR0cmlidXRlKCdzdHJva2UnLCBpc0RhcmtNb2RlID8gJyNmZmZmZmYnIDogJyMwMDAwMDAnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsLnN0eWxlLnN0cm9rZU9wYWNpdHkgPSAnMSdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChlbFRhZyA9PT0gJ3JlY3QnIHx8IGVsVGFnID09PSAnY2lyY2xlJyB8fCBlbFRhZyA9PT0gJ3BvbHlnb24nKSAmJiBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICFlbC5jbG9zZXN0KCcuZGpzLW91dGxpbmUnKSAmJiAhZWwuY2xvc2VzdCgnLmRqcy1zZWxlY3Rpb24nKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsLnN0eWxlLmZpbGwgPSBpc0RhcmtNb2RlID8gJyMxZjI5MzcnIDogJyNmZmZmZmYnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWwuc2V0QXR0cmlidXRlKCdmaWxsJywgaXNEYXJrTW9kZSA/ICcjMWYyOTM3JyA6ICcjZmZmZmZmJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAvLyBBbHNvIGNoZWNrIGF0dHJpYnV0ZSBjaGFuZ2VzIGZvciBzdHJva2UvZmlsbFxuICAgICAgICAgICAgICBpZiAobXV0YXRpb24udHlwZSA9PT0gJ2F0dHJpYnV0ZXMnICYmIG11dGF0aW9uLnRhcmdldCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRhcmdldCA9IG11dGF0aW9uLnRhcmdldCBhcyBhbnlcbiAgICAgICAgICAgICAgICBpZiAodGFyZ2V0LnRhZ05hbWUpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHRhZ05hbWUgPSB0YXJnZXQudGFnTmFtZS50b0xvd2VyQ2FzZSgpXG4gICAgICAgICAgICAgICAgICBpZiAodGFnTmFtZSA9PT0gJ3JlY3QnICYmIChtdXRhdGlvbi5hdHRyaWJ1dGVOYW1lID09PSAnc3Ryb2tlJyB8fCBtdXRhdGlvbi5hdHRyaWJ1dGVOYW1lID09PSAnc3R5bGUnKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBGb3JjZSBjb3JyZWN0IGNvbG9yIGlmIGl0IHdhcyBjaGFuZ2VkIHRvIHdyb25nIGNvbG9yXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRTdHJva2UgPSB0YXJnZXQuZ2V0QXR0cmlidXRlKCdzdHJva2UnKSB8fCB0YXJnZXQuc3R5bGUuc3Ryb2tlXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0RhcmtNb2RlICYmIChjdXJyZW50U3Ryb2tlID09PSAnIzAwMDAwMCcgfHwgY3VycmVudFN0cm9rZSA9PT0gJ2JsYWNrJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQuc3R5bGUuc3Ryb2tlID0gJyNmZmZmZmYnXG4gICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LnNldEF0dHJpYnV0ZSgnc3Ryb2tlJywgJyNmZmZmZmYnKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH0pXG4gICAgICAgICAgXG4gICAgICAgICAgb2JzZXJ2ZXIub2JzZXJ2ZShjYW52YXNDb250YWluZXIsIHtcbiAgICAgICAgICAgIGNoaWxkTGlzdDogdHJ1ZSxcbiAgICAgICAgICAgIHN1YnRyZWU6IHRydWUsXG4gICAgICAgICAgICBhdHRyaWJ1dGVzOiB0cnVlLFxuICAgICAgICAgICAgYXR0cmlidXRlRmlsdGVyOiBbJ3N0cm9rZScsICdmaWxsJywgJ3N0eWxlJ11cbiAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgc2V0SXNSZWFkeSh0cnVlKVxuICAgICAgICBzZXRFcnJvcihudWxsKVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0JQTU4gaW5pdGlhbGl6YXRpb24gZXJyb3I6JywgZXJyKVxuICAgICAgICBzZXRFcnJvcihlcnIgaW5zdGFuY2VvZiBFcnJvciA/IGVyci5tZXNzYWdlIDogJ0ZhaWxlZCB0byBpbml0aWFsaXplJylcbiAgICAgIH1cbiAgICB9XG5cblxuICAgIC8vIFN0YXJ0IGluaXRpYWxpemF0aW9uIGFmdGVyIGEgc21hbGwgZGVsYXlcbiAgICBzZXRUaW1lb3V0KGluaXRCcG1uLCAxMDApXG5cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgbW91bnRlZCA9IGZhbHNlXG4gICAgICBpZiAob2JzZXJ2ZXIpIHtcbiAgICAgICAgb2JzZXJ2ZXIuZGlzY29ubmVjdCgpXG4gICAgICB9XG4gICAgICBpZiAobW9kZWxlcikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIG1vZGVsZXIuZGVzdHJveSgpXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAvLyBJZ25vcmUgY2xlYW51cCBlcnJvcnNcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwgW3RoZW1lLCBhcHBseUJwbW5TdHlsZXNdKVxuXG4gIC8vIFJlLWFwcGx5IHN0eWxlcyB3aGVuIHRoZW1lIGNoYW5nZXNcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAobW9kZWxlclJlZi5jdXJyZW50ICYmIGlzUmVhZHkpIHtcbiAgICAgIGFwcGx5QnBtblN0eWxlcyhtb2RlbGVyUmVmLmN1cnJlbnQsIHRoZW1lKVxuICAgICAgXG4gICAgICAvLyBBbHNvIHVwZGF0ZSBncmlkIGlmIGl0J3MgZW5hYmxlZFxuICAgICAgY29uc3QgY2FudmFzID0gbW9kZWxlclJlZi5jdXJyZW50LmdldCgnY2FudmFzJykgYXMgYW55XG4gICAgICBjb25zdCBjb250YWluZXIgPSBjYW52YXM/Ll9jb250YWluZXIgfHwgY2FudmFzPy5nZXRDb250YWluZXIoKVxuICAgICAgaWYgKGNvbnRhaW5lciAmJiBzaG93R3JpZCkge1xuICAgICAgICBjb250YWluZXIuY2xhc3NMaXN0LmFkZCgnc2hvdy1ncmlkJylcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gQUdHUkVTU0lWRTogQ29udGludW91cyBUYXNrIGZpeCBmb3Igc3R1YmJvcm4gZWxlbWVudHNcbiAgICAgIGNvbnN0IGZpeFRhc2tDb2xvcnMgPSAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGlzRGFyayA9IHRoZW1lID09PSAnZGFyaydcbiAgICAgICAgY29uc3QgdGFza3MgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS1lbGVtZW50LWlkKj1cIlRhc2tcIl0nKVxuICAgICAgICBcbiAgICAgICAgdGFza3MuZm9yRWFjaCh0YXNrID0+IHtcbiAgICAgICAgICBjb25zdCByZWN0cyA9IHRhc2sucXVlcnlTZWxlY3RvckFsbCgncmVjdCcpXG4gICAgICAgICAgcmVjdHMuZm9yRWFjaChyZWN0ID0+IHtcbiAgICAgICAgICAgIC8vIENoZWNrIGN1cnJlbnQgY29sb3JcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRTdHJva2UgPSByZWN0LmdldEF0dHJpYnV0ZSgnc3Ryb2tlJykgfHwgcmVjdC5zdHlsZS5zdHJva2VcbiAgICAgICAgICAgIGNvbnN0IG5lZWRzRml4ID0gaXNEYXJrID8gXG4gICAgICAgICAgICAgIChjdXJyZW50U3Ryb2tlID09PSAnIzAwMDAwMCcgfHwgY3VycmVudFN0cm9rZSA9PT0gJ2JsYWNrJyB8fCBjdXJyZW50U3Ryb2tlID09PSAncmdiKDAsIDAsIDApJykgOlxuICAgICAgICAgICAgICAoY3VycmVudFN0cm9rZSA9PT0gJyNmZmZmZmYnIHx8IGN1cnJlbnRTdHJva2UgPT09ICd3aGl0ZScgfHwgY3VycmVudFN0cm9rZSA9PT0gJ3JnYigyNTUsIDI1NSwgMjU1KScpXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmIChuZWVkc0ZpeCkge1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZygnRml4aW5nIFRhc2sgc3Ryb2tlOicsIGN1cnJlbnRTdHJva2UsICfihpInLCBpc0RhcmsgPyAnI2ZmZmZmZicgOiAnIzAwMDAwMCcpXG4gICAgICAgICAgICAgIHJlY3Quc2V0QXR0cmlidXRlKCdzdHJva2UnLCBpc0RhcmsgPyAnI2ZmZmZmZicgOiAnIzAwMDAwMCcpXG4gICAgICAgICAgICAgIHJlY3Quc3R5bGUuc3Ryb2tlID0gaXNEYXJrID8gJyNmZmZmZmYnIDogJyMwMDAwMDAnXG4gICAgICAgICAgICAgIHJlY3Quc3R5bGUuc3Ryb2tlT3BhY2l0eSA9ICcxJ1xuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgaWYgKCFyZWN0LmNsb3Nlc3QoJy5kanMtb3V0bGluZScpKSB7XG4gICAgICAgICAgICAgICAgcmVjdC5zZXRBdHRyaWJ1dGUoJ2ZpbGwnLCBpc0RhcmsgPyAnIzFmMjkzNycgOiAnI2ZmZmZmZicpXG4gICAgICAgICAgICAgICAgcmVjdC5zdHlsZS5maWxsID0gaXNEYXJrID8gJyMxZjI5MzcnIDogJyNmZmZmZmYnXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICB9KVxuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBSdW4gbXVsdGlwbGUgdGltZXMgdG8gY2F0Y2ggc3R1YmJvcm4gZWxlbWVudHNcbiAgICAgIGNvbnN0IGludGVydmFscyA9IFswLCAxMDAsIDIwMCwgNTAwLCAxMDAwLCAyMDAwXVxuICAgICAgaW50ZXJ2YWxzLmZvckVhY2goZGVsYXkgPT4ge1xuICAgICAgICBzZXRUaW1lb3V0KGZpeFRhc2tDb2xvcnMsIGRlbGF5KVxuICAgICAgfSlcbiAgICB9XG4gIH0sIFt0aGVtZSwgaXNSZWFkeSwgc2hvd0dyaWQsIGFwcGx5QnBtblN0eWxlc10pXG5cbiAgLy8gSGFuZGxlcnNcbiAgY29uc3QgaGFuZGxlU2F2ZSA9IHVzZUNhbGxiYWNrKGFzeW5jICgpID0+IHtcbiAgICBpZiAoIW1vZGVsZXJSZWYuY3VycmVudCkgcmV0dXJuXG4gICAgc2V0U2F2aW5nKHRydWUpXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHsgeG1sIH0gPSBhd2FpdCBtb2RlbGVyUmVmLmN1cnJlbnQuc2F2ZVhNTCh7IGZvcm1hdDogdHJ1ZSB9KVxuICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ2JwbW4tZGlhZ3JhbScsIHhtbCB8fCAnJylcbiAgICAgIGNvbnNvbGUubG9nKCdTYXZlZCB0byBsb2NhbFN0b3JhZ2UnKVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY29uc29sZS5lcnJvcignU2F2ZSBlcnJvcjonLCBlcnIpXG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHNldFNhdmluZyhmYWxzZSlcbiAgICB9XG4gIH0sIFtdKVxuXG4gIGNvbnN0IGhhbmRsZUV4cG9ydCA9IHVzZUNhbGxiYWNrKGFzeW5jICgpID0+IHtcbiAgICBpZiAoIW1vZGVsZXJSZWYuY3VycmVudCkgcmV0dXJuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHsgeG1sIH0gPSBhd2FpdCBtb2RlbGVyUmVmLmN1cnJlbnQuc2F2ZVhNTCh7IGZvcm1hdDogdHJ1ZSB9KVxuICAgICAgXG4gICAgICAvLyBTaG93IGV4cG9ydCBmb3JtYXQgb3B0aW9uc1xuICAgICAgY29uc3QgZm9ybWF0ID0gcHJvbXB0KCdFeHBvcnQgZm9ybWF0OiB4bWwsIGpzb24sIG9yIHlhbWw/JywgJ3htbCcpPy50b0xvd2VyQ2FzZSgpXG4gICAgICBcbiAgICAgIGxldCBjb250ZW50ID0geG1sIHx8ICcnXG4gICAgICBsZXQgZmlsZW5hbWUgPSAnZGlhZ3JhbS5icG1uJ1xuICAgICAgbGV0IG1pbWVUeXBlID0gJ3RleHQveG1sJ1xuICAgICAgXG4gICAgICBpZiAoZm9ybWF0ID09PSAnanNvbicpIHtcbiAgICAgICAgLy8gQ29udmVydCBYTUwgdG8gSlNPTiByZXByZXNlbnRhdGlvblxuICAgICAgICBjb25zdCBwYXJzZXIgPSBuZXcgRE9NUGFyc2VyKClcbiAgICAgICAgY29uc3QgeG1sRG9jID0gcGFyc2VyLnBhcnNlRnJvbVN0cmluZyh4bWwgfHwgJycsICd0ZXh0L3htbCcpXG4gICAgICAgIGNvbnN0IGpzb25EYXRhID0ge1xuICAgICAgICAgIHR5cGU6ICdicG1uOmRlZmluaXRpb25zJyxcbiAgICAgICAgICBwcm9jZXNzOiB4bWxEb2MucXVlcnlTZWxlY3RvcigncHJvY2VzcycpPy5nZXRBdHRyaWJ1dGUoJ2lkJykgfHwgJ1Byb2Nlc3NfMScsXG4gICAgICAgICAgZWxlbWVudHM6IEFycmF5LmZyb20oeG1sRG9jLnF1ZXJ5U2VsZWN0b3JBbGwoJypbaWRdJykpLm1hcChlbCA9PiAoe1xuICAgICAgICAgICAgaWQ6IGVsLmdldEF0dHJpYnV0ZSgnaWQnKSxcbiAgICAgICAgICAgIHR5cGU6IGVsLnRhZ05hbWUsXG4gICAgICAgICAgICBuYW1lOiBlbC5nZXRBdHRyaWJ1dGUoJ25hbWUnKSB8fCAnJ1xuICAgICAgICAgIH0pKVxuICAgICAgICB9XG4gICAgICAgIGNvbnRlbnQgPSBKU09OLnN0cmluZ2lmeShqc29uRGF0YSwgbnVsbCwgMilcbiAgICAgICAgZmlsZW5hbWUgPSAnZGlhZ3JhbS5qc29uJ1xuICAgICAgICBtaW1lVHlwZSA9ICdhcHBsaWNhdGlvbi9qc29uJ1xuICAgICAgfSBlbHNlIGlmIChmb3JtYXQgPT09ICd5YW1sJyB8fCBmb3JtYXQgPT09ICd5bWwnKSB7XG4gICAgICAgIC8vIFNpbXBsZSBZQU1MIGNvbnZlcnNpb24gKHdvdWxkIG5lZWQgcHJvcGVyIGxpYnJhcnkgZm9yIHByb2R1Y3Rpb24pXG4gICAgICAgIGNvbnN0IHBhcnNlciA9IG5ldyBET01QYXJzZXIoKVxuICAgICAgICBjb25zdCB4bWxEb2MgPSBwYXJzZXIucGFyc2VGcm9tU3RyaW5nKHhtbCB8fCAnJywgJ3RleHQveG1sJylcbiAgICAgICAgbGV0IHlhbWxDb250ZW50ID0gJ3R5cGU6IGJwbW46ZGVmaW5pdGlvbnNcXG4nXG4gICAgICAgIHlhbWxDb250ZW50ICs9IGBwcm9jZXNzOiAke3htbERvYy5xdWVyeVNlbGVjdG9yKCdwcm9jZXNzJyk/LmdldEF0dHJpYnV0ZSgnaWQnKSB8fCAnUHJvY2Vzc18xJ31cXG5gXG4gICAgICAgIHlhbWxDb250ZW50ICs9ICdlbGVtZW50czpcXG4nXG4gICAgICAgIHhtbERvYy5xdWVyeVNlbGVjdG9yQWxsKCcqW2lkXScpLmZvckVhY2goZWwgPT4ge1xuICAgICAgICAgIHlhbWxDb250ZW50ICs9IGAgIC0gaWQ6ICR7ZWwuZ2V0QXR0cmlidXRlKCdpZCcpfVxcbmBcbiAgICAgICAgICB5YW1sQ29udGVudCArPSBgICAgIHR5cGU6ICR7ZWwudGFnTmFtZX1cXG5gXG4gICAgICAgICAgY29uc3QgbmFtZSA9IGVsLmdldEF0dHJpYnV0ZSgnbmFtZScpXG4gICAgICAgICAgaWYgKG5hbWUpIHlhbWxDb250ZW50ICs9IGAgICAgbmFtZTogJHtuYW1lfVxcbmBcbiAgICAgICAgfSlcbiAgICAgICAgY29udGVudCA9IHlhbWxDb250ZW50XG4gICAgICAgIGZpbGVuYW1lID0gJ2RpYWdyYW0ueWFtbCdcbiAgICAgICAgbWltZVR5cGUgPSAndGV4dC95YW1sJ1xuICAgICAgfVxuICAgICAgXG4gICAgICBjb25zdCBibG9iID0gbmV3IEJsb2IoW2NvbnRlbnRdLCB7IHR5cGU6IG1pbWVUeXBlIH0pXG4gICAgICBjb25zdCB1cmwgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpXG4gICAgICBjb25zdCBhID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpXG4gICAgICBhLmhyZWYgPSB1cmxcbiAgICAgIGEuZG93bmxvYWQgPSBmaWxlbmFtZVxuICAgICAgYS5jbGljaygpXG4gICAgICBVUkwucmV2b2tlT2JqZWN0VVJMKHVybClcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0V4cG9ydCBlcnJvcjonLCBlcnIpXG4gICAgfVxuICB9LCBbXSlcblxuICBjb25zdCBoYW5kbGVJbXBvcnQgPSB1c2VDYWxsYmFjaygoZTogUmVhY3QuQ2hhbmdlRXZlbnQ8SFRNTElucHV0RWxlbWVudD4pID0+IHtcbiAgICBjb25zdCBmaWxlID0gZS50YXJnZXQuZmlsZXM/LlswXVxuICAgIGlmICghZmlsZSB8fCAhbW9kZWxlclJlZi5jdXJyZW50KSByZXR1cm5cbiAgICBcbiAgICBjb25zdCByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpXG4gICAgcmVhZGVyLm9ubG9hZCA9IGFzeW5jIChldmVudCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgY29udGVudCA9IGV2ZW50LnRhcmdldD8ucmVzdWx0IGFzIHN0cmluZ1xuICAgICAgICBsZXQgeG1sID0gY29udGVudFxuICAgICAgICBcbiAgICAgICAgLy8gQ2hlY2sgZmlsZSBleHRlbnNpb24gdG8gZGV0ZXJtaW5lIGZvcm1hdFxuICAgICAgICBjb25zdCBleHQgPSBmaWxlLm5hbWUuc3BsaXQoJy4nKS5wb3AoKT8udG9Mb3dlckNhc2UoKVxuICAgICAgICBcbiAgICAgICAgaWYgKGV4dCA9PT0gJ2pzb24nKSB7XG4gICAgICAgICAgLy8gQ29udmVydCBKU09OIGJhY2sgdG8gQlBNTiBYTUwgKHNpbXBsaWZpZWQpXG4gICAgICAgICAgY29uc3QganNvbkRhdGEgPSBKU09OLnBhcnNlKGNvbnRlbnQpXG4gICAgICAgICAgeG1sID0gREVGQVVMVF9CUE1OIC8vIFN0YXJ0IHdpdGggZGVmYXVsdCBhbmQgbW9kaWZ5XG4gICAgICAgICAgY29uc29sZS5sb2coJ0ltcG9ydGluZyBKU09OIGZvcm1hdDonLCBqc29uRGF0YSlcbiAgICAgICAgICAvLyBXb3VsZCBuZWVkIHByb3BlciBKU09OIHRvIEJQTU4gY29udmVyc2lvblxuICAgICAgICAgIGFsZXJ0KCdKU09OIGltcG9ydDogRWxlbWVudHMgZGV0ZWN0ZWQsIHVzaW5nIGRlZmF1bHQgdGVtcGxhdGUuIEZ1bGwgSlNPTiBpbXBvcnQgcmVxdWlyZXMgY3VzdG9tIHBhcnNlci4nKVxuICAgICAgICB9IGVsc2UgaWYgKGV4dCA9PT0gJ3lhbWwnIHx8IGV4dCA9PT0gJ3ltbCcpIHtcbiAgICAgICAgICAvLyBDb252ZXJ0IFlBTUwgYmFjayB0byBCUE1OIFhNTCAoc2ltcGxpZmllZClcbiAgICAgICAgICBjb25zb2xlLmxvZygnSW1wb3J0aW5nIFlBTUwgZm9ybWF0JylcbiAgICAgICAgICB4bWwgPSBERUZBVUxUX0JQTU4gLy8gU3RhcnQgd2l0aCBkZWZhdWx0XG4gICAgICAgICAgYWxlcnQoJ1lBTUwgaW1wb3J0OiBVc2luZyBkZWZhdWx0IHRlbXBsYXRlLiBGdWxsIFlBTUwgaW1wb3J0IHJlcXVpcmVzIHlhbWwgcGFyc2VyIGxpYnJhcnkuJylcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgYXdhaXQgbW9kZWxlclJlZi5jdXJyZW50Py5pbXBvcnRYTUwoeG1sKVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ltcG9ydCBlcnJvcjonLCBlcnIpXG4gICAgICAgIGFsZXJ0KCdJbXBvcnQgZmFpbGVkOiAnICsgKGVyciBpbnN0YW5jZW9mIEVycm9yID8gZXJyLm1lc3NhZ2UgOiAnVW5rbm93biBlcnJvcicpKVxuICAgICAgfVxuICAgIH1cbiAgICByZWFkZXIucmVhZEFzVGV4dChmaWxlKVxuICB9LCBbXSlcblxuICBjb25zdCBoYW5kbGVVbmRvID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIGNvbnN0IGNvbW1hbmRTdGFjayA9IG1vZGVsZXJSZWYuY3VycmVudD8uZ2V0KCdjb21tYW5kU3RhY2snKSBhcyBhbnlcbiAgICBpZiAoY29tbWFuZFN0YWNrPy5jYW5VbmRvKCkpIHtcbiAgICAgIGNvbW1hbmRTdGFjay51bmRvKClcbiAgICB9XG4gIH0sIFtdKVxuXG4gIGNvbnN0IGhhbmRsZVJlZG8gPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgY29uc3QgY29tbWFuZFN0YWNrID0gbW9kZWxlclJlZi5jdXJyZW50Py5nZXQoJ2NvbW1hbmRTdGFjaycpIGFzIGFueVxuICAgIGlmIChjb21tYW5kU3RhY2s/LmNhblJlZG8oKSkge1xuICAgICAgY29tbWFuZFN0YWNrLnJlZG8oKVxuICAgIH1cbiAgfSwgW10pXG5cbiAgY29uc3QgaGFuZGxlWm9vbUluID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIGlmICghbW9kZWxlclJlZi5jdXJyZW50KSByZXR1cm5cbiAgICB0cnkge1xuICAgICAgY29uc3QgY2FudmFzID0gbW9kZWxlclJlZi5jdXJyZW50LmdldCgnY2FudmFzJykgYXMgYW55XG4gICAgICBpZiAoIWNhbnZhcykgcmV0dXJuXG4gICAgICBcbiAgICAgIC8vIEVuc3VyZSBTVkcgY29udGV4dCBpcyBhdmFpbGFibGVcbiAgICAgIGNvbnN0IHN2ZyA9IGNhbnZhcy5fc3ZnIHx8IGNhbnZhcy5fY29udGFpbmVyPy5xdWVyeVNlbGVjdG9yKCdzdmcnKVxuICAgICAgaWYgKCFzdmcgfHwgIXN2Zy5jcmVhdGVTVkdNYXRyaXgpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdTVkcgbm90IHJlYWR5IGZvciB6b29tJylcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnN0IGN1cnJlbnRab29tID0gY2FudmFzLnpvb20oKVxuICAgICAgaWYgKHR5cGVvZiBjdXJyZW50Wm9vbSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgY29uc3QgbmV3Wm9vbSA9IE1hdGgubWluKGN1cnJlbnRab29tICogMS4yLCA0KVxuICAgICAgICBjYW52YXMuem9vbShuZXdab29tKVxuICAgICAgICBzZXRab29tTGV2ZWwoTWF0aC5yb3VuZChuZXdab29tICogMTAwKSlcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1pvb20gaW4gZXJyb3I6JywgZXJyKVxuICAgIH1cbiAgfSwgW10pXG5cbiAgY29uc3QgaGFuZGxlWm9vbU91dCA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBpZiAoIW1vZGVsZXJSZWYuY3VycmVudCkgcmV0dXJuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGNhbnZhcyA9IG1vZGVsZXJSZWYuY3VycmVudC5nZXQoJ2NhbnZhcycpIGFzIGFueVxuICAgICAgaWYgKCFjYW52YXMpIHJldHVyblxuICAgICAgXG4gICAgICAvLyBFbnN1cmUgU1ZHIGNvbnRleHQgaXMgYXZhaWxhYmxlXG4gICAgICBjb25zdCBzdmcgPSBjYW52YXMuX3N2ZyB8fCBjYW52YXMuX2NvbnRhaW5lcj8ucXVlcnlTZWxlY3Rvcignc3ZnJylcbiAgICAgIGlmICghc3ZnIHx8ICFzdmcuY3JlYXRlU1ZHTWF0cml4KSB7XG4gICAgICAgIGNvbnNvbGUud2FybignU1ZHIG5vdCByZWFkeSBmb3Igem9vbScpXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgXG4gICAgICBjb25zdCBjdXJyZW50Wm9vbSA9IGNhbnZhcy56b29tKClcbiAgICAgIGlmICh0eXBlb2YgY3VycmVudFpvb20gPT09ICdudW1iZXInKSB7XG4gICAgICAgIGNvbnN0IG5ld1pvb20gPSBNYXRoLm1heChjdXJyZW50Wm9vbSAvIDEuMiwgMC4yKVxuICAgICAgICBjYW52YXMuem9vbShuZXdab29tKVxuICAgICAgICBzZXRab29tTGV2ZWwoTWF0aC5yb3VuZChuZXdab29tICogMTAwKSlcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1pvb20gb3V0IGVycm9yOicsIGVycilcbiAgICB9XG4gIH0sIFtdKVxuXG4gIGNvbnN0IGhhbmRsZVpvb21SZXNldCA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBpZiAoIW1vZGVsZXJSZWYuY3VycmVudCkgcmV0dXJuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGNhbnZhcyA9IG1vZGVsZXJSZWYuY3VycmVudC5nZXQoJ2NhbnZhcycpIGFzIGFueVxuICAgICAgaWYgKCFjYW52YXMpIHJldHVyblxuICAgICAgXG4gICAgICAvLyBFbnN1cmUgU1ZHIGNvbnRleHQgaXMgYXZhaWxhYmxlXG4gICAgICBjb25zdCBzdmcgPSBjYW52YXMuX3N2ZyB8fCBjYW52YXMuX2NvbnRhaW5lcj8ucXVlcnlTZWxlY3Rvcignc3ZnJylcbiAgICAgIGlmICghc3ZnIHx8ICFzdmcuY3JlYXRlU1ZHTWF0cml4KSB7XG4gICAgICAgIGNvbnNvbGUud2FybignU1ZHIG5vdCByZWFkeSBmb3Igem9vbScpXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgXG4gICAgICBjYW52YXMuem9vbSgnZml0LXZpZXdwb3J0JylcbiAgICAgIHNldFpvb21MZXZlbCgxMDApXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdab29tIHJlc2V0IGVycm9yOicsIGVycilcbiAgICB9XG4gIH0sIFtdKVxuXG4gIGNvbnN0IGhhbmRsZUNsZWFyID0gdXNlQ2FsbGJhY2soYXN5bmMgKCkgPT4ge1xuICAgIGlmICghbW9kZWxlclJlZi5jdXJyZW50KSByZXR1cm5cbiAgICBpZiAoY29uZmlybSgnQ2xlYXIgdGhlIGVudGlyZSBkaWFncmFtPycpKSB7XG4gICAgICBhd2FpdCBtb2RlbGVyUmVmLmN1cnJlbnQuaW1wb3J0WE1MKERFRkFVTFRfQlBNTilcbiAgICB9XG4gIH0sIFtdKVxuXG4gIGNvbnN0IGhhbmRsZVRoZW1lVG9nZ2xlID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIGNvbnN0IG5ld1RoZW1lID0gdGhlbWUgPT09ICdsaWdodCcgPyAnZGFyaycgOiAnbGlnaHQnXG4gICAgY29uc29sZS5sb2coJ1RoZW1lIHRvZ2dsZTonLCB0aGVtZSwgJy0+JywgbmV3VGhlbWUpXG4gICAgc2V0VGhlbWUobmV3VGhlbWUpICAvLyBUaGVtZVByb3ZpZGVyIGhhbmRsZXMgRE9NIG1hbmlwdWxhdGlvblxuICAgIFxuICAgIC8vIFJlLWFwcGx5IEJQTU4gc3R5bGVzIHdpdGggbmV3IHRoZW1lXG4gICAgaWYgKG1vZGVsZXJSZWYuY3VycmVudCkge1xuICAgICAgLy8gQXBwbHkgbmV3IHN0eWxlcyAodGhpcyB3aWxsIHVwZGF0ZSB0aGUgZXhpc3Rpbmcgc3R5bGUgZWxlbWVudClcbiAgICAgIGFwcGx5QnBtblN0eWxlcyhtb2RlbGVyUmVmLmN1cnJlbnQsIG5ld1RoZW1lKVxuICAgICAgXG4gICAgICAvLyBJTU1FRElBVEU6IEZvcmNlIGRpcmVjdCBTVkcgbWFuaXB1bGF0aW9uIGZvciBpbnN0YW50IGNvbG9yIGNoYW5nZVxuICAgICAgY29uc3QgZm9yY2VDb2xvclVwZGF0ZSA9ICgpID0+IHtcbiAgICAgICAgY29uc3QgaXNEYXJrTW9kZSA9IG5ld1RoZW1lID09PSAnZGFyaydcbiAgICAgICAgY29uc3Qgc3ZnRWxlbWVudHMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcuZGpzLWNvbnRhaW5lciBzdmcgKicpXG4gICAgICAgIFxuICAgICAgICBzdmdFbGVtZW50cy5mb3JFYWNoKChlbDogYW55KSA9PiB7XG4gICAgICAgICAgLy8gVXBkYXRlIHN0cm9rZSBhdHRyaWJ1dGVzXG4gICAgICAgICAgaWYgKGVsLmhhc0F0dHJpYnV0ZSgnc3Ryb2tlJykpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0cm9rZSA9IGVsLmdldEF0dHJpYnV0ZSgnc3Ryb2tlJylcbiAgICAgICAgICAgIGlmIChzdHJva2UgJiYgc3Ryb2tlICE9PSAnbm9uZScgJiYgc3Ryb2tlICE9PSAndHJhbnNwYXJlbnQnKSB7XG4gICAgICAgICAgICAgIC8vIEZvcmNlIHdoaXRlIGluIGRhcmsgbW9kZSwgYmxhY2sgaW4gbGlnaHQgbW9kZVxuICAgICAgICAgICAgICBlbC5zdHlsZS5zdHJva2UgPSBpc0RhcmtNb2RlID8gJyNmZmZmZmYnIDogJyMwMDAwMDAnXG4gICAgICAgICAgICAgIGVsLnNldEF0dHJpYnV0ZSgnc3Ryb2tlJywgaXNEYXJrTW9kZSA/ICcjZmZmZmZmJyA6ICcjMDAwMDAwJylcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gVXBkYXRlIGZpbGwgYXR0cmlidXRlc1xuICAgICAgICAgIGlmIChlbC5oYXNBdHRyaWJ1dGUoJ2ZpbGwnKSkge1xuICAgICAgICAgICAgY29uc3QgZmlsbCA9IGVsLmdldEF0dHJpYnV0ZSgnZmlsbCcpXG4gICAgICAgICAgICBpZiAoZmlsbCAmJiBmaWxsICE9PSAnbm9uZScgJiYgZmlsbCAhPT0gJ3RyYW5zcGFyZW50Jykge1xuICAgICAgICAgICAgICAvLyBTaGFwZXMgZ2V0IGJhY2tncm91bmQgY29sb3JcbiAgICAgICAgICAgICAgaWYgKGVsLnRhZ05hbWUgPT09ICdyZWN0JyB8fCBlbC50YWdOYW1lID09PSAnY2lyY2xlJyB8fCBcbiAgICAgICAgICAgICAgICAgIGVsLnRhZ05hbWUgPT09ICdlbGxpcHNlJyB8fCBlbC50YWdOYW1lID09PSAncG9seWdvbicpIHtcbiAgICAgICAgICAgICAgICBlbC5zdHlsZS5maWxsID0gaXNEYXJrTW9kZSA/ICcjMWYyOTM3JyA6ICcjZmZmZmZmJ1xuICAgICAgICAgICAgICAgIGVsLnNldEF0dHJpYnV0ZSgnZmlsbCcsIGlzRGFya01vZGUgPyAnIzFmMjkzNycgOiAnI2ZmZmZmZicpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy8gVGV4dCBhbmQgaWNvbnMgZ2V0IGZvcmVncm91bmQgY29sb3JcbiAgICAgICAgICAgICAgZWxzZSBpZiAoZWwudGFnTmFtZSA9PT0gJ3RleHQnIHx8IGVsLnRhZ05hbWUgPT09ICd0c3BhbicgfHwgZWwudGFnTmFtZSA9PT0gJ3BhdGgnKSB7XG4gICAgICAgICAgICAgICAgZWwuc3R5bGUuZmlsbCA9IGlzRGFya01vZGUgPyAnI2ZmZmZmZicgOiAnIzAwMDAwMCdcbiAgICAgICAgICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoJ2ZpbGwnLCBpc0RhcmtNb2RlID8gJyNmZmZmZmYnIDogJyMwMDAwMDAnKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIC8vIEFsc28gc2V0IHN0eWxlIGF0dHJpYnV0ZSB0byBvdmVycmlkZSBhbnkgaW5saW5lIHN0eWxlc1xuICAgICAgICAgIGlmIChlbC50YWdOYW1lID09PSAncmVjdCcgfHwgZWwudGFnTmFtZSA9PT0gJ2NpcmNsZScgfHwgXG4gICAgICAgICAgICAgIGVsLnRhZ05hbWUgPT09ICdlbGxpcHNlJyB8fCBlbC50YWdOYW1lID09PSAncG9seWdvbicgfHxcbiAgICAgICAgICAgICAgZWwudGFnTmFtZSA9PT0gJ3BhdGgnIHx8IGVsLnRhZ05hbWUgPT09ICdsaW5lJyB8fCBlbC50YWdOYW1lID09PSAncG9seWxpbmUnKSB7XG4gICAgICAgICAgICBpZiAoIWVsLmdldEF0dHJpYnV0ZSgnc3Ryb2tlLW9wYWNpdHknKSB8fCBlbC5nZXRBdHRyaWJ1dGUoJ3N0cm9rZS1vcGFjaXR5JykgIT09ICcwJykge1xuICAgICAgICAgICAgICBlbC5zdHlsZS5zdHJva2UgPSBpc0RhcmtNb2RlID8gJyNmZmZmZmYnIDogJyMwMDAwMDAnXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBFeGVjdXRlIGltbWVkaWF0ZWx5IGFuZCBhZnRlciBhIHNob3J0IGRlbGF5XG4gICAgICBmb3JjZUNvbG9yVXBkYXRlKClcbiAgICAgIHNldFRpbWVvdXQoZm9yY2VDb2xvclVwZGF0ZSwgMTAwKVxuICAgICAgc2V0VGltZW91dChmb3JjZUNvbG9yVXBkYXRlLCAzMDApXG4gICAgICBcbiAgICAgIC8vIEZvcmNlIGEgY29tcGxldGUgcmVkcmF3IHVzaW5nIGEgc2FmZXIgbWV0aG9kXG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBjYW52YXMgPSBtb2RlbGVyUmVmLmN1cnJlbnQuZ2V0KCdjYW52YXMnKSBhcyBhbnlcbiAgICAgICAgY29uc3QgZXZlbnRCdXMgPSBtb2RlbGVyUmVmLmN1cnJlbnQuZ2V0KCdldmVudEJ1cycpIGFzIGFueVxuICAgICAgICBcbiAgICAgICAgaWYgKGNhbnZhcyAmJiBldmVudEJ1cykge1xuICAgICAgICAgIC8vIEdldCB0aGUgY3VycmVudCB2aWV3Ym94IHRvIHByZXNlcnZlIHBvc2l0aW9uXG4gICAgICAgICAgY29uc3Qgdmlld2JveCA9IGNhbnZhcy52aWV3Ym94KClcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBEaXJlY3RseSB1cGRhdGUgY2FudmFzIGNvbnRhaW5lciBiYWNrZ3JvdW5kXG4gICAgICAgICAgY29uc3QgY29udGFpbmVyID0gY2FudmFzLl9jb250YWluZXIgfHwgY2FudmFzLmdldENvbnRhaW5lcigpXG4gICAgICAgICAgaWYgKGNvbnRhaW5lcikge1xuICAgICAgICAgICAgY29uc3QgYmdDb2xvciA9IG5ld1RoZW1lID09PSAnZGFyaycgPyAnIzExMTgyNycgOiAnI2Y5ZmFmYidcbiAgICAgICAgICAgIGNvbnRhaW5lci5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBiZ0NvbG9yXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIFVwZGF0ZSBTVkcgYmFja2dyb3VuZFxuICAgICAgICAgICAgY29uc3Qgc3ZnID0gY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoJ3N2ZycpXG4gICAgICAgICAgICBpZiAoc3ZnKSB7XG4gICAgICAgICAgICAgIHN2Zy5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBiZ0NvbG9yXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIFVwZGF0ZSBhbnkgdmlld3BvcnQgZWxlbWVudHNcbiAgICAgICAgICAgIGNvbnN0IHZpZXdwb3J0ID0gY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoJy5kanMtdmlld3BvcnQnKVxuICAgICAgICAgICAgaWYgKHZpZXdwb3J0KSB7XG4gICAgICAgICAgICAgIHZpZXdwb3J0LnN0eWxlLmJhY2tncm91bmRDb2xvciA9IGJnQ29sb3JcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gUHJlc2VydmUgZ3JpZCBzdGF0ZSBhZnRlciB0aGVtZSBjaGFuZ2VcbiAgICAgICAgICAgIGlmIChzaG93R3JpZCkge1xuICAgICAgICAgICAgICBjb250YWluZXIuY2xhc3NMaXN0LmFkZCgnc2hvdy1ncmlkJylcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gU2ltcGx5IHRyaWdnZXIgYSBjYW52YXMgcmVmcmVzaCB3aXRob3V0IG1hbmlwdWxhdGluZyBlbGVtZW50c1xuICAgICAgICAgIC8vIFRoZSBzdHlsZXMgd2lsbCBiZSByZS1hcHBsaWVkIHRocm91Z2ggdGhlIHN0eWxlIGVsZW1lbnQgdXBkYXRlXG4gICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICAgIGlmIChldmVudEJ1cykge1xuICAgICAgICAgICAgICAvLyBKdXN0IGZpcmUgYSB2aWV3Ym94IGNoYW5nZSB0byByZWZyZXNoIHRoZSByZW5kZXJpbmdcbiAgICAgICAgICAgICAgZXZlbnRCdXMuZmlyZSgnY2FudmFzLnZpZXdib3guY2hhbmdlZCcsIHZpZXdib3gpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ1RoZW1lIHRvZ2dsZSByZWRyYXcgZXJyb3I6JywgZXJyKVxuICAgICAgfVxuICAgIH1cbiAgfSwgW3RoZW1lLCBhcHBseUJwbW5TdHlsZXNdKVxuXG4gIC8vIEFsaWdubWVudCBoYW5kbGVyc1xuICBjb25zdCBoYW5kbGVBbGlnbkxlZnQgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgaWYgKCFtb2RlbGVyUmVmLmN1cnJlbnQgfHwgc2VsZWN0ZWRFbGVtZW50cy5sZW5ndGggPCAyKSByZXR1cm5cbiAgICBjb25zdCBtb2RlbGluZyA9IG1vZGVsZXJSZWYuY3VycmVudC5nZXQoJ21vZGVsaW5nJykgYXMgYW55XG4gICAgY29uc3QgY2FudmFzID0gbW9kZWxlclJlZi5jdXJyZW50LmdldCgnY2FudmFzJykgYXMgYW55XG4gICAgXG4gICAgLy8gRmluZCBsZWZ0bW9zdCBlbGVtZW50XG4gICAgY29uc3QgbGVmdE1vc3QgPSBzZWxlY3RlZEVsZW1lbnRzLnJlZHVjZSgobWluLCBlbCkgPT4gXG4gICAgICBlbC54IDwgbWluLnggPyBlbCA6IG1pbiwgc2VsZWN0ZWRFbGVtZW50c1swXSlcbiAgICBcbiAgICAvLyBBbGlnbiBhbGwgZWxlbWVudHMgdG8gbGVmdG1vc3RcbiAgICBzZWxlY3RlZEVsZW1lbnRzLmZvckVhY2goZWwgPT4ge1xuICAgICAgaWYgKGVsLmlkICE9PSBsZWZ0TW9zdC5pZCkge1xuICAgICAgICBtb2RlbGluZy5tb3ZlRWxlbWVudHMoW2VsXSwgeyB4OiBsZWZ0TW9zdC54IC0gZWwueCwgeTogMCB9KVxuICAgICAgfVxuICAgIH0pXG4gIH0sIFtzZWxlY3RlZEVsZW1lbnRzXSlcblxuICBjb25zdCBoYW5kbGVBbGlnbkNlbnRlciA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBpZiAoIW1vZGVsZXJSZWYuY3VycmVudCB8fCBzZWxlY3RlZEVsZW1lbnRzLmxlbmd0aCA8IDIpIHJldHVyblxuICAgIGNvbnN0IG1vZGVsaW5nID0gbW9kZWxlclJlZi5jdXJyZW50LmdldCgnbW9kZWxpbmcnKSBhcyBhbnlcbiAgICBcbiAgICAvLyBDYWxjdWxhdGUgY2VudGVyIHBvc2l0aW9uXG4gICAgY29uc3QgY2VudGVyWCA9IHNlbGVjdGVkRWxlbWVudHMucmVkdWNlKChzdW0sIGVsKSA9PiBzdW0gKyBlbC54ICsgZWwud2lkdGgvMiwgMCkgLyBzZWxlY3RlZEVsZW1lbnRzLmxlbmd0aFxuICAgIFxuICAgIC8vIEFsaWduIGFsbCBlbGVtZW50cyB0byBjZW50ZXJcbiAgICBzZWxlY3RlZEVsZW1lbnRzLmZvckVhY2goZWwgPT4ge1xuICAgICAgY29uc3QgdGFyZ2V0WCA9IGNlbnRlclggLSBlbC53aWR0aC8yXG4gICAgICBtb2RlbGluZy5tb3ZlRWxlbWVudHMoW2VsXSwgeyB4OiB0YXJnZXRYIC0gZWwueCwgeTogMCB9KVxuICAgIH0pXG4gIH0sIFtzZWxlY3RlZEVsZW1lbnRzXSlcblxuICBjb25zdCBoYW5kbGVBbGlnblJpZ2h0ID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIGlmICghbW9kZWxlclJlZi5jdXJyZW50IHx8IHNlbGVjdGVkRWxlbWVudHMubGVuZ3RoIDwgMikgcmV0dXJuXG4gICAgY29uc3QgbW9kZWxpbmcgPSBtb2RlbGVyUmVmLmN1cnJlbnQuZ2V0KCdtb2RlbGluZycpIGFzIGFueVxuICAgIFxuICAgIC8vIEZpbmQgcmlnaHRtb3N0IGVsZW1lbnRcbiAgICBjb25zdCByaWdodE1vc3QgPSBzZWxlY3RlZEVsZW1lbnRzLnJlZHVjZSgobWF4LCBlbCkgPT4gXG4gICAgICAoZWwueCArIGVsLndpZHRoKSA+IChtYXgueCArIG1heC53aWR0aCkgPyBlbCA6IG1heCwgc2VsZWN0ZWRFbGVtZW50c1swXSlcbiAgICBcbiAgICBjb25zdCByaWdodEVkZ2UgPSByaWdodE1vc3QueCArIHJpZ2h0TW9zdC53aWR0aFxuICAgIFxuICAgIC8vIEFsaWduIGFsbCBlbGVtZW50cyB0byByaWdodG1vc3RcbiAgICBzZWxlY3RlZEVsZW1lbnRzLmZvckVhY2goZWwgPT4ge1xuICAgICAgaWYgKGVsLmlkICE9PSByaWdodE1vc3QuaWQpIHtcbiAgICAgICAgY29uc3QgdGFyZ2V0WCA9IHJpZ2h0RWRnZSAtIGVsLndpZHRoXG4gICAgICAgIG1vZGVsaW5nLm1vdmVFbGVtZW50cyhbZWxdLCB7IHg6IHRhcmdldFggLSBlbC54LCB5OiAwIH0pXG4gICAgICB9XG4gICAgfSlcbiAgfSwgW3NlbGVjdGVkRWxlbWVudHNdKVxuXG4gIGNvbnN0IGhhbmRsZUFsaWduVG9wID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIGlmICghbW9kZWxlclJlZi5jdXJyZW50IHx8IHNlbGVjdGVkRWxlbWVudHMubGVuZ3RoIDwgMikgcmV0dXJuXG4gICAgY29uc3QgbW9kZWxpbmcgPSBtb2RlbGVyUmVmLmN1cnJlbnQuZ2V0KCdtb2RlbGluZycpIGFzIGFueVxuICAgIFxuICAgIC8vIEZpbmQgdG9wbW9zdCBlbGVtZW50XG4gICAgY29uc3QgdG9wTW9zdCA9IHNlbGVjdGVkRWxlbWVudHMucmVkdWNlKChtaW4sIGVsKSA9PiBcbiAgICAgIGVsLnkgPCBtaW4ueSA/IGVsIDogbWluLCBzZWxlY3RlZEVsZW1lbnRzWzBdKVxuICAgIFxuICAgIC8vIEFsaWduIGFsbCBlbGVtZW50cyB0byB0b3Btb3N0XG4gICAgc2VsZWN0ZWRFbGVtZW50cy5mb3JFYWNoKGVsID0+IHtcbiAgICAgIGlmIChlbC5pZCAhPT0gdG9wTW9zdC5pZCkge1xuICAgICAgICBtb2RlbGluZy5tb3ZlRWxlbWVudHMoW2VsXSwgeyB4OiAwLCB5OiB0b3BNb3N0LnkgLSBlbC55IH0pXG4gICAgICB9XG4gICAgfSlcbiAgfSwgW3NlbGVjdGVkRWxlbWVudHNdKVxuXG4gIGNvbnN0IGhhbmRsZUFsaWduTWlkZGxlID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIGlmICghbW9kZWxlclJlZi5jdXJyZW50IHx8IHNlbGVjdGVkRWxlbWVudHMubGVuZ3RoIDwgMikgcmV0dXJuXG4gICAgY29uc3QgbW9kZWxpbmcgPSBtb2RlbGVyUmVmLmN1cnJlbnQuZ2V0KCdtb2RlbGluZycpIGFzIGFueVxuICAgIFxuICAgIC8vIENhbGN1bGF0ZSBtaWRkbGUgcG9zaXRpb25cbiAgICBjb25zdCBtaWRkbGVZID0gc2VsZWN0ZWRFbGVtZW50cy5yZWR1Y2UoKHN1bSwgZWwpID0+IHN1bSArIGVsLnkgKyBlbC5oZWlnaHQvMiwgMCkgLyBzZWxlY3RlZEVsZW1lbnRzLmxlbmd0aFxuICAgIFxuICAgIC8vIEFsaWduIGFsbCBlbGVtZW50cyB0byBtaWRkbGVcbiAgICBzZWxlY3RlZEVsZW1lbnRzLmZvckVhY2goZWwgPT4ge1xuICAgICAgY29uc3QgdGFyZ2V0WSA9IG1pZGRsZVkgLSBlbC5oZWlnaHQvMlxuICAgICAgbW9kZWxpbmcubW92ZUVsZW1lbnRzKFtlbF0sIHsgeDogMCwgeTogdGFyZ2V0WSAtIGVsLnkgfSlcbiAgICB9KVxuICB9LCBbc2VsZWN0ZWRFbGVtZW50c10pXG5cbiAgY29uc3QgaGFuZGxlQWxpZ25Cb3R0b20gPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgaWYgKCFtb2RlbGVyUmVmLmN1cnJlbnQgfHwgc2VsZWN0ZWRFbGVtZW50cy5sZW5ndGggPCAyKSByZXR1cm5cbiAgICBjb25zdCBtb2RlbGluZyA9IG1vZGVsZXJSZWYuY3VycmVudC5nZXQoJ21vZGVsaW5nJykgYXMgYW55XG4gICAgXG4gICAgLy8gRmluZCBib3R0b21tb3N0IGVsZW1lbnRcbiAgICBjb25zdCBib3R0b21Nb3N0ID0gc2VsZWN0ZWRFbGVtZW50cy5yZWR1Y2UoKG1heCwgZWwpID0+IFxuICAgICAgKGVsLnkgKyBlbC5oZWlnaHQpID4gKG1heC55ICsgbWF4LmhlaWdodCkgPyBlbCA6IG1heCwgc2VsZWN0ZWRFbGVtZW50c1swXSlcbiAgICBcbiAgICBjb25zdCBib3R0b21FZGdlID0gYm90dG9tTW9zdC55ICsgYm90dG9tTW9zdC5oZWlnaHRcbiAgICBcbiAgICAvLyBBbGlnbiBhbGwgZWxlbWVudHMgdG8gYm90dG9tbW9zdFxuICAgIHNlbGVjdGVkRWxlbWVudHMuZm9yRWFjaChlbCA9PiB7XG4gICAgICBpZiAoZWwuaWQgIT09IGJvdHRvbU1vc3QuaWQpIHtcbiAgICAgICAgY29uc3QgdGFyZ2V0WSA9IGJvdHRvbUVkZ2UgLSBlbC5oZWlnaHRcbiAgICAgICAgbW9kZWxpbmcubW92ZUVsZW1lbnRzKFtlbF0sIHsgeDogMCwgeTogdGFyZ2V0WSAtIGVsLnkgfSlcbiAgICAgIH1cbiAgICB9KVxuICB9LCBbc2VsZWN0ZWRFbGVtZW50c10pXG5cbiAgLy8gUHJldmlldyBoYW5kbGVyIC0gb3BlbnMgWE1MIHZpZXdlciBtb2RhbFxuICBjb25zdCBoYW5kbGVQcmV2aWV3ID0gdXNlQ2FsbGJhY2soYXN5bmMgKCkgPT4ge1xuICAgIGlmICghbW9kZWxlclJlZi5jdXJyZW50KSByZXR1cm5cbiAgICB0cnkge1xuICAgICAgY29uc3QgeyB4bWwgfSA9IGF3YWl0IG1vZGVsZXJSZWYuY3VycmVudC5zYXZlWE1MKHsgZm9ybWF0OiB0cnVlIH0pXG4gICAgICBzZXRDdXJyZW50WG1sKHhtbCB8fCAnJylcbiAgICAgIHNldFNob3dYbWxWaWV3ZXIodHJ1ZSlcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1ByZXZpZXcgZXJyb3I6JywgZXJyKVxuICAgIH1cbiAgfSwgW10pXG5cbiAgLy8gSGFuZGxlIFhNTCBzYXZlIGZyb20gdmlld2VyXG4gIGNvbnN0IGhhbmRsZVhtbFNhdmUgPSB1c2VDYWxsYmFjayhhc3luYyAobmV3WG1sOiBzdHJpbmcpID0+IHtcbiAgICBpZiAoIW1vZGVsZXJSZWYuY3VycmVudCkgcmV0dXJuXG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IG1vZGVsZXJSZWYuY3VycmVudC5pbXBvcnRYTUwobmV3WG1sKVxuICAgICAgc2V0U2hvd1htbFZpZXdlcihmYWxzZSlcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1hNTCBpbXBvcnQgZXJyb3I6JywgZXJyKVxuICAgICAgYWxlcnQoJ0ZhaWxlZCB0byBhcHBseSBYTUwgY2hhbmdlczogJyArIChlcnIgaW5zdGFuY2VvZiBFcnJvciA/IGVyci5tZXNzYWdlIDogJ1Vua25vd24gZXJyb3InKSlcbiAgICB9XG4gIH0sIFtdKVxuXG4gIC8vIFJ1biBQcm9jZXNzIGhhbmRsZXIgKHNpbXVsYXRpb24pXG4gIGNvbnN0IGhhbmRsZVJ1blByb2Nlc3MgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgaWYgKCFtb2RlbGVyUmVmLmN1cnJlbnQpIHJldHVyblxuICAgIGNvbnNvbGUubG9nKCdTdGFydGluZyBwcm9jZXNzIHNpbXVsYXRpb24uLi4nKVxuICAgIC8vIFRoaXMgd291bGQgaW50ZWdyYXRlIHdpdGggYSBCUE1OIGVuZ2luZSBmb3IgZXhlY3V0aW9uXG4gICAgYWxlcnQoJ1Byb2Nlc3Mgc2ltdWxhdGlvbiB3b3VsZCBzdGFydCBoZXJlLiBUaGlzIHJlcXVpcmVzIGludGVncmF0aW9uIHdpdGggYSBCUE1OIGVuZ2luZS4nKVxuICB9LCBbXSlcblxuICAvLyBNZWV0aW5nL1ByZXNlbnRhdGlvbiBNb2RlIGhhbmRsZXJcbiAgY29uc3QgaGFuZGxlTWVldGluZ01vZGUgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgc2V0SXNNZWV0aW5nTW9kZSghaXNNZWV0aW5nTW9kZSlcbiAgICBpZiAoIWlzTWVldGluZ01vZGUpIHtcbiAgICAgIC8vIEVudGVyIHByZXNlbnRhdGlvbiBtb2RlIC0gaGlkZSBwYWxldHRlLCBtYXhpbWl6ZSBjYW52YXNcbiAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5yZXF1ZXN0RnVsbHNjcmVlbigpXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEV4aXQgcHJlc2VudGF0aW9uIG1vZGVcbiAgICAgIGlmIChkb2N1bWVudC5mdWxsc2NyZWVuRWxlbWVudCkge1xuICAgICAgICBkb2N1bWVudC5leGl0RnVsbHNjcmVlbigpXG4gICAgICB9XG4gICAgfVxuICB9LCBbaXNNZWV0aW5nTW9kZV0pXG5cbiAgLy8gTWluaW1hcCB0b2dnbGUgaGFuZGxlclxuICBjb25zdCBoYW5kbGVUb2dnbGVNaW5pbWFwID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIHNldElzTWluaW1hcE9wZW4oIWlzTWluaW1hcE9wZW4pXG4gICAgLy8gQlBNTi5qcyBkb2Vzbid0IGhhdmUgYnVpbHQtaW4gbWluaW1hcCwgd291bGQgbmVlZCBjdXN0b20gaW1wbGVtZW50YXRpb25cbiAgICBjb25zb2xlLmxvZygnTWluaW1hcCB0b2dnbGU6JywgIWlzTWluaW1hcE9wZW4pXG4gIH0sIFtpc01pbmltYXBPcGVuXSlcblxuICAvLyBMYW5ndWFnZSB0b2dnbGUgaGFuZGxlclxuICBjb25zdCBoYW5kbGVUb2dnbGVMYW5ndWFnZSA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICAvLyBXb3VsZCBpbXBsZW1lbnQgaTE4biBoZXJlXG4gICAgY29uc29sZS5sb2coJ0xhbmd1YWdlIHRvZ2dsZSAtIHdvdWxkIGltcGxlbWVudCBpMThuJylcbiAgICBhbGVydCgnTGFuZ3VhZ2Ugc3dpdGNoaW5nIHdvdWxkIGJlIGltcGxlbWVudGVkIHdpdGggaTE4biBsaWJyYXJ5JylcbiAgfSwgW10pXG5cbiAgLy8gR3JpZCB0b2dnbGUgaGFuZGxlclxuICBjb25zdCBoYW5kbGVUb2dnbGVHcmlkID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIHNldFNob3dHcmlkKHByZXYgPT4ge1xuICAgICAgY29uc3QgbmV3VmFsdWUgPSAhcHJldlxuICAgICAgLy8gQXBwbHkgb3IgcmVtb3ZlIGdyaWQgY2xhc3MgdG8gY2FudmFzIGNvbnRhaW5lclxuICAgICAgaWYgKG1vZGVsZXJSZWYuY3VycmVudCkge1xuICAgICAgICBjb25zdCBjYW52YXMgPSBtb2RlbGVyUmVmLmN1cnJlbnQuZ2V0KCdjYW52YXMnKSBhcyBhbnlcbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gY2FudmFzLl9jb250YWluZXIgfHwgY2FudmFzLmdldENvbnRhaW5lcigpXG4gICAgICAgIGlmIChjb250YWluZXIpIHtcbiAgICAgICAgICBpZiAobmV3VmFsdWUpIHtcbiAgICAgICAgICAgIGNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKCdzaG93LWdyaWQnKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb250YWluZXIuY2xhc3NMaXN0LnJlbW92ZSgnc2hvdy1ncmlkJylcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXdWYWx1ZVxuICAgIH0pXG4gIH0sIFtdKVxuXG4gIC8vIEhhbmRsZSBwYWxldHRlIGFjdGlvbnNcbiAgY29uc3QgaGFuZGxlUGFsZXR0ZUFjdGlvbiA9IHVzZUNhbGxiYWNrKChhY3Rpb246IHN0cmluZywgZXZlbnQ6IEV2ZW50IHwgRHJhZ0V2ZW50KSA9PiB7XG4gICAgaWYgKCFtb2RlbGVyUmVmLmN1cnJlbnQpIHJldHVyblxuICAgIFxuICAgIGNvbnNvbGUubG9nKCdQYWxldHRlIGFjdGlvbjonLCBhY3Rpb24pXG4gICAgXG4gICAgLy8gSGFuZGxlIHRvb2wgYWN0aW9uc1xuICAgIGlmIChhY3Rpb24uZW5kc1dpdGgoJy10b29sJykpIHtcbiAgICAgIHNldEFjdGl2ZVRvb2woYWN0aW9uLnJlcGxhY2UoJy10b29sJywgJycpKVxuICAgICAgXG4gICAgICAvLyBBY3RpdmF0ZSB0aGUgdG9vbCBpbiBCUE1OLmpzXG4gICAgICBjb25zdCBoYW5kVG9vbCA9IG1vZGVsZXJSZWYuY3VycmVudC5nZXQoJ2hhbmRUb29sJykgYXMgYW55XG4gICAgICBjb25zdCBsYXNzb1Rvb2wgPSBtb2RlbGVyUmVmLmN1cnJlbnQuZ2V0KCdsYXNzb1Rvb2wnKSBhcyBhbnlcbiAgICAgIGNvbnN0IHNwYWNlVG9vbCA9IG1vZGVsZXJSZWYuY3VycmVudC5nZXQoJ3NwYWNlVG9vbCcpIGFzIGFueVxuICAgICAgY29uc3QgZ2xvYmFsQ29ubmVjdCA9IG1vZGVsZXJSZWYuY3VycmVudC5nZXQoJ2dsb2JhbENvbm5lY3QnKSBhcyBhbnlcbiAgICAgIFxuICAgICAgc3dpdGNoIChhY3Rpb24pIHtcbiAgICAgICAgY2FzZSAnaGFuZC10b29sJzpcbiAgICAgICAgICBoYW5kVG9vbD8uYWN0aXZhdGVIYW5kKGV2ZW50KVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgJ2xhc3NvLXRvb2wnOlxuICAgICAgICAgIGxhc3NvVG9vbD8uYWN0aXZhdGVTZWxlY3Rpb24oZXZlbnQpXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAnc3BhY2UtdG9vbCc6XG4gICAgICAgICAgc3BhY2VUb29sPy5hY3RpdmF0ZVNlbGVjdGlvbihldmVudClcbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlICdnbG9iYWwtY29ubmVjdC10b29sJzpcbiAgICAgICAgICBnbG9iYWxDb25uZWN0Py50b2dnbGUoZXZlbnQpXG4gICAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBcbiAgICAvLyBIYW5kbGUgZWxlbWVudCBjcmVhdGlvblxuICAgIGlmIChhY3Rpb24uc3RhcnRzV2l0aCgnY3JlYXRlLicpKSB7XG4gICAgICBjb25zdCBlbGVtZW50RmFjdG9yeSA9IG1vZGVsZXJSZWYuY3VycmVudC5nZXQoJ2VsZW1lbnRGYWN0b3J5JykgYXMgYW55XG4gICAgICBjb25zdCBjcmVhdGUgPSBtb2RlbGVyUmVmLmN1cnJlbnQuZ2V0KCdjcmVhdGUnKSBhcyBhbnlcbiAgICAgIGNvbnN0IGNhbnZhcyA9IG1vZGVsZXJSZWYuY3VycmVudC5nZXQoJ2NhbnZhcycpIGFzIGFueVxuICAgICAgY29uc3QgbW9kZWxpbmcgPSBtb2RlbGVyUmVmLmN1cnJlbnQuZ2V0KCdtb2RlbGluZycpIGFzIGFueVxuICAgICAgXG4gICAgICAvLyBQYXJzZSB0aGUgZWxlbWVudCB0eXBlIGZyb20gYWN0aW9uIChrZWVwIG9yaWdpbmFsIGZvcm1hdClcbiAgICAgIGNvbnN0IGVsZW1lbnRUeXBlID0gYWN0aW9uLnJlcGxhY2UoJ2NyZWF0ZS4nLCAnJylcbiAgICAgIGNvbnNvbGUubG9nKCdDcmVhdGluZyBlbGVtZW50IHR5cGU6JywgZWxlbWVudFR5cGUpXG4gICAgICBcbiAgICAgIGxldCB0eXBlID0gJ2JwbW46VGFzaycgLy8gZGVmYXVsdFxuICAgICAgbGV0IGV2ZW50RGVmaW5pdGlvblR5cGUgPSB1bmRlZmluZWRcbiAgICAgIFxuICAgICAgLy8gTWFwIGFsbCBwb3NzaWJsZSBhY3Rpb25zIHRvIEJQTU4gdHlwZXMgKG1hdGNoaW5nIHJlZ2lzdHJ5IGFjdGlvbnMpXG4gICAgICBjb25zdCB0eXBlTWFwOiBSZWNvcmQ8c3RyaW5nLCB7IHR5cGU6IHN0cmluZzsgZXZlbnREZWZpbml0aW9uVHlwZT86IHN0cmluZzsgaXNFeHBhbmRlZD86IGJvb2xlYW47IHRyaWdnZXJlZEJ5RXZlbnQ/OiBib29sZWFuIH0+ID0ge1xuICAgICAgICAvLyBTdGFydCBFdmVudHNcbiAgICAgICAgJ3N0YXJ0LWV2ZW50JzogeyB0eXBlOiAnYnBtbjpTdGFydEV2ZW50JyB9LFxuICAgICAgICAnc3RhcnQtZXZlbnQtbWVzc2FnZSc6IHsgdHlwZTogJ2JwbW46U3RhcnRFdmVudCcsIGV2ZW50RGVmaW5pdGlvblR5cGU6ICdicG1uOk1lc3NhZ2VFdmVudERlZmluaXRpb24nIH0sXG4gICAgICAgICdzdGFydC1ldmVudC10aW1lcic6IHsgdHlwZTogJ2JwbW46U3RhcnRFdmVudCcsIGV2ZW50RGVmaW5pdGlvblR5cGU6ICdicG1uOlRpbWVyRXZlbnREZWZpbml0aW9uJyB9LFxuICAgICAgICAnc3RhcnQtZXZlbnQtY29uZGl0aW9uYWwnOiB7IHR5cGU6ICdicG1uOlN0YXJ0RXZlbnQnLCBldmVudERlZmluaXRpb25UeXBlOiAnYnBtbjpDb25kaXRpb25hbEV2ZW50RGVmaW5pdGlvbicgfSxcbiAgICAgICAgJ3N0YXJ0LWV2ZW50LXNpZ25hbCc6IHsgdHlwZTogJ2JwbW46U3RhcnRFdmVudCcsIGV2ZW50RGVmaW5pdGlvblR5cGU6ICdicG1uOlNpZ25hbEV2ZW50RGVmaW5pdGlvbicgfSxcbiAgICAgICAgXG4gICAgICAgIC8vIEVuZCBFdmVudHNcbiAgICAgICAgJ2VuZC1ldmVudCc6IHsgdHlwZTogJ2JwbW46RW5kRXZlbnQnIH0sXG4gICAgICAgICdlbmQtZXZlbnQtbWVzc2FnZSc6IHsgdHlwZTogJ2JwbW46RW5kRXZlbnQnLCBldmVudERlZmluaXRpb25UeXBlOiAnYnBtbjpNZXNzYWdlRXZlbnREZWZpbml0aW9uJyB9LFxuICAgICAgICAnZW5kLWV2ZW50LWVzY2FsYXRpb24nOiB7IHR5cGU6ICdicG1uOkVuZEV2ZW50JywgZXZlbnREZWZpbml0aW9uVHlwZTogJ2JwbW46RXNjYWxhdGlvbkV2ZW50RGVmaW5pdGlvbicgfSxcbiAgICAgICAgJ2VuZC1ldmVudC1lcnJvcic6IHsgdHlwZTogJ2JwbW46RW5kRXZlbnQnLCBldmVudERlZmluaXRpb25UeXBlOiAnYnBtbjpFcnJvckV2ZW50RGVmaW5pdGlvbicgfSxcbiAgICAgICAgJ2VuZC1ldmVudC1jYW5jZWwnOiB7IHR5cGU6ICdicG1uOkVuZEV2ZW50JywgZXZlbnREZWZpbml0aW9uVHlwZTogJ2JwbW46Q2FuY2VsRXZlbnREZWZpbml0aW9uJyB9LFxuICAgICAgICAnZW5kLWV2ZW50LWNvbXBlbnNhdGlvbic6IHsgdHlwZTogJ2JwbW46RW5kRXZlbnQnLCBldmVudERlZmluaXRpb25UeXBlOiAnYnBtbjpDb21wZW5zYXRlRXZlbnREZWZpbml0aW9uJyB9LFxuICAgICAgICAnZW5kLWV2ZW50LXNpZ25hbCc6IHsgdHlwZTogJ2JwbW46RW5kRXZlbnQnLCBldmVudERlZmluaXRpb25UeXBlOiAnYnBtbjpTaWduYWxFdmVudERlZmluaXRpb24nIH0sXG4gICAgICAgICdlbmQtZXZlbnQtdGVybWluYXRlJzogeyB0eXBlOiAnYnBtbjpFbmRFdmVudCcsIGV2ZW50RGVmaW5pdGlvblR5cGU6ICdicG1uOlRlcm1pbmF0ZUV2ZW50RGVmaW5pdGlvbicgfSxcbiAgICAgICAgXG4gICAgICAgIC8vIEludGVybWVkaWF0ZSBFdmVudHNcbiAgICAgICAgJ2ludGVybWVkaWF0ZS1ldmVudCc6IHsgdHlwZTogJ2JwbW46SW50ZXJtZWRpYXRlVGhyb3dFdmVudCcgfSxcbiAgICAgICAgJ2ludGVybWVkaWF0ZS1ldmVudC1tZXNzYWdlJzogeyB0eXBlOiAnYnBtbjpJbnRlcm1lZGlhdGVUaHJvd0V2ZW50JywgZXZlbnREZWZpbml0aW9uVHlwZTogJ2JwbW46TWVzc2FnZUV2ZW50RGVmaW5pdGlvbicgfSxcbiAgICAgICAgJ2ludGVybWVkaWF0ZS1ldmVudC10aW1lcic6IHsgdHlwZTogJ2JwbW46SW50ZXJtZWRpYXRlQ2F0Y2hFdmVudCcsIGV2ZW50RGVmaW5pdGlvblR5cGU6ICdicG1uOlRpbWVyRXZlbnREZWZpbml0aW9uJyB9LFxuICAgICAgICAnaW50ZXJtZWRpYXRlLWV2ZW50LWVzY2FsYXRpb24nOiB7IHR5cGU6ICdicG1uOkludGVybWVkaWF0ZVRocm93RXZlbnQnLCBldmVudERlZmluaXRpb25UeXBlOiAnYnBtbjpFc2NhbGF0aW9uRXZlbnREZWZpbml0aW9uJyB9LFxuICAgICAgICAnaW50ZXJtZWRpYXRlLWV2ZW50LWNvbmRpdGlvbmFsJzogeyB0eXBlOiAnYnBtbjpJbnRlcm1lZGlhdGVDYXRjaEV2ZW50JywgZXZlbnREZWZpbml0aW9uVHlwZTogJ2JwbW46Q29uZGl0aW9uYWxFdmVudERlZmluaXRpb24nIH0sXG4gICAgICAgICdpbnRlcm1lZGlhdGUtZXZlbnQtbGluayc6IHsgdHlwZTogJ2JwbW46SW50ZXJtZWRpYXRlVGhyb3dFdmVudCcsIGV2ZW50RGVmaW5pdGlvblR5cGU6ICdicG1uOkxpbmtFdmVudERlZmluaXRpb24nIH0sXG4gICAgICAgICdpbnRlcm1lZGlhdGUtZXZlbnQtY29tcGVuc2F0aW9uJzogeyB0eXBlOiAnYnBtbjpJbnRlcm1lZGlhdGVUaHJvd0V2ZW50JywgZXZlbnREZWZpbml0aW9uVHlwZTogJ2JwbW46Q29tcGVuc2F0ZUV2ZW50RGVmaW5pdGlvbicgfSxcbiAgICAgICAgJ2ludGVybWVkaWF0ZS1ldmVudC1zaWduYWwnOiB7IHR5cGU6ICdicG1uOkludGVybWVkaWF0ZVRocm93RXZlbnQnLCBldmVudERlZmluaXRpb25UeXBlOiAnYnBtbjpTaWduYWxFdmVudERlZmluaXRpb24nIH0sXG4gICAgICAgIFxuICAgICAgICAvLyBUYXNrc1xuICAgICAgICAndGFzayc6IHsgdHlwZTogJ2JwbW46VGFzaycgfSxcbiAgICAgICAgJ3VzZXItdGFzayc6IHsgdHlwZTogJ2JwbW46VXNlclRhc2snIH0sXG4gICAgICAgICdzZXJ2aWNlLXRhc2snOiB7IHR5cGU6ICdicG1uOlNlcnZpY2VUYXNrJyB9LFxuICAgICAgICAnc2NyaXB0LXRhc2snOiB7IHR5cGU6ICdicG1uOlNjcmlwdFRhc2snIH0sXG4gICAgICAgICdidXNpbmVzcy1ydWxlLXRhc2snOiB7IHR5cGU6ICdicG1uOkJ1c2luZXNzUnVsZVRhc2snIH0sXG4gICAgICAgICdzZW5kLXRhc2snOiB7IHR5cGU6ICdicG1uOlNlbmRUYXNrJyB9LFxuICAgICAgICAncmVjZWl2ZS10YXNrJzogeyB0eXBlOiAnYnBtbjpSZWNlaXZlVGFzaycgfSxcbiAgICAgICAgJ21hbnVhbC10YXNrJzogeyB0eXBlOiAnYnBtbjpNYW51YWxUYXNrJyB9LFxuICAgICAgICBcbiAgICAgICAgLy8gR2F0ZXdheXNcbiAgICAgICAgJ2V4Y2x1c2l2ZS1nYXRld2F5JzogeyB0eXBlOiAnYnBtbjpFeGNsdXNpdmVHYXRld2F5JyB9LFxuICAgICAgICAncGFyYWxsZWwtZ2F0ZXdheSc6IHsgdHlwZTogJ2JwbW46UGFyYWxsZWxHYXRld2F5JyB9LFxuICAgICAgICAnaW5jbHVzaXZlLWdhdGV3YXknOiB7IHR5cGU6ICdicG1uOkluY2x1c2l2ZUdhdGV3YXknIH0sXG4gICAgICAgICdldmVudC1iYXNlZC1nYXRld2F5JzogeyB0eXBlOiAnYnBtbjpFdmVudEJhc2VkR2F0ZXdheScgfSxcbiAgICAgICAgJ2NvbXBsZXgtZ2F0ZXdheSc6IHsgdHlwZTogJ2JwbW46Q29tcGxleEdhdGV3YXknIH0sXG4gICAgICAgIFxuICAgICAgICAvLyBTdWIgUHJvY2Vzc1xuICAgICAgICAnc3VicHJvY2Vzcy1leHBhbmRlZCc6IHsgdHlwZTogJ2JwbW46U3ViUHJvY2VzcycsIGlzRXhwYW5kZWQ6IHRydWUgfSxcbiAgICAgICAgJ3N1YnByb2Nlc3MtY29sbGFwc2VkJzogeyB0eXBlOiAnYnBtbjpTdWJQcm9jZXNzJywgaXNFeHBhbmRlZDogZmFsc2UgfSxcbiAgICAgICAgJ2V2ZW50LXN1YnByb2Nlc3MnOiB7IHR5cGU6ICdicG1uOlN1YlByb2Nlc3MnLCB0cmlnZ2VyZWRCeUV2ZW50OiB0cnVlIH0sXG4gICAgICAgICd0cmFuc2FjdGlvbic6IHsgdHlwZTogJ2JwbW46VHJhbnNhY3Rpb24nIH0sXG4gICAgICAgICdjYWxsLWFjdGl2aXR5JzogeyB0eXBlOiAnYnBtbjpDYWxsQWN0aXZpdHknIH0sXG4gICAgICAgIFxuICAgICAgICAvLyBEYXRhXG4gICAgICAgICdkYXRhLW9iamVjdCc6IHsgdHlwZTogJ2JwbW46RGF0YU9iamVjdFJlZmVyZW5jZScgfSxcbiAgICAgICAgJ2RhdGEtc3RvcmUnOiB7IHR5cGU6ICdicG1uOkRhdGFTdG9yZVJlZmVyZW5jZScgfSxcbiAgICAgICAgJ2RhdGEtaW5wdXQnOiB7IHR5cGU6ICdicG1uOkRhdGFJbnB1dCcgfSxcbiAgICAgICAgJ2RhdGEtb3V0cHV0JzogeyB0eXBlOiAnYnBtbjpEYXRhT3V0cHV0JyB9LFxuICAgICAgICBcbiAgICAgICAgLy8gUGFydGljaXBhbnRzXG4gICAgICAgICdwYXJ0aWNpcGFudC1leHBhbmRlZCc6IHsgdHlwZTogJ2JwbW46UGFydGljaXBhbnQnIH0sXG4gICAgICAgICdwYXJ0aWNpcGFudCc6IHsgdHlwZTogJ2JwbW46UGFydGljaXBhbnQnIH0sXG4gICAgICAgICdsYW5lJzogeyB0eXBlOiAnYnBtbjpMYW5lJyB9LFxuICAgICAgICBcbiAgICAgICAgLy8gQXJ0aWZhY3RzXG4gICAgICAgICdncm91cCc6IHsgdHlwZTogJ2JwbW46R3JvdXAnIH0sXG4gICAgICAgICd0ZXh0LWFubm90YXRpb24nOiB7IHR5cGU6ICdicG1uOlRleHRBbm5vdGF0aW9uJyB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnN0IGVsZW1lbnRDb25maWcgPSB0eXBlTWFwW2VsZW1lbnRUeXBlXSB8fCB7IHR5cGU6ICdicG1uOlRhc2snIH1cbiAgICAgIFxuICAgICAgLy8gQ3JlYXRlIHRoZSBzaGFwZSB3aXRoIHByb3BlciBjb25maWd1cmF0aW9uXG4gICAgICBjb25zdCBzaGFwZUNvbmZpZzogYW55ID0geyB0eXBlOiBlbGVtZW50Q29uZmlnLnR5cGUgfVxuICAgICAgXG4gICAgICAvLyBBZGQgZXZlbnQgZGVmaW5pdGlvbiBpZiBuZWVkZWRcbiAgICAgIGlmIChlbGVtZW50Q29uZmlnLmV2ZW50RGVmaW5pdGlvblR5cGUpIHtcbiAgICAgICAgY29uc3QgYnBtbkZhY3RvcnkgPSBtb2RlbGVyUmVmLmN1cnJlbnQuZ2V0KCdicG1uRmFjdG9yeScpIGFzIGFueVxuICAgICAgICBjb25zdCBldmVudERlZmluaXRpb24gPSBicG1uRmFjdG9yeS5jcmVhdGUoZWxlbWVudENvbmZpZy5ldmVudERlZmluaXRpb25UeXBlKVxuICAgICAgICBzaGFwZUNvbmZpZy5ldmVudERlZmluaXRpb25UeXBlID0gZWxlbWVudENvbmZpZy5ldmVudERlZmluaXRpb25UeXBlXG4gICAgICAgIHNoYXBlQ29uZmlnLmJ1c2luZXNzT2JqZWN0ID0gYnBtbkZhY3RvcnkuY3JlYXRlKGVsZW1lbnRDb25maWcudHlwZSwge1xuICAgICAgICAgIGV2ZW50RGVmaW5pdGlvbnM6IFtldmVudERlZmluaXRpb25dXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIEhhbmRsZSBleHBhbmRlZC9jb2xsYXBzZWQgc3RhdGVcbiAgICAgIGlmICgnaXNFeHBhbmRlZCcgaW4gZWxlbWVudENvbmZpZykge1xuICAgICAgICBzaGFwZUNvbmZpZy5pc0V4cGFuZGVkID0gZWxlbWVudENvbmZpZy5pc0V4cGFuZGVkXG4gICAgICB9XG4gICAgICBcbiAgICAgIGlmICgndHJpZ2dlcmVkQnlFdmVudCcgaW4gZWxlbWVudENvbmZpZykge1xuICAgICAgICBzaGFwZUNvbmZpZy50cmlnZ2VyZWRCeUV2ZW50ID0gZWxlbWVudENvbmZpZy50cmlnZ2VyZWRCeUV2ZW50XG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnN0IHNoYXBlID0gZWxlbWVudEZhY3RvcnkuY3JlYXRlU2hhcGUoc2hhcGVDb25maWcpXG4gICAgICBcbiAgICAgIC8vIElmIGl0J3MgYSBkcmFnIGV2ZW50LCB1c2UgZHJhZyBjb29yZGluYXRlc1xuICAgICAgaWYgKGV2ZW50IGluc3RhbmNlb2YgRHJhZ0V2ZW50KSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdTdGFydGluZyBkcmFnIGNyZWF0ZSBmb3I6JywgZWxlbWVudFR5cGUpXG4gICAgICAgIC8vIEZvciBkcmFnIGV2ZW50cywgd2UgbmVlZCB0byBsZXQgQlBNTi5qcyBoYW5kbGUgdGhlIGRyb3BcbiAgICAgICAgLy8gVGhlIGNyZWF0ZSBtb2R1bGUgZXhwZWN0cyB0aGUgZHJhZyBldmVudCB0byBjb250aW51ZVxuICAgICAgICBjcmVhdGUuc3RhcnQoZXZlbnQsIHNoYXBlKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRm9yIGNsaWNrIGV2ZW50cywgZGlyZWN0bHkgY3JlYXRlIHRoZSBzaGFwZSBhdCBhIHBvc2l0aW9uXG4gICAgICAgIGNvbnNvbGUubG9nKCdDcmVhdGluZyBlbGVtZW50IHZpYSBjbGljazonLCBlbGVtZW50VHlwZSlcbiAgICAgICAgY29uc3Qgcm9vdEVsZW1lbnQgPSBjYW52YXMuZ2V0Um9vdEVsZW1lbnQoKVxuICAgICAgICBjb25zdCB2aWV3cG9ydCA9IGNhbnZhcy52aWV3Ym94KClcbiAgICAgICAgXG4gICAgICAgIC8vIENhbGN1bGF0ZSBjZW50ZXIgcG9zaXRpb24gYWNjb3VudGluZyBmb3IgY3VycmVudCB6b29tXG4gICAgICAgIGNvbnN0IGNlbnRlclggPSB2aWV3cG9ydC54ICsgKHZpZXdwb3J0LndpZHRoIC8gMilcbiAgICAgICAgY29uc3QgY2VudGVyWSA9IHZpZXdwb3J0LnkgKyAodmlld3BvcnQuaGVpZ2h0IC8gMilcbiAgICAgICAgXG4gICAgICAgIC8vIERpcmVjdGx5IGNyZWF0ZSB0aGUgc2hhcGUgdXNpbmcgbW9kZWxpbmdcbiAgICAgICAgbW9kZWxpbmcuY3JlYXRlU2hhcGUoc2hhcGUsIHsgeDogY2VudGVyWCwgeTogY2VudGVyWSB9LCByb290RWxlbWVudClcbiAgICAgIH1cbiAgICB9XG4gIH0sIFtdKVxuXG4gIGlmIChlcnJvcikge1xuICAgIHJldHVybiAoXG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cImgtc2NyZWVuIGZsZXggaXRlbXMtY2VudGVyIGp1c3RpZnktY2VudGVyIGJnLWdyYXktNTBcIj5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ0ZXh0LWNlbnRlclwiPlxuICAgICAgICAgIDxoMiBjbGFzc05hbWU9XCJ0ZXh0LXhsIGZvbnQtc2VtaWJvbGQgdGV4dC1yZWQtNjAwIG1iLTJcIj5FcnJvciBMb2FkaW5nIFN0dWRpbzwvaDI+XG4gICAgICAgICAgPHAgY2xhc3NOYW1lPVwidGV4dC1ncmF5LTYwMFwiPntlcnJvcn08L3A+XG4gICAgICAgICAgPGJ1dHRvbiBcbiAgICAgICAgICAgIG9uQ2xpY2s9eygpID0+IHdpbmRvdy5sb2NhdGlvbi5yZWxvYWQoKX1cbiAgICAgICAgICAgIGNsYXNzTmFtZT1cIm10LTQgcHgtNCBweS0yIGJnLWJsdWUtNjAwIHRleHQtd2hpdGUgcm91bmRlZCBob3ZlcjpiZy1ibHVlLTcwMFwiXG4gICAgICAgICAgPlxuICAgICAgICAgICAgUmVsb2FkIFBhZ2VcbiAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICApXG4gIH1cblxuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3NOYW1lPVwiaC1zY3JlZW4gZmxleCBmbGV4LWNvbCBiZy1iYWNrZ3JvdW5kXCI+XG4gICAgICB7LyogVXNlIHRoZSBwcm9wZXIgQnBtblRvb2xiYXIgY29tcG9uZW50IHdpdGggYWxsIGhhbmRsZXJzICovfVxuICAgICAgPEJwbW5Ub29sYmFyXG4gICAgICAgIG9uU2F2ZT17aGFuZGxlU2F2ZX1cbiAgICAgICAgb25FeHBvcnQ9e2hhbmRsZUV4cG9ydH1cbiAgICAgICAgb25JbXBvcnQ9eygpID0+IGZpbGVJbnB1dFJlZi5jdXJyZW50Py5jbGljaygpfVxuICAgICAgICBvblVuZG89e2hhbmRsZVVuZG99XG4gICAgICAgIG9uUmVkbz17aGFuZGxlUmVkb31cbiAgICAgICAgb25ab29tSW49e2hhbmRsZVpvb21Jbn1cbiAgICAgICAgb25ab29tT3V0PXtoYW5kbGVab29tT3V0fVxuICAgICAgICBvbkZpdFRvVmlld3BvcnQ9e2hhbmRsZVpvb21SZXNldH1cbiAgICAgICAgb25DbGVhcj17aGFuZGxlQ2xlYXJ9XG4gICAgICAgIG9uVG9nZ2xlVGhlbWU9e2hhbmRsZVRoZW1lVG9nZ2xlfVxuICAgICAgICBvbkFsaWduTGVmdD17aGFuZGxlQWxpZ25MZWZ0fVxuICAgICAgICBvbkFsaWduQ2VudGVyPXtoYW5kbGVBbGlnbkNlbnRlcn1cbiAgICAgICAgb25BbGlnblJpZ2h0PXtoYW5kbGVBbGlnblJpZ2h0fVxuICAgICAgICBvbkFsaWduVG9wPXtoYW5kbGVBbGlnblRvcH1cbiAgICAgICAgb25BbGlnbk1pZGRsZT17aGFuZGxlQWxpZ25NaWRkbGV9XG4gICAgICAgIG9uQWxpZ25Cb3R0b209e2hhbmRsZUFsaWduQm90dG9tfVxuICAgICAgICBvblByZXZpZXc9e2hhbmRsZVByZXZpZXd9XG4gICAgICAgIG9uUnVuPXtoYW5kbGVSdW5Qcm9jZXNzfVxuICAgICAgICBvbk1lZXRpbmdNb2RlPXtoYW5kbGVNZWV0aW5nTW9kZX1cbiAgICAgICAgb25Ub2dnbGVNaW5pbWFwPXtoYW5kbGVUb2dnbGVNaW5pbWFwfVxuICAgICAgICBvblRvZ2dsZUxhbmd1YWdlPXtoYW5kbGVUb2dnbGVMYW5ndWFnZX1cbiAgICAgICAgb25Ub2dnbGVHcmlkPXtoYW5kbGVUb2dnbGVHcmlkfVxuICAgICAgICB0aGVtZT17dGhlbWV9XG4gICAgICAgIHpvb21MZXZlbD17em9vbUxldmVsfVxuICAgICAgICBjYW5VbmRvPXtjYW5VbmRvfVxuICAgICAgICBjYW5SZWRvPXtjYW5SZWRvfVxuICAgICAgICBkaXNhYmxlZD17c2F2aW5nfVxuICAgICAgICBpc01lZXRpbmdNb2RlPXtpc01lZXRpbmdNb2RlfVxuICAgICAgICBpc01pbmltYXBPcGVuPXtpc01pbmltYXBPcGVufVxuICAgICAgICBzaG93R3JpZD17c2hvd0dyaWR9XG4gICAgICAvPlxuXG4gICAgICB7LyogTWFpbiBDb250ZW50IEFyZWEgd2l0aCBDdXN0b20gQ29sbGFwc2libGUgUGFsZXR0ZSAqL31cbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleC0xIGZsZXggb3ZlcmZsb3ctaGlkZGVuXCI+XG4gICAgICAgIHsvKiBDdXN0b20gQ29sbGFwc2libGUgQlBNTiBFbGVtZW50cyBQYWxldHRlIC0gaGlkZSBpbiBtZWV0aW5nIG1vZGUgKi99XG4gICAgICAgIHshaXNNZWV0aW5nTW9kZSAmJiAoXG4gICAgICAgICAgPEJwbW5FbGVtZW50c1BhbGV0dGUgXG4gICAgICAgICAgICBvbkFjdGlvbj17aGFuZGxlUGFsZXR0ZUFjdGlvbn1cbiAgICAgICAgICAgIGFjdGl2ZVRvb2w9e2FjdGl2ZVRvb2x9XG4gICAgICAgICAgLz5cbiAgICAgICAgKX1cblxuICAgICAgICB7LyogQ2FudmFzIENvbnRhaW5lciAqL31cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4LTEgcmVsYXRpdmUgYmctZ3JheS01MCBkYXJrOmJnLWdyYXktOTAwXCI+XG4gICAgICAgICAgPGRpdiBcbiAgICAgICAgICAgIHJlZj17Y29udGFpbmVyUmVmfVxuICAgICAgICAgICAgY2xhc3NOYW1lPVwidy1mdWxsIGgtZnVsbFwiXG4gICAgICAgICAgICBzdHlsZT17eyBcbiAgICAgICAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICAgICAgICAgIHRvcDogMCxcbiAgICAgICAgICAgICAgbGVmdDogMCxcbiAgICAgICAgICAgICAgcmlnaHQ6IDAsXG4gICAgICAgICAgICAgIGJvdHRvbTogMFxuICAgICAgICAgICAgfX1cbiAgICAgICAgICAvPlxuICAgICAgICAgIHshaXNSZWFkeSAmJiAoXG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImFic29sdXRlIGluc2V0LTAgZmxleCBpdGVtcy1jZW50ZXIganVzdGlmeS1jZW50ZXIgYmctZ3JheS01MC85MCBkYXJrOmJnLWdyYXktOTAwLzkwIHBvaW50ZXItZXZlbnRzLW5vbmVcIj5cbiAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ0ZXh0LWNlbnRlclwiPlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiYW5pbWF0ZS1zcGluIHJvdW5kZWQtZnVsbCBoLTEyIHctMTIgYm9yZGVyLWItMiBib3JkZXItYmx1ZS02MDAgbXgtYXV0b1wiPjwvZGl2PlxuICAgICAgICAgICAgICAgIDxwIGNsYXNzTmFtZT1cIm10LTQgdGV4dC1ncmF5LTYwMCBkYXJrOnRleHQtZ3JheS00MDBcIj5Jbml0aWFsaXppbmcgQlBNTiBTdHVkaW8uLi48L3A+XG4gICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgKX1cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cblxuICAgICAgey8qIEhpZGRlbiBmaWxlIGlucHV0ICovfVxuICAgICAgPGlucHV0XG4gICAgICAgIHJlZj17ZmlsZUlucHV0UmVmfVxuICAgICAgICB0eXBlPVwiZmlsZVwiXG4gICAgICAgIGFjY2VwdD1cIi5icG1uLC54bWxcIlxuICAgICAgICBvbkNoYW5nZT17aGFuZGxlSW1wb3J0fVxuICAgICAgICBjbGFzc05hbWU9XCJoaWRkZW5cIlxuICAgICAgLz5cblxuICAgICAgey8qIFhNTCBWaWV3ZXIgTW9kYWwgKi99XG4gICAgICA8WG1sVmlld2VyTW9kYWxcbiAgICAgICAgaXNPcGVuPXtzaG93WG1sVmlld2VyfVxuICAgICAgICBvbkNsb3NlPXsoKSA9PiBzZXRTaG93WG1sVmlld2VyKGZhbHNlKX1cbiAgICAgICAgeG1sPXtjdXJyZW50WG1sfVxuICAgICAgICBvblNhdmU9e2hhbmRsZVhtbFNhdmV9XG4gICAgICAgIHJlYWRPbmx5PXtmYWxzZX1cbiAgICAgIC8+XG4gICAgPC9kaXY+XG4gIClcbn0iXSwibmFtZXMiOlsidXNlRWZmZWN0IiwidXNlUmVmIiwidXNlU3RhdGUiLCJ1c2VDYWxsYmFjayIsIkJwbW5Nb2RlbGVyIiwiQnBtblRvb2xiYXIiLCJCcG1uRWxlbWVudHNQYWxldHRlIiwiWG1sVmlld2VyTW9kYWwiLCJ1c2VUaGVtZSIsIkRFRkFVTFRfQlBNTiIsIkJwbW5TdHVkaW9GaXhlZCIsImNvbnRhaW5lclJlZiIsIm1vZGVsZXJSZWYiLCJmaWxlSW5wdXRSZWYiLCJpc1JlYWR5Iiwic2V0SXNSZWFkeSIsImVycm9yIiwic2V0RXJyb3IiLCJjYW5VbmRvIiwic2V0Q2FuVW5kbyIsImNhblJlZG8iLCJzZXRDYW5SZWRvIiwidGhlbWUiLCJzZXRUaGVtZSIsInN0eWxlRWxlbWVudFJlZiIsInpvb21MZXZlbCIsInNldFpvb21MZXZlbCIsInNhdmluZyIsInNldFNhdmluZyIsImFjdGl2ZVRvb2wiLCJzZXRBY3RpdmVUb29sIiwidW5kZWZpbmVkIiwiaXNNZWV0aW5nTW9kZSIsInNldElzTWVldGluZ01vZGUiLCJpc01pbmltYXBPcGVuIiwic2V0SXNNaW5pbWFwT3BlbiIsInNob3dHcmlkIiwic2V0U2hvd0dyaWQiLCJzaG93UHJldmlldyIsInNldFNob3dQcmV2aWV3Iiwic2hvd1htbFZpZXdlciIsInNldFNob3dYbWxWaWV3ZXIiLCJjdXJyZW50WG1sIiwic2V0Q3VycmVudFhtbCIsInNlbGVjdGVkRWxlbWVudHMiLCJzZXRTZWxlY3RlZEVsZW1lbnRzIiwiYXBwbHlCcG1uU3R5bGVzIiwibW9kZWxlciIsImN1cnJlbnRUaGVtZSIsImNhbnZhcyIsImdldCIsImNvbnRhaW5lciIsIl9jb250YWluZXIiLCJnZXRDb250YWluZXIiLCJzdmciLCJxdWVyeVNlbGVjdG9yIiwiX3N2ZyIsImNyZWF0ZVNWR01hdHJpeCIsImNvbnNvbGUiLCJ3YXJuIiwic2V0VGltZW91dCIsInN0eWxlIiwiY3VycmVudCIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsImlkIiwiaXNEYXJrIiwibG9nIiwidGV4dENvbnRlbnQiLCJwYXJlbnROb2RlIiwiaGVhZCIsImFwcGVuZENoaWxkIiwiY2xhc3NMaXN0IiwiYWRkIiwicmVtb3ZlIiwiYmFja2dyb3VuZENvbG9yIiwic3ZnRWxlbWVudCIsImV2ZW50QnVzIiwiZmlyZSIsImZvcmNlQ29sb3JVcGRhdGUiLCJzdmdFbGVtZW50cyIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJmb3JFYWNoIiwiZWwiLCJ0YWdOYW1lIiwidG9Mb3dlckNhc2UiLCJoYXNBdHRyaWJ1dGUiLCJzdHJva2UiLCJjdXJyZW50U3Ryb2tlIiwiZ2V0QXR0cmlidXRlIiwibmVlZHNGaXgiLCJuZXdTdHJva2UiLCJzZXRBdHRyaWJ1dGUiLCJzdHJva2VPcGFjaXR5IiwiY3VycmVudEZpbGwiLCJmaWxsIiwiY2xvc2VzdCIsIm5ld0ZpbGwiLCJuZXdDb2xvciIsImVyciIsIm1vdW50ZWQiLCJvYnNlcnZlciIsImluaXRCcG1uIiwib2Zmc2V0V2lkdGgiLCJvZmZzZXRIZWlnaHQiLCJrZXlib2FyZCIsImJpbmRUbyIsIndpbmRvdyIsImFkZGl0aW9uYWxNb2R1bGVzIiwibW9kZGxlRXh0ZW5zaW9ucyIsImltcG9ydFhNTCIsIlByb21pc2UiLCJyZXNvbHZlIiwiY29tbWFuZFN0YWNrIiwidXBkYXRlVW5kb1JlZG8iLCJvbiIsInNlbGVjdGlvbiIsImUiLCJlbGVtZW50cyIsIm5ld1NlbGVjdGlvbiIsImxlbmd0aCIsInNlbGVjdGlvbkJveGVzIiwiYm94IiwiZmlsbE9wYWNpdHkiLCJmcmFtZXMiLCJmcmFtZSIsInJlY3QiLCJlZGl0b3JBY3Rpb25zIiwicmVnaXN0ZXIiLCJlbGVtZW50UmVnaXN0cnkiLCJhbGxFbGVtZW50cyIsImZpbHRlciIsImVsZW1lbnQiLCJ0eXBlIiwibGFiZWxUYXJnZXQiLCJzZWxlY3QiLCJwb3B1cE1lbnUiLCJyZXBsYWNlTWVudVByb3ZpZGVyIiwiZWxlbWVudFNoYXBlIiwicG9zaXRpb24iLCJ4Iiwid2lkdGgiLCJ5IiwiZW50cmllcyIsImdldFBvcHVwTWVudUVudHJpZXMiLCJPYmplY3QiLCJrZXlzIiwib3BlbiIsInJlcGxhY2VQcmV2aWV3IiwidG9nZ2xlIiwiYWRkTGlzdGVuZXIiLCJjb250ZXh0Iiwia2V5Iiwia2V5RXZlbnQiLCJjdHJsIiwiY3RybEtleSIsIm1ldGFLZXkiLCJ0cmlnZ2VyIiwicHJldmVudERlZmF1bHQiLCJzaGlmdEtleSIsImFsdEtleSIsImFjdGl2ZUVsZW1lbnQiLCJoYW5kbGVHbG9iYWxLZXlkb3duIiwiY2FudmFzRWxlbWVudCIsImNvbnRhaW5zIiwiYm9keSIsInN0b3BQcm9wYWdhdGlvbiIsImFkZEV2ZW50TGlzdGVuZXIiLCJfc3BhY2ViYXJIYW5kbGVyIiwiY2FudmFzQ29udGFpbmVyIiwiTXV0YXRpb25PYnNlcnZlciIsIm11dGF0aW9ucyIsImRvY3VtZW50RWxlbWVudCIsImlzRGFya01vZGUiLCJtdXRhdGlvbiIsImFkZGVkTm9kZXMiLCJub2RlIiwibm9kZVR5cGUiLCJyZWN0cyIsImVsVGFnIiwidGFyZ2V0IiwiYXR0cmlidXRlTmFtZSIsIm9ic2VydmUiLCJjaGlsZExpc3QiLCJzdWJ0cmVlIiwiYXR0cmlidXRlcyIsImF0dHJpYnV0ZUZpbHRlciIsIkVycm9yIiwibWVzc2FnZSIsImRpc2Nvbm5lY3QiLCJkZXN0cm95IiwiZml4VGFza0NvbG9ycyIsInRhc2tzIiwidGFzayIsImludGVydmFscyIsImRlbGF5IiwiaGFuZGxlU2F2ZSIsInhtbCIsInNhdmVYTUwiLCJmb3JtYXQiLCJsb2NhbFN0b3JhZ2UiLCJzZXRJdGVtIiwiaGFuZGxlRXhwb3J0IiwicHJvbXB0IiwiY29udGVudCIsImZpbGVuYW1lIiwibWltZVR5cGUiLCJ4bWxEb2MiLCJwYXJzZXIiLCJET01QYXJzZXIiLCJwYXJzZUZyb21TdHJpbmciLCJqc29uRGF0YSIsInByb2Nlc3MiLCJBcnJheSIsImZyb20iLCJtYXAiLCJuYW1lIiwiSlNPTiIsInN0cmluZ2lmeSIsInlhbWxDb250ZW50IiwiYmxvYiIsIkJsb2IiLCJ1cmwiLCJVUkwiLCJjcmVhdGVPYmplY3RVUkwiLCJhIiwiaHJlZiIsImRvd25sb2FkIiwiY2xpY2siLCJyZXZva2VPYmplY3RVUkwiLCJoYW5kbGVJbXBvcnQiLCJmaWxlIiwiZmlsZXMiLCJyZWFkZXIiLCJGaWxlUmVhZGVyIiwib25sb2FkIiwiZXZlbnQiLCJyZXN1bHQiLCJleHQiLCJzcGxpdCIsInBvcCIsInBhcnNlIiwiYWxlcnQiLCJyZWFkQXNUZXh0IiwiaGFuZGxlVW5kbyIsInVuZG8iLCJoYW5kbGVSZWRvIiwicmVkbyIsImhhbmRsZVpvb21JbiIsImN1cnJlbnRab29tIiwiem9vbSIsIm5ld1pvb20iLCJNYXRoIiwibWluIiwicm91bmQiLCJoYW5kbGVab29tT3V0IiwibWF4IiwiaGFuZGxlWm9vbVJlc2V0IiwiaGFuZGxlQ2xlYXIiLCJjb25maXJtIiwiaGFuZGxlVGhlbWVUb2dnbGUiLCJuZXdUaGVtZSIsInZpZXdib3giLCJiZ0NvbG9yIiwidmlld3BvcnQiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJoYW5kbGVBbGlnbkxlZnQiLCJtb2RlbGluZyIsImxlZnRNb3N0IiwicmVkdWNlIiwibW92ZUVsZW1lbnRzIiwiaGFuZGxlQWxpZ25DZW50ZXIiLCJjZW50ZXJYIiwic3VtIiwidGFyZ2V0WCIsImhhbmRsZUFsaWduUmlnaHQiLCJyaWdodE1vc3QiLCJyaWdodEVkZ2UiLCJoYW5kbGVBbGlnblRvcCIsInRvcE1vc3QiLCJoYW5kbGVBbGlnbk1pZGRsZSIsIm1pZGRsZVkiLCJoZWlnaHQiLCJ0YXJnZXRZIiwiaGFuZGxlQWxpZ25Cb3R0b20iLCJib3R0b21Nb3N0IiwiYm90dG9tRWRnZSIsImhhbmRsZVByZXZpZXciLCJoYW5kbGVYbWxTYXZlIiwibmV3WG1sIiwiaGFuZGxlUnVuUHJvY2VzcyIsImhhbmRsZU1lZXRpbmdNb2RlIiwicmVxdWVzdEZ1bGxzY3JlZW4iLCJmdWxsc2NyZWVuRWxlbWVudCIsImV4aXRGdWxsc2NyZWVuIiwiaGFuZGxlVG9nZ2xlTWluaW1hcCIsImhhbmRsZVRvZ2dsZUxhbmd1YWdlIiwiaGFuZGxlVG9nZ2xlR3JpZCIsInByZXYiLCJuZXdWYWx1ZSIsImhhbmRsZVBhbGV0dGVBY3Rpb24iLCJhY3Rpb24iLCJlbmRzV2l0aCIsInJlcGxhY2UiLCJoYW5kVG9vbCIsImxhc3NvVG9vbCIsInNwYWNlVG9vbCIsImdsb2JhbENvbm5lY3QiLCJhY3RpdmF0ZUhhbmQiLCJhY3RpdmF0ZVNlbGVjdGlvbiIsInN0YXJ0c1dpdGgiLCJlbGVtZW50RmFjdG9yeSIsImNyZWF0ZSIsImVsZW1lbnRUeXBlIiwiZXZlbnREZWZpbml0aW9uVHlwZSIsInR5cGVNYXAiLCJpc0V4cGFuZGVkIiwidHJpZ2dlcmVkQnlFdmVudCIsImVsZW1lbnRDb25maWciLCJzaGFwZUNvbmZpZyIsImJwbW5GYWN0b3J5IiwiZXZlbnREZWZpbml0aW9uIiwiYnVzaW5lc3NPYmplY3QiLCJldmVudERlZmluaXRpb25zIiwic2hhcGUiLCJjcmVhdGVTaGFwZSIsIkRyYWdFdmVudCIsInN0YXJ0Iiwicm9vdEVsZW1lbnQiLCJnZXRSb290RWxlbWVudCIsImNlbnRlclkiLCJkaXYiLCJjbGFzc05hbWUiLCJoMiIsInAiLCJidXR0b24iLCJvbkNsaWNrIiwibG9jYXRpb24iLCJyZWxvYWQiLCJvblNhdmUiLCJvbkV4cG9ydCIsIm9uSW1wb3J0Iiwib25VbmRvIiwib25SZWRvIiwib25ab29tSW4iLCJvblpvb21PdXQiLCJvbkZpdFRvVmlld3BvcnQiLCJvbkNsZWFyIiwib25Ub2dnbGVUaGVtZSIsIm9uQWxpZ25MZWZ0Iiwib25BbGlnbkNlbnRlciIsIm9uQWxpZ25SaWdodCIsIm9uQWxpZ25Ub3AiLCJvbkFsaWduTWlkZGxlIiwib25BbGlnbkJvdHRvbSIsIm9uUHJldmlldyIsIm9uUnVuIiwib25NZWV0aW5nTW9kZSIsIm9uVG9nZ2xlTWluaW1hcCIsIm9uVG9nZ2xlTGFuZ3VhZ2UiLCJvblRvZ2dsZUdyaWQiLCJkaXNhYmxlZCIsIm9uQWN0aW9uIiwicmVmIiwidG9wIiwibGVmdCIsInJpZ2h0IiwiYm90dG9tIiwiaW5wdXQiLCJhY2NlcHQiLCJvbkNoYW5nZSIsImlzT3BlbiIsIm9uQ2xvc2UiLCJyZWFkT25seSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./components/bpmn/BpmnStudioFixed.tsx\n"));

/***/ })

});