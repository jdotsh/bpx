"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/studio/page",{

/***/ "(app-pages-browser)/./components/bpmn/BpmnStudioFixed.tsx":
/*!*********************************************!*\
  !*** ./components/bpmn/BpmnStudioFixed.tsx ***!
  \*********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BpmnStudioFixed: function() { return /* binding */ BpmnStudioFixed; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var bpmn_js_lib_Modeler__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! bpmn-js/lib/Modeler */ \"(app-pages-browser)/./node_modules/bpmn-js/lib/Modeler.js\");\n/* harmony import */ var _bpmn_toolbar__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./bpmn-toolbar */ \"(app-pages-browser)/./components/bpmn/bpmn-toolbar.tsx\");\n/* harmony import */ var _bpmn_elements_palette__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./bpmn-elements-palette */ \"(app-pages-browser)/./components/bpmn/bpmn-elements-palette.tsx\");\n/* harmony import */ var _XmlViewerModal__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./XmlViewerModal */ \"(app-pages-browser)/./components/bpmn/XmlViewerModal.tsx\");\n/* harmony import */ var _components_theme_provider__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @/components/theme-provider */ \"(app-pages-browser)/./components/theme-provider.tsx\");\n/* __next_internal_client_entry_do_not_use__ BpmnStudioFixed auto */ \nvar _s = $RefreshSig$();\n\n\n\n\n\n\n// NO CSS imports here - they are in globals.css\nconst DEFAULT_BPMN = '<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n<bpmn2:definitions xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" \\n  xmlns:bpmn2=\"http://www.omg.org/spec/BPMN/20100524/MODEL\" \\n  xmlns:bpmndi=\"http://www.omg.org/spec/BPMN/20100524/DI\" \\n  xmlns:dc=\"http://www.omg.org/spec/DD/20100524/DC\" \\n  xmlns:di=\"http://www.omg.org/spec/DD/20100524/DI\" \\n  id=\"sample-diagram\" \\n  targetNamespace=\"http://bpmn.io/schema/bpmn\">\\n  <bpmn2:process id=\"Process_1\" isExecutable=\"false\">\\n    <bpmn2:startEvent id=\"StartEvent_1\" name=\"Start\"/>\\n  </bpmn2:process>\\n  <bpmndi:BPMNDiagram id=\"BPMNDiagram_1\">\\n    <bpmndi:BPMNPlane id=\"BPMNPlane_1\" bpmnElement=\"Process_1\">\\n      <bpmndi:BPMNShape id=\"_BPMNShape_StartEvent_2\" bpmnElement=\"StartEvent_1\">\\n        <dc:Bounds height=\"36.0\" width=\"36.0\" x=\"412.0\" y=\"240.0\"/>\\n      </bpmndi:BPMNShape>\\n    </bpmndi:BPMNPlane>\\n  </bpmndi:BPMNDiagram>\\n</bpmn2:definitions>';\nfunction BpmnStudioFixed() {\n    _s();\n    const containerRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const modelerRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const fileInputRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const [isReady, setIsReady] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [canUndo, setCanUndo] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [canRedo, setCanRedo] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const { theme, setTheme } = (0,_components_theme_provider__WEBPACK_IMPORTED_MODULE_5__.useTheme)();\n    const styleElementRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const [zoomLevel, setZoomLevel] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(100);\n    const [saving, setSaving] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [activeTool, setActiveTool] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(undefined);\n    const [isMeetingMode, setIsMeetingMode] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [isMinimapOpen, setIsMinimapOpen] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [showGrid, setShowGrid] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(true);\n    const [showPreview, setShowPreview] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [showXmlViewer, setShowXmlViewer] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [currentXml, setCurrentXml] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"\");\n    const [selectedElements, setSelectedElements] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    // Helper function to apply styles (needs to be defined before useEffect)\n    const applyBpmnStyles = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((modeler, currentTheme)=>{\n        if (!modeler) return;\n        try {\n            const canvas = modeler.get(\"canvas\");\n            if (!canvas) return;\n            // Get the container and ensure SVG is available\n            const container = canvas._container || canvas.getContainer();\n            const svg = (container === null || container === void 0 ? void 0 : container.querySelector(\"svg\")) || canvas._svg;\n            // Check if SVG element exists and has necessary methods\n            if (!svg || typeof svg.createSVGMatrix !== \"function\") {\n                console.warn(\"SVG element not ready, delaying style application\");\n                setTimeout(()=>applyBpmnStyles(modeler, currentTheme), 100);\n                return;\n            }\n            // Reuse existing style element or create new one\n            let style = styleElementRef.current;\n            if (!style) {\n                style = document.createElement(\"style\");\n                style.id = \"bpmn-custom-styles\";\n                styleElementRef.current = style;\n            }\n            // Define styles based on current theme\n            const isDark = currentTheme === \"dark\";\n            console.log(\"Applying BPMN styles for theme:\", currentTheme, \"isDark:\", isDark);\n            style.textContent = '\\n      /* Ensure proper pointer events for drag and drop */\\n      .djs-container {\\n        pointer-events: auto !important;\\n      }\\n      \\n      .djs-element > * {\\n        pointer-events: all !important;\\n      }\\n      \\n      .djs-hit {\\n        pointer-events: all !important;\\n        fill: transparent !important;\\n        stroke: transparent !important;\\n      }\\n      \\n      .djs-shape .djs-hit {\\n        fill: transparent !important;\\n        pointer-events: all !important;\\n      }\\n      \\n      .djs-drag-active {\\n        pointer-events: all !important;\\n      }\\n      \\n      /* === ACTIVITIES (Tasks, Sub-processes) === */\\n      \\n      /* Task rectangles - MAXIMUM SPECIFICITY */\\n      .djs-shape .djs-visual > rect,\\n      .djs-element[data-element-id*=\"Task\"] rect,\\n      .djs-element[data-element-id*=\"Activity\"] rect,\\n      rect.djs-hit,\\n      rect.djs-outline {\\n        stroke: '.concat(isDark ? \"#ffffff\" : \"#000000\", \" !important;\\n        stroke-dasharray: none !important;\\n        stroke-width: 2px !important;\\n        fill: \").concat(isDark ? \"#1f2937\" : \"#ffffff\", \" !important;\\n      }\\n      \\n      /* All rect elements in shapes (fallback) */\\n      .djs-shape rect {\\n        stroke: \").concat(isDark ? \"#ffffff\" : \"#000000\", \" !important;\\n        fill: \").concat(isDark ? \"#1f2937\" : \"#ffffff\", \" !important;\\n      }\\n      \\n      /* NUCLEAR OPTION: Override ANY rect with black stroke in dark mode */\\n      \").concat(isDark ? '\\n        rect[stroke=\"#000000\"],\\n        rect[stroke=\"black\"],\\n        rect[stroke=\"rgb(0, 0, 0)\"],\\n        rect[style*=\"stroke: rgb(0, 0, 0)\"],\\n        rect[style*=\"stroke:#000000\"],\\n        rect[style*=\"stroke: #000000\"],\\n        rect[style*=\"stroke:black\"] {\\n          stroke: #ffffff !important;\\n          stroke-opacity: 1 !important;\\n        }\\n        \\n        /* SUPER NUCLEAR: Target Tasks by ANY means necessary */\\n        g[data-element-id*=\"Task\"] rect,\\n        g[data-element-id*=\"Activity\"] rect,\\n        .djs-group[data-element-id*=\"Task\"] rect,\\n        g.djs-element rect,\\n        g.djs-shape rect,\\n        svg rect:not([fill=\"none\"]):not([fill=\"transparent\"]) {\\n          stroke: #ffffff !important;\\n          stroke-opacity: 1 !important;\\n          stroke-width: 2px !important;\\n        }\\n        \\n        /* Target the visual rect specifically */\\n        g[data-element-id*=\"Task\"] > .djs-visual > rect,\\n        g[data-element-id*=\"Activity\"] > .djs-visual > rect {\\n          stroke: #ffffff !important;\\n          fill: #1f2937 !important;\\n          stroke-opacity: 1 !important;\\n        }\\n      ' : \"\", '\\n      \\n      /* Task type icons (user, service, script, etc) */\\n      .djs-element[data-element-id*=\"Task\"] .djs-visual > path,\\n      .djs-element[data-element-id*=\"Task\"] .djs-visual > g > path {\\n        stroke: ').concat(isDark ? \"#ffffff\" : \"#000000\", \" !important;\\n        fill: \").concat(isDark ? \"#ffffff\" : \"#000000\", ' !important;\\n      }\\n      \\n      /* Sub-process markers (+) */\\n      .djs-element[data-element-id*=\"SubProcess\"] .djs-visual > path {\\n        stroke: ').concat(isDark ? \"#ffffff\" : \"#000000\", \" !important;\\n        fill: none !important;\\n      }\\n      \\n      /* === EVENTS === */\\n      \\n      /* Event circles (outer) */\\n      .djs-shape .djs-visual > circle {\\n        stroke: \").concat(isDark ? \"#ffffff\" : \"#000000\", \" !important;\\n        stroke-width: 2px !important;\\n        fill: \").concat(isDark ? \"#1f2937\" : \"#ffffff\", \" !important;\\n      }\\n      \\n      /* All circle elements in shapes (fallback) */\\n      .djs-shape circle {\\n        stroke: \").concat(isDark ? \"#ffffff\" : \"#000000\", \" !important;\\n        fill: \").concat(isDark ? \"#1f2937\" : \"#ffffff\", \" !important;\\n      }\\n      \\n      /* Event inner circles (for intermediate/boundary) */\\n      .djs-shape .djs-visual > g > circle {\\n        stroke: \").concat(isDark ? \"#ffffff\" : \"#000000\", \" !important;\\n        fill: \").concat(isDark ? \"#1f2937\" : \"#ffffff\", ' !important;\\n      }\\n      \\n      /* Event type icons (message, timer, error, signal, etc) */\\n      .djs-element[data-element-id*=\"Event\"] .djs-visual > g > path,\\n      .djs-element[data-element-id*=\"Event\"] .djs-visual > path {\\n        stroke: ').concat(isDark ? \"#ffffff\" : \"#000000\", \" !important;\\n        fill: \").concat(isDark ? \"#ffffff\" : \"#000000\", ' !important;\\n        stroke-width: 1px !important;\\n      }\\n      \\n      /* Boundary events (attached to activities) */\\n      .djs-element[data-element-id*=\"BoundaryEvent\"] .djs-visual > circle {\\n        stroke: ').concat(isDark ? \"#ffffff\" : \"#000000\", \" !important;\\n        fill: \").concat(isDark ? \"#1f2937\" : \"#ffffff\", \" !important;\\n      }\\n      \\n      /* === GATEWAYS === */\\n      \\n      /* Gateway diamonds */\\n      .djs-shape .djs-visual > polygon {\\n        stroke: \").concat(isDark ? \"#ffffff\" : \"#000000\", \" !important;\\n        stroke-width: 2px !important;\\n        fill: \").concat(isDark ? \"#1f2937\" : \"#ffffff\", \" !important;\\n      }\\n      \\n      /* All polygon elements in shapes (fallback) */\\n      .djs-shape polygon {\\n        stroke: \").concat(isDark ? \"#ffffff\" : \"#000000\", \" !important;\\n        fill: \").concat(isDark ? \"#1f2937\" : \"#ffffff\", ' !important;\\n      }\\n      \\n      /* Gateway symbols (X, +, O, etc) */\\n      .djs-element[data-element-id*=\"Gateway\"] .djs-visual > g > path,\\n      .djs-element[data-element-id*=\"Gateway\"] .djs-visual > path {\\n        stroke: ').concat(isDark ? \"#ffffff\" : \"#000000\", ' !important;\\n        fill: none !important;\\n        stroke-width: 2px !important;\\n      }\\n      \\n      /* Complex gateway star */\\n      .djs-element[data-element-id*=\"ComplexGateway\"] .djs-visual > path {\\n        fill: ').concat(isDark ? \"#ffffff\" : \"#000000\", \" !important;\\n        stroke: \").concat(isDark ? \"#ffffff\" : \"#000000\", ' !important;\\n      }\\n      \\n      /* === DATA OBJECTS === */\\n      \\n      /* Data object shapes */\\n      .djs-element[data-element-id*=\"DataObject\"] .djs-visual > path,\\n      .djs-element[data-element-id*=\"DataStore\"] .djs-visual > path {\\n        stroke: ').concat(isDark ? \"#ffffff\" : \"#000000\", \" !important;\\n        fill: \").concat(isDark ? \"#1f2937\" : \"#ffffff\", ' !important;\\n      }\\n      \\n      /* Data collection markers */\\n      .djs-element[data-element-id*=\"DataObject\"] .djs-visual > g > path {\\n        stroke: ').concat(isDark ? \"#ffffff\" : \"#000000\", ' !important;\\n        fill: none !important;\\n      }\\n      \\n      /* === PARTICIPANTS (Pools/Lanes) === */\\n      \\n      /* Pool/Lane containers */\\n      .djs-element[data-element-id*=\"Participant\"] .djs-visual > rect,\\n      .djs-element[data-element-id*=\"Lane\"] .djs-visual > rect {\\n        stroke: ').concat(isDark ? \"#ffffff\" : \"#000000\", \" !important;\\n        fill: \").concat(isDark ? \"#1f2937\" : \"#ffffff\", ' !important;\\n      }\\n      \\n      /* Pool/Lane headers */\\n      .djs-element[data-element-id*=\"Participant\"] .djs-visual > g > rect:first-child,\\n      .djs-element[data-element-id*=\"Lane\"] .djs-visual > g > rect:first-child {\\n        fill: ').concat(isDark ? \"#374151\" : \"#e5e7eb\", \" !important;\\n      }\\n      \\n      /* === CONNECTIONS === */\\n      \\n      /* Sequence flows and message flows */\\n      .djs-connection .djs-visual > path {\\n        stroke: \").concat(isDark ? \"#ffffff\" : \"#000000\", \" !important;\\n        fill: none !important;\\n      }\\n      \\n      /* Arrow heads */\\n      .djs-connection .djs-visual > polyline,\\n      .djs-connection .djs-visual > polygon {\\n        stroke: \").concat(isDark ? \"#ffffff\" : \"#000000\", \" !important;\\n        fill: \").concat(isDark ? \"#ffffff\" : \"#000000\", ' !important;\\n      }\\n      \\n      /* Association/Data association (dotted lines) */\\n      .djs-connection[data-element-id*=\"Association\"] .djs-visual > path {\\n        stroke: ').concat(isDark ? \"#ffffff\" : \"#000000\", ' !important;\\n        stroke-dasharray: 5, 5 !important;\\n      }\\n      \\n      /* Message flows (dashed lines) */\\n      .djs-connection[data-element-id*=\"MessageFlow\"] .djs-visual > path {\\n        stroke: ').concat(isDark ? \"#ffffff\" : \"#000000\", ' !important;\\n        stroke-dasharray: 10, 5 !important;\\n      }\\n      \\n      /* === ARTIFACTS === */\\n      \\n      /* Text annotations */\\n      .djs-element[data-element-id*=\"TextAnnotation\"] .djs-visual > rect {\\n        stroke: ').concat(isDark ? \"#ffffff\" : \"#000000\", ' !important;\\n        fill: none !important;\\n        stroke-dasharray: 5, 5 !important;\\n      }\\n      \\n      /* Groups */\\n      .djs-element[data-element-id*=\"Group\"] .djs-visual > rect {\\n        stroke: ').concat(isDark ? \"#ffffff\" : \"#000000\", \" !important;\\n        fill: none !important;\\n        stroke-dasharray: 8, 3, 1, 3 !important;\\n        stroke-width: 1px !important;\\n      }\\n      \\n      /* === TEXT LABELS === */\\n      \\n      /* All text elements */\\n      .djs-label,\\n      .djs-shape .djs-visual text,\\n      .djs-element text,\\n      text {\\n        fill: \").concat(isDark ? \"#ffffff\" : \"#000000\", \" !important;\\n      }\\n      \\n      /* Label backgrounds should be transparent */\\n      .djs-label .djs-visual rect {\\n        fill: transparent !important;\\n        stroke: none !important;\\n      }\\n      \\n      /* === GENERIC FALLBACKS === */\\n      \\n      /* Any other path elements */\\n      .djs-shape .djs-visual > path {\\n        stroke: \").concat(isDark ? \"#ffffff\" : \"#000000\", ' !important;\\n      }\\n      \\n      /* All paths with stroke attribute */\\n      path[stroke]:not([stroke=\"none\"]) {\\n        stroke: ').concat(isDark ? \"#ffffff\" : \"#000000\", \" !important;\\n      }\\n      \\n      /* All ellipse elements */\\n      ellipse {\\n        stroke: \").concat(isDark ? \"#ffffff\" : \"#000000\", \" !important;\\n        fill: \").concat(isDark ? \"#1f2937\" : \"#ffffff\", \" !important;\\n      }\\n      \\n      /* All line elements */\\n      line {\\n        stroke: \").concat(isDark ? \"#ffffff\" : \"#000000\", ' !important;\\n      }\\n      \\n      /* Filled path elements (icons, markers) */\\n      .djs-shape .djs-visual > g > path[fill]:not([fill=\"none\"]) {\\n        fill: ').concat(isDark ? \"#ffffff\" : \"#000000\", ' !important;\\n      }\\n      \\n      /* Catch all SVG shapes that might have black stroke in light mode */\\n      .djs-visual > *[stroke=\"#000000\"],\\n      .djs-visual > *[stroke=\"black\"],\\n      .djs-visual > *[stroke=\"rgb(0,0,0)\"],\\n      .djs-visual > *[stroke=\"rgb(0, 0, 0)\"] {\\n        stroke: ').concat(isDark ? \"#ffffff\" : \"#000000\", ' !important;\\n      }\\n      \\n      /* Catch all nested elements with black stroke */\\n      .djs-visual *[stroke=\"#000000\"],\\n      .djs-visual *[stroke=\"black\"],\\n      .djs-visual *[stroke=\"rgb(0,0,0)\"],\\n      .djs-visual *[stroke=\"rgb(0, 0, 0)\"] {\\n        stroke: ').concat(isDark ? \"#ffffff\" : \"#000000\", ' !important;\\n      }\\n      \\n      /* Catch all SVG shapes that might have white fill in light mode */\\n      .djs-visual > *[fill=\"#ffffff\"],\\n      .djs-visual > *[fill=\"white\"],\\n      .djs-visual > *[fill=\"rgb(255,255,255)\"],\\n      .djs-visual > *[fill=\"rgb(255, 255, 255)\"] {\\n        fill: ').concat(isDark ? \"#1f2937\" : \"#ffffff\", ' !important;\\n      }\\n      \\n      /* Catch all nested elements with white fill */\\n      .djs-visual *[fill=\"#ffffff\"],\\n      .djs-visual *[fill=\"white\"],\\n      .djs-visual *[fill=\"rgb(255,255,255)\"],\\n      .djs-visual *[fill=\"rgb(255, 255, 255)\"] {\\n        fill: ').concat(isDark ? \"#1f2937\" : \"#ffffff\", \" !important;\\n      }\\n      \\n      /* Direct editing text */\\n      .djs-direct-editing-parent {\\n        color: \").concat(isDark ? \"#ffffff\" : \"#000000\", \" !important;\\n        background: transparent !important;\\n      }\\n      \\n      .djs-direct-editing-content {\\n        color: \").concat(isDark ? \"#ffffff\" : \"#000000\", \" !important;\\n        background: transparent !important;\\n        caret-color: \").concat(isDark ? \"#ffffff\" : \"#000000\", ' !important;\\n      }\\n      \\n      /* Ensure the editing box itself is transparent */\\n      .djs-direct-editing-parent > div {\\n        background: transparent !important;\\n      }\\n      \\n      /* Contenteditable elements should be transparent */\\n      [contenteditable=\"true\"] {\\n        background: transparent !important;\\n        outline: none !important;\\n      }\\n      \\n      /* Focus state for editing */\\n      .djs-direct-editing-content:focus {\\n        background: transparent !important;\\n        outline: 1px dotted ').concat(isDark ? \"#60a5fa\" : \"#2563eb\", \" !important;\\n      }\\n      \\n      /* === SELECTION VISIBILITY FIX === */\\n      \\n      /* Selected element outline - make it highly visible */\\n      .djs-outline {\\n        stroke: \").concat(isDark ? \"#60a5fa\" : \"#2563eb\", \" !important;\\n        stroke-width: 3px !important;\\n        stroke-dasharray: 5, 5 !important;\\n        fill: none !important;\\n        fill-opacity: 0 !important;\\n        opacity: 1 !important;\\n      }\\n      \\n      /* Outline paths and polygons must be transparent */\\n      .djs-outline path,\\n      .djs-outline polygon,\\n      .djs-outline polyline,\\n      .djs-outline rect,\\n      .djs-outline circle,\\n      .djs-outline ellipse {\\n        fill: none !important;\\n        fill-opacity: 0 !important;\\n      }\\n      \\n      /* Selection box overlay - MUST BE TRANSPARENT */\\n      .djs-lasso-overlay {\\n        stroke: \").concat(isDark ? \"#60a5fa\" : \"#2563eb\", \" !important;\\n        stroke-width: 2px !important;\\n        fill: \").concat(isDark ? \"rgba(96, 165, 250, 0.1)\" : \"rgba(37, 99, 235, 0.1)\", \" !important;\\n        opacity: 1 !important;\\n      }\\n      \\n      /* Multi-select marquee - transparent background */\\n      .djs-marquee {\\n        fill: \").concat(isDark ? \"rgba(96, 165, 250, 0.1)\" : \"rgba(37, 99, 235, 0.1)\", \" !important;\\n        stroke: \").concat(isDark ? \"#60a5fa\" : \"#2563eb\", \" !important;\\n        stroke-width: 1px !important;\\n        stroke-dasharray: 5, 5 !important;\\n      }\\n      \\n      /* Selected elements get a highlight */\\n      .djs-element.selected .djs-outline {\\n        stroke: \").concat(isDark ? \"#60a5fa\" : \"#2563eb\", \" !important;\\n        stroke-width: 3px !important;\\n        opacity: 1 !important;\\n      }\\n      \\n      /* Hover state for better visibility */\\n      .djs-element.hover .djs-outline {\\n        stroke: \").concat(isDark ? \"#93c5fd\" : \"#60a5fa\", \" !important;\\n        stroke-width: 2px !important;\\n        opacity: 0.8 !important;\\n      }\\n      \\n      /* Selection frame around elements */\\n      .djs-select-visual {\\n        stroke: \").concat(isDark ? \"#60a5fa\" : \"#2563eb\", \" !important;\\n        stroke-width: 2px !important;\\n        stroke-dasharray: 5, 5 !important;\\n        fill: none !important;\\n      }\\n      \\n      /* Multi-selection visual */\\n      .djs-multiselect-visual {\\n        stroke: \").concat(isDark ? \"#60a5fa\" : \"#2563eb\", \" !important;\\n        stroke-width: 2px !important;\\n        fill: \").concat(isDark ? \"rgba(96, 165, 250, 0.05)\" : \"rgba(37, 99, 235, 0.05)\", \" !important;\\n      }\\n      \\n      /* Resize handles - small corner squares */\\n      .djs-resizer-visual,\\n      .djs-resizer-hit {\\n        stroke: \").concat(isDark ? \"#60a5fa\" : \"#2563eb\", \" !important;\\n        fill: transparent !important;\\n        opacity: 1 !important;\\n      }\\n      \\n      /* Resize handle corners - the actual squares */\\n      .djs-resizer-visual rect,\\n      .djs-resizer-hit rect {\\n        fill: \").concat(isDark ? \"#60a5fa\" : \"#2563eb\", \" !important;\\n        stroke: \").concat(isDark ? \"#ffffff\" : \"#000000\", \" !important;\\n        stroke-width: 1px !important;\\n        width: 6px !important;\\n        height: 6px !important;\\n      }\\n      \\n      /* Selection frame - MUST BE TRANSPARENT */\\n      .djs-selection-frame {\\n        fill: transparent !important;\\n        stroke: \").concat(isDark ? \"#60a5fa\" : \"#2563eb\", \" !important;\\n        stroke-width: 2px !important;\\n        stroke-dasharray: 5, 5 !important;\\n      }\\n      \\n      /* Selection visual box - TRANSPARENT BACKGROUND */\\n      .djs-selection-visual {\\n        fill: transparent !important;\\n        stroke: \").concat(isDark ? \"#60a5fa\" : \"#2563eb\", \" !important;\\n      }\\n      \\n      /* Selection overlay background - CRITICAL FIX */\\n      .djs-overlay-container .djs-overlay {\\n        background: transparent !important;\\n      }\\n      \\n      /* Any selection-related overlays must be transparent */\\n      .djs-overlay-container > * {\\n        background: transparent !important;\\n      }\\n      \\n      /* Lasso selection area */\\n      .djs-lasso-overlay rect {\\n        fill: \").concat(isDark ? \"rgba(96, 165, 250, 0.1)\" : \"rgba(37, 99, 235, 0.1)\", \" !important;\\n        stroke: \").concat(isDark ? \"#60a5fa\" : \"#2563eb\", \" !important;\\n      }\\n      \\n      /* Drag selection marquee box */\\n      .djs-drag-marquee {\\n        fill: \").concat(isDark ? \"rgba(96, 165, 250, 0.1)\" : \"rgba(37, 99, 235, 0.1)\", \" !important;\\n        stroke: \").concat(isDark ? \"#60a5fa\" : \"#2563eb\", \" !important;\\n        stroke-width: 1px !important;\\n        stroke-dasharray: 5, 5 !important;\\n      }\\n      \\n      /* Group selection frame */\\n      .djs-group-selector {\\n        fill: transparent !important;\\n        stroke: \").concat(isDark ? \"#60a5fa\" : \"#2563eb\", \" !important;\\n        stroke-width: 2px !important;\\n        stroke-dasharray: 5, 5 !important;\\n      }\\n      \\n      /* Selected state visual feedback */\\n      .selected > .djs-visual {\\n        filter: \").concat(isDark ? \"drop-shadow(0 0 4px rgba(96, 165, 250, 0.5))\" : \"drop-shadow(0 0 4px rgba(37, 99, 235, 0.3))\", \" !important;\\n      }\\n      \\n      /* Make sure selection doesn't hide elements */\\n      .djs-overlay {\\n        pointer-events: none !important;\\n      }\\n      \\n      .djs-overlay.djs-lasso-overlay {\\n        pointer-events: all !important;\\n      }\\n      \\n      /* AGGRESSIVE FIX: Force ALL selection rectangles to be transparent */\\n      .selected rect:not(.djs-visual rect) {\\n        fill: transparent !important;\\n      }\\n      \\n      /* Selection indicators should only be outlines */\\n      .djs-outline rect,\\n      .djs-selection rect,\\n      .djs-select rect {\\n        fill: transparent !important;\\n        stroke: \").concat(isDark ? \"#60a5fa\" : \"#2563eb\", ' !important;\\n        stroke-width: 2px !important;\\n      }\\n      \\n      /* Ensure no background on selection visuals */\\n      [class*=\"select\"] rect:not(.djs-visual rect) {\\n        fill: transparent !important;\\n      }\\n      \\n      /* Remove any fill from selection frames */\\n      .djs-frame rect {\\n        fill: transparent !important;\\n      }\\n      \\n      /* Canvas background - target multiple selectors for better coverage */\\n      .djs-container,\\n      .djs-container svg,\\n      .djs-viewport,\\n      .djs-plane {\\n        background-color: ').concat(isDark ? \"#111827\" : \"#f9fafb\", \" !important;\\n      }\\n      \\n      /* Grid pattern background */\\n      .grid-background {\\n        background-image: \\n          linear-gradient(\").concat(isDark ? \"rgba(255,255,255,0.03)\" : \"rgba(0,0,0,0.03)\", \" 1px, transparent 1px),\\n          linear-gradient(90deg, \").concat(isDark ? \"rgba(255,255,255,0.03)\" : \"rgba(0,0,0,0.03)\", \" 1px, transparent 1px);\\n        background-size: 20px 20px;\\n        background-position: 0 0, 0 0;\\n      }\\n      \\n      /* Apply grid to canvas when enabled */\\n      .djs-container.show-grid > svg {\\n        background-image: \\n          linear-gradient(\").concat(isDark ? \"rgba(255,255,255,0.05)\" : \"rgba(0,0,0,0.05)\", \" 1px, transparent 1px),\\n          linear-gradient(90deg, \").concat(isDark ? \"rgba(255,255,255,0.05)\" : \"rgba(0,0,0,0.05)\", \" 1px, transparent 1px);\\n        background-size: 20px 20px;\\n        background-position: 0 0, 0 0;\\n        background-color: \").concat(isDark ? \"#111827\" : \"#f9fafb\", \" !important;\\n      }\\n      \\n      /* Ensure the SVG itself has the right background */\\n      .djs-container > svg {\\n        background-color: \").concat(isDark ? \"#111827\" : \"#f9fafb\", \" !important;\\n      }\\n      \\n      /* Hide native BPMN.js palette since we use custom */\\n      .djs-palette {\\n        display: none !important;\\n      }\\n      \\n      /* === ULTIMATE FALLBACK - Catch ANY element that might be missed === */\\n      \\n      /* AGGRESSIVE: Force all strokes in djs elements */\\n      .djs-container svg * {\\n        stroke: \").concat(isDark ? \"#ffffff\" : \"#000000\", ' !important;\\n      }\\n      \\n      /* But preserve transparent strokes */\\n      .djs-container svg *[stroke=\"none\"],\\n      .djs-container svg *[stroke=\"transparent\"],\\n      .djs-container svg *[stroke-opacity=\"0\"] {\\n        stroke: transparent !important;\\n      }\\n      \\n      /* Force proper fills on basic shapes */\\n      .djs-container svg rect:not([fill=\"none\"]):not([fill=\"transparent\"]),\\n      .djs-container svg circle:not([fill=\"none\"]):not([fill=\"transparent\"]),\\n      .djs-container svg ellipse:not([fill=\"none\"]):not([fill=\"transparent\"]),\\n      .djs-container svg polygon:not([fill=\"none\"]):not([fill=\"transparent\"]) {\\n        fill: ').concat(isDark ? \"#1f2937\" : \"#ffffff\", \" !important;\\n      }\\n      \\n      /* Ensure text is always visible */\\n      .djs-container svg text,\\n      .djs-container svg tspan {\\n        fill: \").concat(isDark ? \"#ffffff\" : \"#000000\", \" !important;\\n      }\\n      \\n      /* SUPER AGGRESSIVE: Override ANY stroke attribute in dark mode */\\n      \").concat(isDark ? '\\n        .djs-container svg *:not([stroke=\"none\"]):not([stroke=\"transparent\"]) {\\n          stroke: #ffffff !important;\\n        }\\n        \\n        .djs-container svg path:not([stroke=\"none\"]):not([stroke=\"transparent\"]) {\\n          stroke: #ffffff !important;\\n        }\\n        \\n        .djs-container svg line:not([stroke=\"none\"]):not([stroke=\"transparent\"]) {\\n          stroke: #ffffff !important;\\n        }\\n        \\n        .djs-container svg polyline:not([stroke=\"none\"]):not([stroke=\"transparent\"]) {\\n          stroke: #ffffff !important;\\n        }\\n        \\n        .djs-container svg rect:not([stroke=\"none\"]):not([stroke=\"transparent\"]) {\\n          stroke: #ffffff !important;\\n        }\\n        \\n        .djs-container svg circle:not([stroke=\"none\"]):not([stroke=\"transparent\"]) {\\n          stroke: #ffffff !important;\\n        }\\n        \\n        .djs-container svg ellipse:not([stroke=\"none\"]):not([stroke=\"transparent\"]) {\\n          stroke: #ffffff !important;\\n        }\\n        \\n        .djs-container svg polygon:not([stroke=\"none\"]):not([stroke=\"transparent\"]) {\\n          stroke: #ffffff !important;\\n        }\\n      ' : '\\n        .djs-container svg *:not([stroke=\"none\"]):not([stroke=\"transparent\"]) {\\n          stroke: #000000 !important;\\n        }\\n      ', \"\\n    \");\n            // Only append if not already in DOM\n            if (!style.parentNode) {\n                document.head.appendChild(style);\n            }\n            // Also add class to the canvas container for CSS targeting\n            if (container) {\n                if (isDark) {\n                    container.classList.add(\"dark-mode\");\n                    container.classList.remove(\"light-mode\");\n                } else {\n                    container.classList.add(\"light-mode\");\n                    container.classList.remove(\"dark-mode\");\n                }\n                // Directly set background on container and SVG\n                container.style.backgroundColor = isDark ? \"#111827\" : \"#f9fafb\";\n                const svgElement = container.querySelector(\"svg\");\n                if (svgElement) {\n                    svgElement.style.backgroundColor = isDark ? \"#111827\" : \"#f9fafb\";\n                }\n            }\n            // Force a redraw - but check if eventBus exists\n            const eventBus = modeler.get(\"eventBus\");\n            if (eventBus) {\n                eventBus.fire(\"canvas.viewbox.changed\");\n            }\n            // AGGRESSIVE FALLBACK: Force color updates on ALL elements\n            const forceColorUpdate = ()=>{\n                const svgElements = document.querySelectorAll(\".djs-container svg *\");\n                svgElements.forEach((el)=>{\n                    var _el_tagName;\n                    const tagName = (_el_tagName = el.tagName) === null || _el_tagName === void 0 ? void 0 : _el_tagName.toLowerCase();\n                    // FORCE stroke colors\n                    if (el.hasAttribute(\"stroke\") || el.style.stroke) {\n                        const currentStroke = el.getAttribute(\"stroke\") || el.style.stroke;\n                        if (currentStroke && currentStroke !== \"none\" && currentStroke !== \"transparent\") {\n                            // Check if it's a black stroke in dark mode or white in light mode (needs fixing)\n                            const needsFix = isDark && (currentStroke === \"#000000\" || currentStroke === \"black\" || currentStroke === \"rgb(0, 0, 0)\") || !isDark && (currentStroke === \"#ffffff\" || currentStroke === \"white\" || currentStroke === \"rgb(255, 255, 255)\");\n                            if (needsFix || tagName === \"rect\" || tagName === \"circle\" || tagName === \"polygon\" || tagName === \"path\" || tagName === \"line\") {\n                                const newStroke = isDark ? \"#ffffff\" : \"#000000\";\n                                el.setAttribute(\"stroke\", newStroke);\n                                el.style.stroke = newStroke;\n                                el.style.strokeOpacity = \"1\";\n                            }\n                        }\n                    }\n                    // FORCE fill colors for shapes\n                    if (tagName === \"rect\" || tagName === \"circle\" || tagName === \"ellipse\" || tagName === \"polygon\") {\n                        const currentFill = el.getAttribute(\"fill\") || el.style.fill;\n                        if (currentFill && currentFill !== \"none\" && currentFill !== \"transparent\") {\n                            // Skip selection boxes\n                            if (!el.closest(\".djs-outline\") && !el.closest(\".djs-selection\")) {\n                                const newFill = isDark ? \"#1f2937\" : \"#ffffff\";\n                                el.setAttribute(\"fill\", newFill);\n                                el.style.fill = newFill;\n                            }\n                        }\n                    }\n                    // Text and icons\n                    if (tagName === \"text\" || tagName === \"tspan\") {\n                        const newColor = isDark ? \"#ffffff\" : \"#000000\";\n                        el.setAttribute(\"fill\", newColor);\n                        el.style.fill = newColor;\n                    }\n                });\n            };\n            // Run multiple times to catch all updates\n            forceColorUpdate();\n            setTimeout(forceColorUpdate, 50);\n            setTimeout(forceColorUpdate, 100);\n            setTimeout(forceColorUpdate, 200);\n            setTimeout(forceColorUpdate, 500);\n        } catch (err) {\n            console.error(\"Error applying BPMN styles:\", err);\n        }\n    }, []);\n    // Initialize BPMN Modeler\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        let mounted = true;\n        let modeler = null;\n        let observer = null;\n        const initBpmn = async ()=>{\n            const container = containerRef.current;\n            if (!container || !mounted) return;\n            try {\n                // Wait for container to have dimensions\n                if (container.offsetWidth === 0 || container.offsetHeight === 0) {\n                    setTimeout(initBpmn, 100);\n                    return;\n                }\n                // Create modeler with full default modules (including palette)\n                modeler = new bpmn_js_lib_Modeler__WEBPACK_IMPORTED_MODULE_6__[\"default\"]({\n                    container: container,\n                    keyboard: {\n                        bindTo: window\n                    },\n                    // Ensure all default modules are enabled\n                    additionalModules: [],\n                    moddleExtensions: {}\n                });\n                modelerRef.current = modeler;\n                // Import default diagram\n                await modeler.importXML(DEFAULT_BPMN);\n                // Wait a bit for canvas to be fully initialized\n                await new Promise((resolve)=>setTimeout(resolve, 50));\n                // Setup command stack listeners - with safety checks\n                const eventBus = modeler.get(\"eventBus\");\n                const commandStack = modeler.get(\"commandStack\");\n                if (!eventBus || !commandStack) {\n                    console.warn(\"BPMN modules not fully initialized, retrying...\");\n                    setTimeout(initBpmn, 100);\n                    return;\n                }\n                const updateUndoRedo = ()=>{\n                    if (!mounted) return;\n                    setCanUndo(commandStack.canUndo());\n                    setCanRedo(commandStack.canRedo());\n                };\n                eventBus.on(\"commandStack.changed\", updateUndoRedo);\n                updateUndoRedo();\n                // Track selection changes for alignment tools\n                const selection = modeler.get(\"selection\");\n                eventBus.on(\"selection.changed\", (e)=>{\n                    if (!mounted) return;\n                    const elements = e.newSelection || [];\n                    setSelectedElements(elements);\n                    // Apply visual feedback for selection\n                    if (elements.length > 0) {\n                        console.log(\"Selected \".concat(elements.length, \" element(s)\"));\n                        // FORCE TRANSPARENCY: Remove any opaque selection boxes\n                        setTimeout(()=>{\n                            const selectionBoxes = document.querySelectorAll('.djs-outline rect, .djs-selection rect, [class*=\"select\"] rect');\n                            selectionBoxes.forEach((box)=>{\n                                // Skip actual shape rectangles\n                                if (box.closest(\".djs-visual\")) return;\n                                // Force transparent fill\n                                box.style.fill = \"transparent\";\n                                box.style.fillOpacity = \"0\";\n                                box.setAttribute(\"fill\", \"none\");\n                                box.setAttribute(\"fill-opacity\", \"0\");\n                            });\n                            // Also check for any selection frames\n                            const frames = document.querySelectorAll(\".djs-frame, .djs-selection-frame, .djs-select-visual\");\n                            frames.forEach((frame)=>{\n                                if (frame.tagName === \"rect\" || frame.querySelector(\"rect\")) {\n                                    const rect = frame.tagName === \"rect\" ? frame : frame.querySelector(\"rect\");\n                                    if (rect && !rect.closest(\".djs-visual\")) {\n                                        rect.style.fill = \"transparent\";\n                                        rect.setAttribute(\"fill\", \"none\");\n                                    }\n                                }\n                            });\n                        }, 0);\n                    }\n                });\n                // Add keyboard shortcuts\n                const keyboard = modeler.get(\"keyboard\");\n                const editorActions = modeler.get(\"editorActions\");\n                if (keyboard && editorActions) {\n                    // Register Ctrl+A for select all\n                    editorActions.register(\"selectAll\", ()=>{\n                        const elementRegistry = modeler.get(\"elementRegistry\");\n                        const allElements = elementRegistry.filter((element)=>{\n                            return element.type !== \"label\" && element.type !== \"bpmn:SequenceFlow\" && element.id !== \"Process_1\" && !element.labelTarget;\n                        });\n                        selection.select(allElements);\n                        console.log(\"Selected all \".concat(allElements.length, \" elements\"));\n                    });\n                    // Register spacebar for replace menu\n                    editorActions.register(\"showReplaceMenu\", ()=>{\n                        const selectedElements = selection.get();\n                        if (selectedElements.length === 1) {\n                            const element = selectedElements[0];\n                            // Skip if it's the root element\n                            if (element.id === \"Process_1\" || element.type === \"bpmn:Process\") {\n                                return;\n                            }\n                            // Get the replace menu module\n                            const popupMenu = modeler.get(\"popupMenu\");\n                            const replaceMenuProvider = modeler.get(\"replaceMenuProvider\");\n                            if (popupMenu && replaceMenuProvider) {\n                                // Get the position of the selected element\n                                const elementRegistry = modeler.get(\"elementRegistry\");\n                                const elementShape = elementRegistry.get(element.id);\n                                if (elementShape) {\n                                    // Calculate position for the popup\n                                    const position = {\n                                        x: elementShape.x + (elementShape.width || 100) / 2,\n                                        y: elementShape.y - 10\n                                    };\n                                    // Get replace options for this element\n                                    const entries = replaceMenuProvider.getPopupMenuEntries(element);\n                                    if (entries && Object.keys(entries).length > 0) {\n                                        // Open the popup menu\n                                        popupMenu.open(element, \"bpmn-replace\", position, entries);\n                                        console.log(\"Replace menu opened for:\", element.type);\n                                    }\n                                }\n                            } else {\n                                // Fallback: Try to trigger the replace tool directly\n                                const replacePreview = modeler.get(\"replacePreview\");\n                                if (replacePreview) {\n                                    replacePreview.toggle();\n                                }\n                            }\n                        }\n                    });\n                    // Bind keyboard shortcuts\n                    keyboard.addListener((context)=>{\n                        const key = context.keyEvent.key;\n                        const ctrl = context.keyEvent.ctrlKey || context.keyEvent.metaKey;\n                        // Ctrl+A or Cmd+A for select all\n                        if (ctrl && key === \"a\") {\n                            editorActions.trigger(\"selectAll\");\n                            context.keyEvent.preventDefault();\n                            return true;\n                        }\n                        // Spacebar for replace menu\n                        if (key === \" \" && !ctrl && !context.keyEvent.shiftKey && !context.keyEvent.altKey) {\n                            // Check if we're not in a text input\n                            const activeElement = document.activeElement;\n                            if (activeElement && (activeElement.tagName === \"INPUT\" || activeElement.tagName === \"TEXTAREA\")) {\n                                return false;\n                            }\n                            editorActions.trigger(\"showReplaceMenu\");\n                            context.keyEvent.preventDefault();\n                            return true;\n                        }\n                        return false;\n                    });\n                }\n                // Apply initial styles\n                applyBpmnStyles(modeler, theme);\n                // Add a global keyboard listener for spacebar (fallback)\n                const handleGlobalKeydown = (e)=>{\n                    // Only handle spacebar when canvas is focused\n                    if (e.key === \" \" && !e.ctrlKey && !e.metaKey && !e.shiftKey && !e.altKey) {\n                        const activeElement = document.activeElement;\n                        // Skip if typing in an input\n                        if (activeElement && (activeElement.tagName === \"INPUT\" || activeElement.tagName === \"TEXTAREA\" || activeElement.getAttribute(\"contenteditable\") === \"true\")) {\n                            return;\n                        }\n                        // Check if the canvas or its container has focus\n                        const canvasElement = container.querySelector(\".djs-container\");\n                        if (canvasElement && (canvasElement.contains(activeElement) || activeElement === document.body)) {\n                            const selectedElements = selection.get();\n                            if (selectedElements.length === 1) {\n                                e.preventDefault();\n                                e.stopPropagation();\n                                const element = selectedElements[0];\n                                // Skip root element\n                                if (element.id === \"Process_1\" || element.type === \"bpmn:Process\") {\n                                    return;\n                                }\n                                console.log(\"Spacebar pressed with element selected:\", element.type);\n                                // Try to open replace menu\n                                const popupMenu = modeler.get(\"popupMenu\");\n                                const replaceMenuProvider = modeler.get(\"replaceMenuProvider\");\n                                if (popupMenu && replaceMenuProvider) {\n                                    const elementRegistry = modeler.get(\"elementRegistry\");\n                                    const elementShape = elementRegistry.get(element.id);\n                                    if (elementShape) {\n                                        const position = {\n                                            x: elementShape.x + (elementShape.width || 100) / 2,\n                                            y: elementShape.y - 10\n                                        };\n                                        const entries = replaceMenuProvider.getPopupMenuEntries(element);\n                                        if (entries && Object.keys(entries).length > 0) {\n                                            popupMenu.open(element, \"bpmn-replace\", position, entries);\n                                            console.log(\"Replace menu triggered via spacebar\");\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                };\n                // Attach the global listener\n                document.addEventListener(\"keydown\", handleGlobalKeydown);\n                // Store reference for cleanup\n                modelerRef.current._spacebarHandler = handleGlobalKeydown;\n                // Apply initial grid state\n                const canvas = modeler.get(\"canvas\");\n                const canvasContainer = canvas._container || canvas.getContainer();\n                if (canvasContainer && showGrid) {\n                    canvasContainer.classList.add(\"show-grid\");\n                }\n                // Set up MutationObserver to catch dynamically added elements\n                if (canvasContainer) {\n                    observer = new MutationObserver((mutations)=>{\n                        const currentTheme = document.documentElement.classList.contains(\"dark\") ? \"dark\" : \"light\";\n                        const isDarkMode = currentTheme === \"dark\";\n                        mutations.forEach((mutation)=>{\n                            // Process added nodes\n                            mutation.addedNodes.forEach((node)=>{\n                                if (node.nodeType === 1) {\n                                    // Process the node itself if it's an SVG element\n                                    if (node.tagName) {\n                                        const tagName = node.tagName.toLowerCase();\n                                        // IMMEDIATE fix for rectangles (Tasks)\n                                        if (tagName === \"rect\" || tagName === \"g\" || tagName === \"svg\") {\n                                            // Fix the node itself\n                                            if (tagName === \"rect\") {\n                                                node.style.stroke = isDarkMode ? \"#ffffff\" : \"#000000\";\n                                                node.setAttribute(\"stroke\", isDarkMode ? \"#ffffff\" : \"#000000\");\n                                                if (!node.closest(\".djs-outline\") && !node.closest(\".djs-selection\")) {\n                                                    node.style.fill = isDarkMode ? \"#1f2937\" : \"#ffffff\";\n                                                    node.setAttribute(\"fill\", isDarkMode ? \"#1f2937\" : \"#ffffff\");\n                                                }\n                                            }\n                                            // Fix all rect children\n                                            const rects = node.querySelectorAll ? node.querySelectorAll(\"rect\") : [];\n                                            rects.forEach((rect)=>{\n                                                rect.style.stroke = isDarkMode ? \"#ffffff\" : \"#000000\";\n                                                rect.setAttribute(\"stroke\", isDarkMode ? \"#ffffff\" : \"#000000\");\n                                                rect.style.strokeOpacity = \"1\";\n                                                if (!rect.closest(\".djs-outline\") && !rect.closest(\".djs-selection\")) {\n                                                    rect.style.fill = isDarkMode ? \"#1f2937\" : \"#ffffff\";\n                                                    rect.setAttribute(\"fill\", isDarkMode ? \"#1f2937\" : \"#ffffff\");\n                                                }\n                                            });\n                                        }\n                                        // Process all descendants\n                                        if (node.querySelectorAll) {\n                                            const elements = node.querySelectorAll(\"*\");\n                                            elements.forEach((el)=>{\n                                                var _el_tagName;\n                                                const elTag = (_el_tagName = el.tagName) === null || _el_tagName === void 0 ? void 0 : _el_tagName.toLowerCase();\n                                                // Force colors on all shape elements\n                                                if (elTag === \"rect\" || elTag === \"circle\" || elTag === \"polygon\" || elTag === \"path\" || elTag === \"line\") {\n                                                    if (el.hasAttribute(\"stroke\") || el.style.stroke) {\n                                                        el.style.stroke = isDarkMode ? \"#ffffff\" : \"#000000\";\n                                                        el.setAttribute(\"stroke\", isDarkMode ? \"#ffffff\" : \"#000000\");\n                                                        el.style.strokeOpacity = \"1\";\n                                                    }\n                                                    if ((elTag === \"rect\" || elTag === \"circle\" || elTag === \"polygon\") && !el.closest(\".djs-outline\") && !el.closest(\".djs-selection\")) {\n                                                        el.style.fill = isDarkMode ? \"#1f2937\" : \"#ffffff\";\n                                                        el.setAttribute(\"fill\", isDarkMode ? \"#1f2937\" : \"#ffffff\");\n                                                    }\n                                                }\n                                            });\n                                        }\n                                    }\n                                }\n                            });\n                            // Also check attribute changes for stroke/fill\n                            if (mutation.type === \"attributes\" && mutation.target) {\n                                const target = mutation.target;\n                                if (target.tagName) {\n                                    const tagName = target.tagName.toLowerCase();\n                                    if (tagName === \"rect\" && (mutation.attributeName === \"stroke\" || mutation.attributeName === \"style\")) {\n                                        // Force correct color if it was changed to wrong color\n                                        const currentStroke = target.getAttribute(\"stroke\") || target.style.stroke;\n                                        if (isDarkMode && (currentStroke === \"#000000\" || currentStroke === \"black\")) {\n                                            target.style.stroke = \"#ffffff\";\n                                            target.setAttribute(\"stroke\", \"#ffffff\");\n                                        }\n                                    }\n                                }\n                            }\n                        });\n                    });\n                    observer.observe(canvasContainer, {\n                        childList: true,\n                        subtree: true,\n                        attributes: true,\n                        attributeFilter: [\n                            \"stroke\",\n                            \"fill\",\n                            \"style\"\n                        ]\n                    });\n                }\n                setIsReady(true);\n                setError(null);\n            } catch (err) {\n                console.error(\"BPMN initialization error:\", err);\n                setError(err instanceof Error ? err.message : \"Failed to initialize\");\n            }\n        };\n        // Start initialization after a small delay\n        setTimeout(initBpmn, 100);\n        return ()=>{\n            mounted = false;\n            if (observer) {\n                observer.disconnect();\n            }\n            if (modeler) {\n                try {\n                    // Remove global keyboard handler\n                    if (modeler._spacebarHandler) {\n                        document.removeEventListener(\"keydown\", modeler._spacebarHandler);\n                    }\n                    modeler.destroy();\n                } catch (e) {\n                // Ignore cleanup errors\n                }\n            }\n        };\n    }, [\n        theme,\n        applyBpmnStyles\n    ]);\n    // Re-apply styles when theme changes\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (modelerRef.current && isReady) {\n            applyBpmnStyles(modelerRef.current, theme);\n            // Also update grid if it's enabled\n            const canvas = modelerRef.current.get(\"canvas\");\n            const container = (canvas === null || canvas === void 0 ? void 0 : canvas._container) || (canvas === null || canvas === void 0 ? void 0 : canvas.getContainer());\n            if (container && showGrid) {\n                container.classList.add(\"show-grid\");\n            }\n            // AGGRESSIVE: Continuous Task fix for stubborn elements\n            const fixTaskColors = ()=>{\n                const isDark = theme === \"dark\";\n                const tasks = document.querySelectorAll('[data-element-id*=\"Task\"]');\n                tasks.forEach((task)=>{\n                    const rects = task.querySelectorAll(\"rect\");\n                    rects.forEach((rect)=>{\n                        // Check current color\n                        const currentStroke = rect.getAttribute(\"stroke\") || rect.style.stroke;\n                        const needsFix = isDark ? currentStroke === \"#000000\" || currentStroke === \"black\" || currentStroke === \"rgb(0, 0, 0)\" : currentStroke === \"#ffffff\" || currentStroke === \"white\" || currentStroke === \"rgb(255, 255, 255)\";\n                        if (needsFix) {\n                            console.log(\"Fixing Task stroke:\", currentStroke, \"\", isDark ? \"#ffffff\" : \"#000000\");\n                            rect.setAttribute(\"stroke\", isDark ? \"#ffffff\" : \"#000000\");\n                            rect.style.stroke = isDark ? \"#ffffff\" : \"#000000\";\n                            rect.style.strokeOpacity = \"1\";\n                            if (!rect.closest(\".djs-outline\")) {\n                                rect.setAttribute(\"fill\", isDark ? \"#1f2937\" : \"#ffffff\");\n                                rect.style.fill = isDark ? \"#1f2937\" : \"#ffffff\";\n                            }\n                        }\n                    });\n                });\n            };\n            // Run multiple times to catch stubborn elements\n            const intervals = [\n                0,\n                100,\n                200,\n                500,\n                1000,\n                2000\n            ];\n            intervals.forEach((delay)=>{\n                setTimeout(fixTaskColors, delay);\n            });\n        }\n    }, [\n        theme,\n        isReady,\n        showGrid,\n        applyBpmnStyles\n    ]);\n    // Handlers\n    const handleSave = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(async ()=>{\n        if (!modelerRef.current) return;\n        setSaving(true);\n        try {\n            const { xml } = await modelerRef.current.saveXML({\n                format: true\n            });\n            localStorage.setItem(\"bpmn-diagram\", xml || \"\");\n            console.log(\"Saved to localStorage\");\n        } catch (err) {\n            console.error(\"Save error:\", err);\n        } finally{\n            setSaving(false);\n        }\n    }, []);\n    const handleExport = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(async ()=>{\n        if (!modelerRef.current) return;\n        try {\n            var _prompt;\n            const { xml } = await modelerRef.current.saveXML({\n                format: true\n            });\n            // Show export format options\n            const format = (_prompt = prompt(\"Export format: xml, json, or yaml?\", \"xml\")) === null || _prompt === void 0 ? void 0 : _prompt.toLowerCase();\n            let content = xml || \"\";\n            let filename = \"diagram.bpmn\";\n            let mimeType = \"text/xml\";\n            if (format === \"json\") {\n                var _xmlDoc_querySelector;\n                // Convert XML to JSON representation\n                const parser = new DOMParser();\n                const xmlDoc = parser.parseFromString(xml || \"\", \"text/xml\");\n                const jsonData = {\n                    type: \"bpmn:definitions\",\n                    process: ((_xmlDoc_querySelector = xmlDoc.querySelector(\"process\")) === null || _xmlDoc_querySelector === void 0 ? void 0 : _xmlDoc_querySelector.getAttribute(\"id\")) || \"Process_1\",\n                    elements: Array.from(xmlDoc.querySelectorAll(\"*[id]\")).map((el)=>({\n                            id: el.getAttribute(\"id\"),\n                            type: el.tagName,\n                            name: el.getAttribute(\"name\") || \"\"\n                        }))\n                };\n                content = JSON.stringify(jsonData, null, 2);\n                filename = \"diagram.json\";\n                mimeType = \"application/json\";\n            } else if (format === \"yaml\" || format === \"yml\") {\n                var _xmlDoc_querySelector1;\n                // Simple YAML conversion (would need proper library for production)\n                const parser = new DOMParser();\n                const xmlDoc = parser.parseFromString(xml || \"\", \"text/xml\");\n                let yamlContent = \"type: bpmn:definitions\\n\";\n                yamlContent += \"process: \".concat(((_xmlDoc_querySelector1 = xmlDoc.querySelector(\"process\")) === null || _xmlDoc_querySelector1 === void 0 ? void 0 : _xmlDoc_querySelector1.getAttribute(\"id\")) || \"Process_1\", \"\\n\");\n                yamlContent += \"elements:\\n\";\n                xmlDoc.querySelectorAll(\"*[id]\").forEach((el)=>{\n                    yamlContent += \"  - id: \".concat(el.getAttribute(\"id\"), \"\\n\");\n                    yamlContent += \"    type: \".concat(el.tagName, \"\\n\");\n                    const name = el.getAttribute(\"name\");\n                    if (name) yamlContent += \"    name: \".concat(name, \"\\n\");\n                });\n                content = yamlContent;\n                filename = \"diagram.yaml\";\n                mimeType = \"text/yaml\";\n            }\n            const blob = new Blob([\n                content\n            ], {\n                type: mimeType\n            });\n            const url = URL.createObjectURL(blob);\n            const a = document.createElement(\"a\");\n            a.href = url;\n            a.download = filename;\n            a.click();\n            URL.revokeObjectURL(url);\n        } catch (err) {\n            console.error(\"Export error:\", err);\n        }\n    }, []);\n    const handleImport = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((e)=>{\n        var _e_target_files;\n        const file = (_e_target_files = e.target.files) === null || _e_target_files === void 0 ? void 0 : _e_target_files[0];\n        if (!file || !modelerRef.current) return;\n        const reader = new FileReader();\n        reader.onload = async (event)=>{\n            try {\n                var _event_target, _file_name_split_pop, _modelerRef_current;\n                const content = (_event_target = event.target) === null || _event_target === void 0 ? void 0 : _event_target.result;\n                let xml = content;\n                // Check file extension to determine format\n                const ext = (_file_name_split_pop = file.name.split(\".\").pop()) === null || _file_name_split_pop === void 0 ? void 0 : _file_name_split_pop.toLowerCase();\n                if (ext === \"json\") {\n                    // Convert JSON back to BPMN XML (simplified)\n                    const jsonData = JSON.parse(content);\n                    xml = DEFAULT_BPMN // Start with default and modify\n                    ;\n                    console.log(\"Importing JSON format:\", jsonData);\n                    // Would need proper JSON to BPMN conversion\n                    alert(\"JSON import: Elements detected, using default template. Full JSON import requires custom parser.\");\n                } else if (ext === \"yaml\" || ext === \"yml\") {\n                    // Convert YAML back to BPMN XML (simplified)\n                    console.log(\"Importing YAML format\");\n                    xml = DEFAULT_BPMN // Start with default\n                    ;\n                    alert(\"YAML import: Using default template. Full YAML import requires yaml parser library.\");\n                }\n                await ((_modelerRef_current = modelerRef.current) === null || _modelerRef_current === void 0 ? void 0 : _modelerRef_current.importXML(xml));\n            } catch (err) {\n                console.error(\"Import error:\", err);\n                alert(\"Import failed: \" + (err instanceof Error ? err.message : \"Unknown error\"));\n            }\n        };\n        reader.readAsText(file);\n    }, []);\n    const handleUndo = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(()=>{\n        var _modelerRef_current;\n        const commandStack = (_modelerRef_current = modelerRef.current) === null || _modelerRef_current === void 0 ? void 0 : _modelerRef_current.get(\"commandStack\");\n        if (commandStack === null || commandStack === void 0 ? void 0 : commandStack.canUndo()) {\n            commandStack.undo();\n        }\n    }, []);\n    const handleRedo = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(()=>{\n        var _modelerRef_current;\n        const commandStack = (_modelerRef_current = modelerRef.current) === null || _modelerRef_current === void 0 ? void 0 : _modelerRef_current.get(\"commandStack\");\n        if (commandStack === null || commandStack === void 0 ? void 0 : commandStack.canRedo()) {\n            commandStack.redo();\n        }\n    }, []);\n    const handleZoomIn = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(()=>{\n        if (!modelerRef.current) return;\n        try {\n            var _canvas__container;\n            const canvas = modelerRef.current.get(\"canvas\");\n            if (!canvas) return;\n            // Ensure SVG context is available\n            const svg = canvas._svg || ((_canvas__container = canvas._container) === null || _canvas__container === void 0 ? void 0 : _canvas__container.querySelector(\"svg\"));\n            if (!svg || !svg.createSVGMatrix) {\n                console.warn(\"SVG not ready for zoom\");\n                return;\n            }\n            const currentZoom = canvas.zoom();\n            if (typeof currentZoom === \"number\") {\n                const newZoom = Math.min(currentZoom * 1.2, 4);\n                canvas.zoom(newZoom);\n                setZoomLevel(Math.round(newZoom * 100));\n            }\n        } catch (err) {\n            console.error(\"Zoom in error:\", err);\n        }\n    }, []);\n    const handleZoomOut = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(()=>{\n        if (!modelerRef.current) return;\n        try {\n            var _canvas__container;\n            const canvas = modelerRef.current.get(\"canvas\");\n            if (!canvas) return;\n            // Ensure SVG context is available\n            const svg = canvas._svg || ((_canvas__container = canvas._container) === null || _canvas__container === void 0 ? void 0 : _canvas__container.querySelector(\"svg\"));\n            if (!svg || !svg.createSVGMatrix) {\n                console.warn(\"SVG not ready for zoom\");\n                return;\n            }\n            const currentZoom = canvas.zoom();\n            if (typeof currentZoom === \"number\") {\n                const newZoom = Math.max(currentZoom / 1.2, 0.2);\n                canvas.zoom(newZoom);\n                setZoomLevel(Math.round(newZoom * 100));\n            }\n        } catch (err) {\n            console.error(\"Zoom out error:\", err);\n        }\n    }, []);\n    const handleZoomReset = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(()=>{\n        if (!modelerRef.current) return;\n        try {\n            var _canvas__container;\n            const canvas = modelerRef.current.get(\"canvas\");\n            if (!canvas) return;\n            // Ensure SVG context is available\n            const svg = canvas._svg || ((_canvas__container = canvas._container) === null || _canvas__container === void 0 ? void 0 : _canvas__container.querySelector(\"svg\"));\n            if (!svg || !svg.createSVGMatrix) {\n                console.warn(\"SVG not ready for zoom\");\n                return;\n            }\n            canvas.zoom(\"fit-viewport\");\n            setZoomLevel(100);\n        } catch (err) {\n            console.error(\"Zoom reset error:\", err);\n        }\n    }, []);\n    const handleClear = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(async ()=>{\n        if (!modelerRef.current) return;\n        if (confirm(\"Clear the entire diagram?\")) {\n            await modelerRef.current.importXML(DEFAULT_BPMN);\n        }\n    }, []);\n    const handleThemeToggle = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(()=>{\n        const newTheme = theme === \"light\" ? \"dark\" : \"light\";\n        console.log(\"Theme toggle:\", theme, \"->\", newTheme);\n        setTheme(newTheme) // ThemeProvider handles DOM manipulation\n        ;\n        // Re-apply BPMN styles with new theme\n        if (modelerRef.current) {\n            // Apply new styles (this will update the existing style element)\n            applyBpmnStyles(modelerRef.current, newTheme);\n            // IMMEDIATE: Force direct SVG manipulation for instant color change\n            const forceColorUpdate = ()=>{\n                const isDarkMode = newTheme === \"dark\";\n                const svgElements = document.querySelectorAll(\".djs-container svg *\");\n                svgElements.forEach((el)=>{\n                    // Update stroke attributes\n                    if (el.hasAttribute(\"stroke\")) {\n                        const stroke = el.getAttribute(\"stroke\");\n                        if (stroke && stroke !== \"none\" && stroke !== \"transparent\") {\n                            // Force white in dark mode, black in light mode\n                            el.style.stroke = isDarkMode ? \"#ffffff\" : \"#000000\";\n                            el.setAttribute(\"stroke\", isDarkMode ? \"#ffffff\" : \"#000000\");\n                        }\n                    }\n                    // Update fill attributes\n                    if (el.hasAttribute(\"fill\")) {\n                        const fill = el.getAttribute(\"fill\");\n                        if (fill && fill !== \"none\" && fill !== \"transparent\") {\n                            // Shapes get background color\n                            if (el.tagName === \"rect\" || el.tagName === \"circle\" || el.tagName === \"ellipse\" || el.tagName === \"polygon\") {\n                                el.style.fill = isDarkMode ? \"#1f2937\" : \"#ffffff\";\n                                el.setAttribute(\"fill\", isDarkMode ? \"#1f2937\" : \"#ffffff\");\n                            } else if (el.tagName === \"text\" || el.tagName === \"tspan\" || el.tagName === \"path\") {\n                                el.style.fill = isDarkMode ? \"#ffffff\" : \"#000000\";\n                                el.setAttribute(\"fill\", isDarkMode ? \"#ffffff\" : \"#000000\");\n                            }\n                        }\n                    }\n                    // Also set style attribute to override any inline styles\n                    if (el.tagName === \"rect\" || el.tagName === \"circle\" || el.tagName === \"ellipse\" || el.tagName === \"polygon\" || el.tagName === \"path\" || el.tagName === \"line\" || el.tagName === \"polyline\") {\n                        if (!el.getAttribute(\"stroke-opacity\") || el.getAttribute(\"stroke-opacity\") !== \"0\") {\n                            el.style.stroke = isDarkMode ? \"#ffffff\" : \"#000000\";\n                        }\n                    }\n                });\n            };\n            // Execute immediately and after a short delay\n            forceColorUpdate();\n            setTimeout(forceColorUpdate, 100);\n            setTimeout(forceColorUpdate, 300);\n            // Force a complete redraw using a safer method\n            try {\n                const canvas = modelerRef.current.get(\"canvas\");\n                const eventBus = modelerRef.current.get(\"eventBus\");\n                if (canvas && eventBus) {\n                    // Get the current viewbox to preserve position\n                    const viewbox = canvas.viewbox();\n                    // Directly update canvas container background\n                    const container = canvas._container || canvas.getContainer();\n                    if (container) {\n                        const bgColor = newTheme === \"dark\" ? \"#111827\" : \"#f9fafb\";\n                        container.style.backgroundColor = bgColor;\n                        // Update SVG background\n                        const svg = container.querySelector(\"svg\");\n                        if (svg) {\n                            svg.style.backgroundColor = bgColor;\n                        }\n                        // Update any viewport elements\n                        const viewport = container.querySelector(\".djs-viewport\");\n                        if (viewport) {\n                            viewport.style.backgroundColor = bgColor;\n                        }\n                        // Preserve grid state after theme change\n                        if (showGrid) {\n                            container.classList.add(\"show-grid\");\n                        }\n                    }\n                    // Simply trigger a canvas refresh without manipulating elements\n                    // The styles will be re-applied through the style element update\n                    requestAnimationFrame(()=>{\n                        if (eventBus) {\n                            // Just fire a viewbox change to refresh the rendering\n                            eventBus.fire(\"canvas.viewbox.changed\", viewbox);\n                        }\n                    });\n                }\n            } catch (err) {\n                console.error(\"Theme toggle redraw error:\", err);\n            }\n        }\n    }, [\n        theme,\n        applyBpmnStyles\n    ]);\n    // Alignment handlers\n    const handleAlignLeft = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(()=>{\n        if (!modelerRef.current || selectedElements.length < 2) return;\n        const modeling = modelerRef.current.get(\"modeling\");\n        const canvas = modelerRef.current.get(\"canvas\");\n        // Find leftmost element\n        const leftMost = selectedElements.reduce((min, el)=>el.x < min.x ? el : min, selectedElements[0]);\n        // Align all elements to leftmost\n        selectedElements.forEach((el)=>{\n            if (el.id !== leftMost.id) {\n                modeling.moveElements([\n                    el\n                ], {\n                    x: leftMost.x - el.x,\n                    y: 0\n                });\n            }\n        });\n    }, [\n        selectedElements\n    ]);\n    const handleAlignCenter = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(()=>{\n        if (!modelerRef.current || selectedElements.length < 2) return;\n        const modeling = modelerRef.current.get(\"modeling\");\n        // Calculate center position\n        const centerX = selectedElements.reduce((sum, el)=>sum + el.x + el.width / 2, 0) / selectedElements.length;\n        // Align all elements to center\n        selectedElements.forEach((el)=>{\n            const targetX = centerX - el.width / 2;\n            modeling.moveElements([\n                el\n            ], {\n                x: targetX - el.x,\n                y: 0\n            });\n        });\n    }, [\n        selectedElements\n    ]);\n    const handleAlignRight = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(()=>{\n        if (!modelerRef.current || selectedElements.length < 2) return;\n        const modeling = modelerRef.current.get(\"modeling\");\n        // Find rightmost element\n        const rightMost = selectedElements.reduce((max, el)=>el.x + el.width > max.x + max.width ? el : max, selectedElements[0]);\n        const rightEdge = rightMost.x + rightMost.width;\n        // Align all elements to rightmost\n        selectedElements.forEach((el)=>{\n            if (el.id !== rightMost.id) {\n                const targetX = rightEdge - el.width;\n                modeling.moveElements([\n                    el\n                ], {\n                    x: targetX - el.x,\n                    y: 0\n                });\n            }\n        });\n    }, [\n        selectedElements\n    ]);\n    const handleAlignTop = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(()=>{\n        if (!modelerRef.current || selectedElements.length < 2) return;\n        const modeling = modelerRef.current.get(\"modeling\");\n        // Find topmost element\n        const topMost = selectedElements.reduce((min, el)=>el.y < min.y ? el : min, selectedElements[0]);\n        // Align all elements to topmost\n        selectedElements.forEach((el)=>{\n            if (el.id !== topMost.id) {\n                modeling.moveElements([\n                    el\n                ], {\n                    x: 0,\n                    y: topMost.y - el.y\n                });\n            }\n        });\n    }, [\n        selectedElements\n    ]);\n    const handleAlignMiddle = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(()=>{\n        if (!modelerRef.current || selectedElements.length < 2) return;\n        const modeling = modelerRef.current.get(\"modeling\");\n        // Calculate middle position\n        const middleY = selectedElements.reduce((sum, el)=>sum + el.y + el.height / 2, 0) / selectedElements.length;\n        // Align all elements to middle\n        selectedElements.forEach((el)=>{\n            const targetY = middleY - el.height / 2;\n            modeling.moveElements([\n                el\n            ], {\n                x: 0,\n                y: targetY - el.y\n            });\n        });\n    }, [\n        selectedElements\n    ]);\n    const handleAlignBottom = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(()=>{\n        if (!modelerRef.current || selectedElements.length < 2) return;\n        const modeling = modelerRef.current.get(\"modeling\");\n        // Find bottommost element\n        const bottomMost = selectedElements.reduce((max, el)=>el.y + el.height > max.y + max.height ? el : max, selectedElements[0]);\n        const bottomEdge = bottomMost.y + bottomMost.height;\n        // Align all elements to bottommost\n        selectedElements.forEach((el)=>{\n            if (el.id !== bottomMost.id) {\n                const targetY = bottomEdge - el.height;\n                modeling.moveElements([\n                    el\n                ], {\n                    x: 0,\n                    y: targetY - el.y\n                });\n            }\n        });\n    }, [\n        selectedElements\n    ]);\n    // Preview handler - opens XML viewer modal\n    const handlePreview = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(async ()=>{\n        if (!modelerRef.current) return;\n        try {\n            const { xml } = await modelerRef.current.saveXML({\n                format: true\n            });\n            setCurrentXml(xml || \"\");\n            setShowXmlViewer(true);\n        } catch (err) {\n            console.error(\"Preview error:\", err);\n        }\n    }, []);\n    // Handle XML save from viewer\n    const handleXmlSave = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(async (newXml)=>{\n        if (!modelerRef.current) return;\n        try {\n            await modelerRef.current.importXML(newXml);\n            setShowXmlViewer(false);\n        } catch (err) {\n            console.error(\"XML import error:\", err);\n            alert(\"Failed to apply XML changes: \" + (err instanceof Error ? err.message : \"Unknown error\"));\n        }\n    }, []);\n    // Run Process handler (simulation)\n    const handleRunProcess = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(()=>{\n        if (!modelerRef.current) return;\n        console.log(\"Starting process simulation...\");\n        // This would integrate with a BPMN engine for execution\n        alert(\"Process simulation would start here. This requires integration with a BPMN engine.\");\n    }, []);\n    // Meeting/Presentation Mode handler\n    const handleMeetingMode = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(()=>{\n        setIsMeetingMode(!isMeetingMode);\n        if (!isMeetingMode) {\n            // Enter presentation mode - hide palette, maximize canvas\n            document.documentElement.requestFullscreen();\n        } else {\n            // Exit presentation mode\n            if (document.fullscreenElement) {\n                document.exitFullscreen();\n            }\n        }\n    }, [\n        isMeetingMode\n    ]);\n    // Minimap toggle handler\n    const handleToggleMinimap = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(()=>{\n        setIsMinimapOpen(!isMinimapOpen);\n        // BPMN.js doesn't have built-in minimap, would need custom implementation\n        console.log(\"Minimap toggle:\", !isMinimapOpen);\n    }, [\n        isMinimapOpen\n    ]);\n    // Language toggle handler\n    const handleToggleLanguage = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(()=>{\n        // Would implement i18n here\n        console.log(\"Language toggle - would implement i18n\");\n        alert(\"Language switching would be implemented with i18n library\");\n    }, []);\n    // Grid toggle handler\n    const handleToggleGrid = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(()=>{\n        setShowGrid((prev)=>{\n            const newValue = !prev;\n            // Apply or remove grid class to canvas container\n            if (modelerRef.current) {\n                const canvas = modelerRef.current.get(\"canvas\");\n                const container = canvas._container || canvas.getContainer();\n                if (container) {\n                    if (newValue) {\n                        container.classList.add(\"show-grid\");\n                    } else {\n                        container.classList.remove(\"show-grid\");\n                    }\n                }\n            }\n            return newValue;\n        });\n    }, []);\n    // Handle palette actions\n    const handlePaletteAction = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((action, event)=>{\n        if (!modelerRef.current) return;\n        console.log(\"Palette action:\", action);\n        // Handle tool actions\n        if (action.endsWith(\"-tool\")) {\n            setActiveTool(action.replace(\"-tool\", \"\"));\n            // Activate the tool in BPMN.js\n            const handTool = modelerRef.current.get(\"handTool\");\n            const lassoTool = modelerRef.current.get(\"lassoTool\");\n            const spaceTool = modelerRef.current.get(\"spaceTool\");\n            const globalConnect = modelerRef.current.get(\"globalConnect\");\n            switch(action){\n                case \"hand-tool\":\n                    handTool === null || handTool === void 0 ? void 0 : handTool.activateHand(event);\n                    break;\n                case \"lasso-tool\":\n                    lassoTool === null || lassoTool === void 0 ? void 0 : lassoTool.activateSelection(event);\n                    break;\n                case \"space-tool\":\n                    spaceTool === null || spaceTool === void 0 ? void 0 : spaceTool.activateSelection(event);\n                    break;\n                case \"global-connect-tool\":\n                    globalConnect === null || globalConnect === void 0 ? void 0 : globalConnect.toggle(event);\n                    break;\n            }\n            return;\n        }\n        // Handle element creation\n        if (action.startsWith(\"create.\")) {\n            const elementFactory = modelerRef.current.get(\"elementFactory\");\n            const create = modelerRef.current.get(\"create\");\n            const canvas = modelerRef.current.get(\"canvas\");\n            const modeling = modelerRef.current.get(\"modeling\");\n            // Parse the element type from action (keep original format)\n            const elementType = action.replace(\"create.\", \"\");\n            console.log(\"Creating element type:\", elementType);\n            let type = \"bpmn:Task\" // default\n            ;\n            let eventDefinitionType = undefined;\n            // Map all possible actions to BPMN types (matching registry actions)\n            const typeMap = {\n                // Start Events\n                \"start-event\": {\n                    type: \"bpmn:StartEvent\"\n                },\n                \"start-event-message\": {\n                    type: \"bpmn:StartEvent\",\n                    eventDefinitionType: \"bpmn:MessageEventDefinition\"\n                },\n                \"start-event-timer\": {\n                    type: \"bpmn:StartEvent\",\n                    eventDefinitionType: \"bpmn:TimerEventDefinition\"\n                },\n                \"start-event-conditional\": {\n                    type: \"bpmn:StartEvent\",\n                    eventDefinitionType: \"bpmn:ConditionalEventDefinition\"\n                },\n                \"start-event-signal\": {\n                    type: \"bpmn:StartEvent\",\n                    eventDefinitionType: \"bpmn:SignalEventDefinition\"\n                },\n                // End Events\n                \"end-event\": {\n                    type: \"bpmn:EndEvent\"\n                },\n                \"end-event-message\": {\n                    type: \"bpmn:EndEvent\",\n                    eventDefinitionType: \"bpmn:MessageEventDefinition\"\n                },\n                \"end-event-escalation\": {\n                    type: \"bpmn:EndEvent\",\n                    eventDefinitionType: \"bpmn:EscalationEventDefinition\"\n                },\n                \"end-event-error\": {\n                    type: \"bpmn:EndEvent\",\n                    eventDefinitionType: \"bpmn:ErrorEventDefinition\"\n                },\n                \"end-event-cancel\": {\n                    type: \"bpmn:EndEvent\",\n                    eventDefinitionType: \"bpmn:CancelEventDefinition\"\n                },\n                \"end-event-compensation\": {\n                    type: \"bpmn:EndEvent\",\n                    eventDefinitionType: \"bpmn:CompensateEventDefinition\"\n                },\n                \"end-event-signal\": {\n                    type: \"bpmn:EndEvent\",\n                    eventDefinitionType: \"bpmn:SignalEventDefinition\"\n                },\n                \"end-event-terminate\": {\n                    type: \"bpmn:EndEvent\",\n                    eventDefinitionType: \"bpmn:TerminateEventDefinition\"\n                },\n                // Intermediate Events\n                \"intermediate-event\": {\n                    type: \"bpmn:IntermediateThrowEvent\"\n                },\n                \"intermediate-event-message\": {\n                    type: \"bpmn:IntermediateThrowEvent\",\n                    eventDefinitionType: \"bpmn:MessageEventDefinition\"\n                },\n                \"intermediate-event-timer\": {\n                    type: \"bpmn:IntermediateCatchEvent\",\n                    eventDefinitionType: \"bpmn:TimerEventDefinition\"\n                },\n                \"intermediate-event-escalation\": {\n                    type: \"bpmn:IntermediateThrowEvent\",\n                    eventDefinitionType: \"bpmn:EscalationEventDefinition\"\n                },\n                \"intermediate-event-conditional\": {\n                    type: \"bpmn:IntermediateCatchEvent\",\n                    eventDefinitionType: \"bpmn:ConditionalEventDefinition\"\n                },\n                \"intermediate-event-link\": {\n                    type: \"bpmn:IntermediateThrowEvent\",\n                    eventDefinitionType: \"bpmn:LinkEventDefinition\"\n                },\n                \"intermediate-event-compensation\": {\n                    type: \"bpmn:IntermediateThrowEvent\",\n                    eventDefinitionType: \"bpmn:CompensateEventDefinition\"\n                },\n                \"intermediate-event-signal\": {\n                    type: \"bpmn:IntermediateThrowEvent\",\n                    eventDefinitionType: \"bpmn:SignalEventDefinition\"\n                },\n                // Tasks\n                \"task\": {\n                    type: \"bpmn:Task\"\n                },\n                \"user-task\": {\n                    type: \"bpmn:UserTask\"\n                },\n                \"service-task\": {\n                    type: \"bpmn:ServiceTask\"\n                },\n                \"script-task\": {\n                    type: \"bpmn:ScriptTask\"\n                },\n                \"business-rule-task\": {\n                    type: \"bpmn:BusinessRuleTask\"\n                },\n                \"send-task\": {\n                    type: \"bpmn:SendTask\"\n                },\n                \"receive-task\": {\n                    type: \"bpmn:ReceiveTask\"\n                },\n                \"manual-task\": {\n                    type: \"bpmn:ManualTask\"\n                },\n                // Gateways\n                \"exclusive-gateway\": {\n                    type: \"bpmn:ExclusiveGateway\"\n                },\n                \"parallel-gateway\": {\n                    type: \"bpmn:ParallelGateway\"\n                },\n                \"inclusive-gateway\": {\n                    type: \"bpmn:InclusiveGateway\"\n                },\n                \"event-based-gateway\": {\n                    type: \"bpmn:EventBasedGateway\"\n                },\n                \"complex-gateway\": {\n                    type: \"bpmn:ComplexGateway\"\n                },\n                // Sub Process\n                \"subprocess-expanded\": {\n                    type: \"bpmn:SubProcess\",\n                    isExpanded: true\n                },\n                \"subprocess-collapsed\": {\n                    type: \"bpmn:SubProcess\",\n                    isExpanded: false\n                },\n                \"event-subprocess\": {\n                    type: \"bpmn:SubProcess\",\n                    triggeredByEvent: true\n                },\n                \"transaction\": {\n                    type: \"bpmn:Transaction\"\n                },\n                \"call-activity\": {\n                    type: \"bpmn:CallActivity\"\n                },\n                // Data\n                \"data-object\": {\n                    type: \"bpmn:DataObjectReference\"\n                },\n                \"data-store\": {\n                    type: \"bpmn:DataStoreReference\"\n                },\n                \"data-input\": {\n                    type: \"bpmn:DataInput\"\n                },\n                \"data-output\": {\n                    type: \"bpmn:DataOutput\"\n                },\n                // Participants\n                \"participant-expanded\": {\n                    type: \"bpmn:Participant\"\n                },\n                \"participant\": {\n                    type: \"bpmn:Participant\"\n                },\n                \"lane\": {\n                    type: \"bpmn:Lane\"\n                },\n                // Artifacts\n                \"group\": {\n                    type: \"bpmn:Group\"\n                },\n                \"text-annotation\": {\n                    type: \"bpmn:TextAnnotation\"\n                }\n            };\n            const elementConfig = typeMap[elementType] || {\n                type: \"bpmn:Task\"\n            };\n            // Create the shape with proper configuration\n            const shapeConfig = {\n                type: elementConfig.type\n            };\n            // Add event definition if needed\n            if (elementConfig.eventDefinitionType) {\n                const bpmnFactory = modelerRef.current.get(\"bpmnFactory\");\n                const eventDefinition = bpmnFactory.create(elementConfig.eventDefinitionType);\n                shapeConfig.eventDefinitionType = elementConfig.eventDefinitionType;\n                shapeConfig.businessObject = bpmnFactory.create(elementConfig.type, {\n                    eventDefinitions: [\n                        eventDefinition\n                    ]\n                });\n            }\n            // Handle expanded/collapsed state\n            if (\"isExpanded\" in elementConfig) {\n                shapeConfig.isExpanded = elementConfig.isExpanded;\n            }\n            if (\"triggeredByEvent\" in elementConfig) {\n                shapeConfig.triggeredByEvent = elementConfig.triggeredByEvent;\n            }\n            const shape = elementFactory.createShape(shapeConfig);\n            // If it's a drag event, use drag coordinates\n            if (event instanceof DragEvent) {\n                console.log(\"Starting drag create for:\", elementType);\n                // For drag events, we need to let BPMN.js handle the drop\n                // The create module expects the drag event to continue\n                create.start(event, shape);\n            } else {\n                // For click events, directly create the shape at a position\n                console.log(\"Creating element via click:\", elementType);\n                const rootElement = canvas.getRootElement();\n                const viewport = canvas.viewbox();\n                // Calculate center position accounting for current zoom\n                const centerX = viewport.x + viewport.width / 2;\n                const centerY = viewport.y + viewport.height / 2;\n                // Directly create the shape using modeling\n                modeling.createShape(shape, {\n                    x: centerX,\n                    y: centerY\n                }, rootElement);\n            }\n        }\n    }, []);\n    if (error) {\n        return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n            className: \"h-screen flex items-center justify-center bg-gray-50\",\n            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"text-center\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h2\", {\n                        className: \"text-xl font-semibold text-red-600 mb-2\",\n                        children: \"Error Loading Studio\"\n                    }, void 0, false, {\n                        fileName: \"/Users/home/Desktop/mvp/components/bpmn/BpmnStudioFixed.tsx\",\n                        lineNumber: 1870,\n                        columnNumber: 11\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                        className: \"text-gray-600\",\n                        children: error\n                    }, void 0, false, {\n                        fileName: \"/Users/home/Desktop/mvp/components/bpmn/BpmnStudioFixed.tsx\",\n                        lineNumber: 1871,\n                        columnNumber: 11\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                        onClick: ()=>window.location.reload(),\n                        className: \"mt-4 px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700\",\n                        children: \"Reload Page\"\n                    }, void 0, false, {\n                        fileName: \"/Users/home/Desktop/mvp/components/bpmn/BpmnStudioFixed.tsx\",\n                        lineNumber: 1872,\n                        columnNumber: 11\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/home/Desktop/mvp/components/bpmn/BpmnStudioFixed.tsx\",\n                lineNumber: 1869,\n                columnNumber: 9\n            }, this)\n        }, void 0, false, {\n            fileName: \"/Users/home/Desktop/mvp/components/bpmn/BpmnStudioFixed.tsx\",\n            lineNumber: 1868,\n            columnNumber: 7\n        }, this);\n    }\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"h-screen flex flex-col bg-background\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_bpmn_toolbar__WEBPACK_IMPORTED_MODULE_2__.BpmnToolbar, {\n                onSave: handleSave,\n                onExport: handleExport,\n                onImport: ()=>{\n                    var _fileInputRef_current;\n                    return (_fileInputRef_current = fileInputRef.current) === null || _fileInputRef_current === void 0 ? void 0 : _fileInputRef_current.click();\n                },\n                onUndo: handleUndo,\n                onRedo: handleRedo,\n                onZoomIn: handleZoomIn,\n                onZoomOut: handleZoomOut,\n                onFitToViewport: handleZoomReset,\n                onClear: handleClear,\n                onToggleTheme: handleThemeToggle,\n                onAlignLeft: handleAlignLeft,\n                onAlignCenter: handleAlignCenter,\n                onAlignRight: handleAlignRight,\n                onAlignTop: handleAlignTop,\n                onAlignMiddle: handleAlignMiddle,\n                onAlignBottom: handleAlignBottom,\n                onPreview: handlePreview,\n                onRun: handleRunProcess,\n                onMeetingMode: handleMeetingMode,\n                onToggleMinimap: handleToggleMinimap,\n                onToggleLanguage: handleToggleLanguage,\n                onToggleGrid: handleToggleGrid,\n                theme: theme,\n                zoomLevel: zoomLevel,\n                canUndo: canUndo,\n                canRedo: canRedo,\n                disabled: saving,\n                isMeetingMode: isMeetingMode,\n                isMinimapOpen: isMinimapOpen,\n                showGrid: showGrid\n            }, void 0, false, {\n                fileName: \"/Users/home/Desktop/mvp/components/bpmn/BpmnStudioFixed.tsx\",\n                lineNumber: 1886,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"flex-1 flex overflow-hidden\",\n                children: [\n                    !isMeetingMode && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_bpmn_elements_palette__WEBPACK_IMPORTED_MODULE_3__.BpmnElementsPalette, {\n                        onAction: handlePaletteAction,\n                        activeTool: activeTool\n                    }, void 0, false, {\n                        fileName: \"/Users/home/Desktop/mvp/components/bpmn/BpmnStudioFixed.tsx\",\n                        lineNumber: 1923,\n                        columnNumber: 11\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"flex-1 relative bg-gray-50 dark:bg-gray-900\",\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                ref: containerRef,\n                                className: \"w-full h-full\",\n                                style: {\n                                    position: \"absolute\",\n                                    top: 0,\n                                    left: 0,\n                                    right: 0,\n                                    bottom: 0\n                                }\n                            }, void 0, false, {\n                                fileName: \"/Users/home/Desktop/mvp/components/bpmn/BpmnStudioFixed.tsx\",\n                                lineNumber: 1931,\n                                columnNumber: 11\n                            }, this),\n                            !isReady && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"absolute inset-0 flex items-center justify-center bg-gray-50/90 dark:bg-gray-900/90 pointer-events-none\",\n                                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                    className: \"text-center\",\n                                    children: [\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                            className: \"animate-spin rounded-full h-12 w-12 border-b-2 border-blue-600 mx-auto\"\n                                        }, void 0, false, {\n                                            fileName: \"/Users/home/Desktop/mvp/components/bpmn/BpmnStudioFixed.tsx\",\n                                            lineNumber: 1945,\n                                            columnNumber: 17\n                                        }, this),\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                            className: \"mt-4 text-gray-600 dark:text-gray-400\",\n                                            children: \"Initializing BPMN Studio...\"\n                                        }, void 0, false, {\n                                            fileName: \"/Users/home/Desktop/mvp/components/bpmn/BpmnStudioFixed.tsx\",\n                                            lineNumber: 1946,\n                                            columnNumber: 17\n                                        }, this)\n                                    ]\n                                }, void 0, true, {\n                                    fileName: \"/Users/home/Desktop/mvp/components/bpmn/BpmnStudioFixed.tsx\",\n                                    lineNumber: 1944,\n                                    columnNumber: 15\n                                }, this)\n                            }, void 0, false, {\n                                fileName: \"/Users/home/Desktop/mvp/components/bpmn/BpmnStudioFixed.tsx\",\n                                lineNumber: 1943,\n                                columnNumber: 13\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/Users/home/Desktop/mvp/components/bpmn/BpmnStudioFixed.tsx\",\n                        lineNumber: 1930,\n                        columnNumber: 9\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/home/Desktop/mvp/components/bpmn/BpmnStudioFixed.tsx\",\n                lineNumber: 1920,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                ref: fileInputRef,\n                type: \"file\",\n                accept: \".bpmn,.xml\",\n                onChange: handleImport,\n                className: \"hidden\"\n            }, void 0, false, {\n                fileName: \"/Users/home/Desktop/mvp/components/bpmn/BpmnStudioFixed.tsx\",\n                lineNumber: 1954,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_XmlViewerModal__WEBPACK_IMPORTED_MODULE_4__.XmlViewerModal, {\n                isOpen: showXmlViewer,\n                onClose: ()=>setShowXmlViewer(false),\n                xml: currentXml,\n                onSave: handleXmlSave,\n                readOnly: false\n            }, void 0, false, {\n                fileName: \"/Users/home/Desktop/mvp/components/bpmn/BpmnStudioFixed.tsx\",\n                lineNumber: 1963,\n                columnNumber: 7\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/home/Desktop/mvp/components/bpmn/BpmnStudioFixed.tsx\",\n        lineNumber: 1884,\n        columnNumber: 5\n    }, this);\n}\n_s(BpmnStudioFixed, \"5Zl8qrJMddFoghqgo2Pl6g6tzYk=\", false, function() {\n    return [\n        _components_theme_provider__WEBPACK_IMPORTED_MODULE_5__.useTheme\n    ];\n});\n_c = BpmnStudioFixed;\nvar _c;\n$RefreshReg$(_c, \"BpmnStudioFixed\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2NvbXBvbmVudHMvYnBtbi9CcG1uU3R1ZGlvRml4ZWQudHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBRWdFO0FBQ25CO0FBQ0Q7QUFDaUI7QUFDWjtBQUNLO0FBRXRELGdEQUFnRDtBQUVoRCxNQUFNUyxlQUFnQjtBQW9CZixTQUFTQzs7SUFDZCxNQUFNQyxlQUFlViw2Q0FBTUEsQ0FBaUI7SUFDNUMsTUFBTVcsYUFBYVgsNkNBQU1BLENBQXFCO0lBQzlDLE1BQU1ZLGVBQWVaLDZDQUFNQSxDQUFtQjtJQUU5QyxNQUFNLENBQUNhLFNBQVNDLFdBQVcsR0FBR2IsK0NBQVFBLENBQUM7SUFDdkMsTUFBTSxDQUFDYyxPQUFPQyxTQUFTLEdBQUdmLCtDQUFRQSxDQUFnQjtJQUNsRCxNQUFNLENBQUNnQixTQUFTQyxXQUFXLEdBQUdqQiwrQ0FBUUEsQ0FBQztJQUN2QyxNQUFNLENBQUNrQixTQUFTQyxXQUFXLEdBQUduQiwrQ0FBUUEsQ0FBQztJQUN2QyxNQUFNLEVBQUVvQixLQUFLLEVBQUVDLFFBQVEsRUFBRSxHQUFHZixvRUFBUUE7SUFDcEMsTUFBTWdCLGtCQUFrQnZCLDZDQUFNQSxDQUEwQjtJQUN4RCxNQUFNLENBQUN3QixXQUFXQyxhQUFhLEdBQUd4QiwrQ0FBUUEsQ0FBQztJQUMzQyxNQUFNLENBQUN5QixRQUFRQyxVQUFVLEdBQUcxQiwrQ0FBUUEsQ0FBQztJQUNyQyxNQUFNLENBQUMyQixZQUFZQyxjQUFjLEdBQUc1QiwrQ0FBUUEsQ0FBcUI2QjtJQUNqRSxNQUFNLENBQUNDLGVBQWVDLGlCQUFpQixHQUFHL0IsK0NBQVFBLENBQUM7SUFDbkQsTUFBTSxDQUFDZ0MsZUFBZUMsaUJBQWlCLEdBQUdqQywrQ0FBUUEsQ0FBQztJQUNuRCxNQUFNLENBQUNrQyxVQUFVQyxZQUFZLEdBQUduQywrQ0FBUUEsQ0FBQztJQUN6QyxNQUFNLENBQUNvQyxhQUFhQyxlQUFlLEdBQUdyQywrQ0FBUUEsQ0FBQztJQUMvQyxN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cy9icG1uL0JwbW5TdHVkaW9GaXhlZC50c3g/Yzk2YyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCdcblxuaW1wb3J0IHsgdXNlRWZmZWN0LCB1c2VSZWYsIHVzZVN0YXRlLCB1c2VDYWxsYmFjayB9IGZyb20gJ3JlYWN0J1xuaW1wb3J0IEJwbW5Nb2RlbGVyIGZyb20gJ2JwbW4tanMvbGliL01vZGVsZXInXG5pbXBvcnQgeyBCcG1uVG9vbGJhciB9IGZyb20gJy4vYnBtbi10b29sYmFyJ1xuaW1wb3J0IHsgQnBtbkVsZW1lbnRzUGFsZXR0ZSB9IGZyb20gJy4vYnBtbi1lbGVtZW50cy1wYWxldHRlJ1xuaW1wb3J0IHsgWG1sVmlld2VyTW9kYWwgfSBmcm9tICcuL1htbFZpZXdlck1vZGFsJ1xuaW1wb3J0IHsgdXNlVGhlbWUgfSBmcm9tICdAL2NvbXBvbmVudHMvdGhlbWUtcHJvdmlkZXInXG5cbi8vIE5PIENTUyBpbXBvcnRzIGhlcmUgLSB0aGV5IGFyZSBpbiBnbG9iYWxzLmNzc1xuXG5jb25zdCBERUZBVUxUX0JQTU4gPSBgPD94bWwgdmVyc2lvbj1cIjEuMFwiIGVuY29kaW5nPVwiVVRGLThcIj8+XG48YnBtbjI6ZGVmaW5pdGlvbnMgeG1sbnM6eHNpPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMS9YTUxTY2hlbWEtaW5zdGFuY2VcIiBcbiAgeG1sbnM6YnBtbjI9XCJodHRwOi8vd3d3Lm9tZy5vcmcvc3BlYy9CUE1OLzIwMTAwNTI0L01PREVMXCIgXG4gIHhtbG5zOmJwbW5kaT1cImh0dHA6Ly93d3cub21nLm9yZy9zcGVjL0JQTU4vMjAxMDA1MjQvRElcIiBcbiAgeG1sbnM6ZGM9XCJodHRwOi8vd3d3Lm9tZy5vcmcvc3BlYy9ERC8yMDEwMDUyNC9EQ1wiIFxuICB4bWxuczpkaT1cImh0dHA6Ly93d3cub21nLm9yZy9zcGVjL0RELzIwMTAwNTI0L0RJXCIgXG4gIGlkPVwic2FtcGxlLWRpYWdyYW1cIiBcbiAgdGFyZ2V0TmFtZXNwYWNlPVwiaHR0cDovL2JwbW4uaW8vc2NoZW1hL2JwbW5cIj5cbiAgPGJwbW4yOnByb2Nlc3MgaWQ9XCJQcm9jZXNzXzFcIiBpc0V4ZWN1dGFibGU9XCJmYWxzZVwiPlxuICAgIDxicG1uMjpzdGFydEV2ZW50IGlkPVwiU3RhcnRFdmVudF8xXCIgbmFtZT1cIlN0YXJ0XCIvPlxuICA8L2JwbW4yOnByb2Nlc3M+XG4gIDxicG1uZGk6QlBNTkRpYWdyYW0gaWQ9XCJCUE1ORGlhZ3JhbV8xXCI+XG4gICAgPGJwbW5kaTpCUE1OUGxhbmUgaWQ9XCJCUE1OUGxhbmVfMVwiIGJwbW5FbGVtZW50PVwiUHJvY2Vzc18xXCI+XG4gICAgICA8YnBtbmRpOkJQTU5TaGFwZSBpZD1cIl9CUE1OU2hhcGVfU3RhcnRFdmVudF8yXCIgYnBtbkVsZW1lbnQ9XCJTdGFydEV2ZW50XzFcIj5cbiAgICAgICAgPGRjOkJvdW5kcyBoZWlnaHQ9XCIzNi4wXCIgd2lkdGg9XCIzNi4wXCIgeD1cIjQxMi4wXCIgeT1cIjI0MC4wXCIvPlxuICAgICAgPC9icG1uZGk6QlBNTlNoYXBlPlxuICAgIDwvYnBtbmRpOkJQTU5QbGFuZT5cbiAgPC9icG1uZGk6QlBNTkRpYWdyYW0+XG48L2JwbW4yOmRlZmluaXRpb25zPmBcblxuZXhwb3J0IGZ1bmN0aW9uIEJwbW5TdHVkaW9GaXhlZCgpIHtcbiAgY29uc3QgY29udGFpbmVyUmVmID0gdXNlUmVmPEhUTUxEaXZFbGVtZW50PihudWxsKVxuICBjb25zdCBtb2RlbGVyUmVmID0gdXNlUmVmPEJwbW5Nb2RlbGVyIHwgbnVsbD4obnVsbClcbiAgY29uc3QgZmlsZUlucHV0UmVmID0gdXNlUmVmPEhUTUxJbnB1dEVsZW1lbnQ+KG51bGwpXG4gIFxuICBjb25zdCBbaXNSZWFkeSwgc2V0SXNSZWFkeV0gPSB1c2VTdGF0ZShmYWxzZSlcbiAgY29uc3QgW2Vycm9yLCBzZXRFcnJvcl0gPSB1c2VTdGF0ZTxzdHJpbmcgfCBudWxsPihudWxsKVxuICBjb25zdCBbY2FuVW5kbywgc2V0Q2FuVW5kb10gPSB1c2VTdGF0ZShmYWxzZSlcbiAgY29uc3QgW2NhblJlZG8sIHNldENhblJlZG9dID0gdXNlU3RhdGUoZmFsc2UpXG4gIGNvbnN0IHsgdGhlbWUsIHNldFRoZW1lIH0gPSB1c2VUaGVtZSgpXG4gIGNvbnN0IHN0eWxlRWxlbWVudFJlZiA9IHVzZVJlZjxIVE1MU3R5bGVFbGVtZW50IHwgbnVsbD4obnVsbClcbiAgY29uc3QgW3pvb21MZXZlbCwgc2V0Wm9vbUxldmVsXSA9IHVzZVN0YXRlKDEwMClcbiAgY29uc3QgW3NhdmluZywgc2V0U2F2aW5nXSA9IHVzZVN0YXRlKGZhbHNlKVxuICBjb25zdCBbYWN0aXZlVG9vbCwgc2V0QWN0aXZlVG9vbF0gPSB1c2VTdGF0ZTxzdHJpbmcgfCB1bmRlZmluZWQ+KHVuZGVmaW5lZClcbiAgY29uc3QgW2lzTWVldGluZ01vZGUsIHNldElzTWVldGluZ01vZGVdID0gdXNlU3RhdGUoZmFsc2UpXG4gIGNvbnN0IFtpc01pbmltYXBPcGVuLCBzZXRJc01pbmltYXBPcGVuXSA9IHVzZVN0YXRlKGZhbHNlKVxuICBjb25zdCBbc2hvd0dyaWQsIHNldFNob3dHcmlkXSA9IHVzZVN0YXRlKHRydWUpXG4gIGNvbnN0IFtzaG93UHJldmlldywgc2V0U2hvd1ByZXZpZXddID0gdXNlU3RhdGUoZmFsc2UpXG4gIGNvbnN0IFtzaG93WG1sVmlld2VyLCBzZXRTaG93WG1sVmlld2VyXSA9IHVzZVN0YXRlKGZhbHNlKVxuICBjb25zdCBbY3VycmVudFhtbCwgc2V0Q3VycmVudFhtbF0gPSB1c2VTdGF0ZSgnJylcbiAgY29uc3QgW3NlbGVjdGVkRWxlbWVudHMsIHNldFNlbGVjdGVkRWxlbWVudHNdID0gdXNlU3RhdGU8YW55W10+KFtdKVxuXG4gIC8vIEhlbHBlciBmdW5jdGlvbiB0byBhcHBseSBzdHlsZXMgKG5lZWRzIHRvIGJlIGRlZmluZWQgYmVmb3JlIHVzZUVmZmVjdClcbiAgY29uc3QgYXBwbHlCcG1uU3R5bGVzID0gdXNlQ2FsbGJhY2soKG1vZGVsZXI6IEJwbW5Nb2RlbGVyIHwgbnVsbCwgY3VycmVudFRoZW1lOiAnbGlnaHQnIHwgJ2RhcmsnKSA9PiB7XG4gICAgaWYgKCFtb2RlbGVyKSByZXR1cm5cbiAgICBcbiAgICB0cnkge1xuICAgICAgY29uc3QgY2FudmFzID0gbW9kZWxlci5nZXQoJ2NhbnZhcycpIGFzIGFueVxuICAgICAgaWYgKCFjYW52YXMpIHJldHVyblxuICAgICAgXG4gICAgICAvLyBHZXQgdGhlIGNvbnRhaW5lciBhbmQgZW5zdXJlIFNWRyBpcyBhdmFpbGFibGVcbiAgICAgIGNvbnN0IGNvbnRhaW5lciA9IGNhbnZhcy5fY29udGFpbmVyIHx8IGNhbnZhcy5nZXRDb250YWluZXIoKVxuICAgICAgY29uc3Qgc3ZnID0gY29udGFpbmVyPy5xdWVyeVNlbGVjdG9yKCdzdmcnKSB8fCBjYW52YXMuX3N2Z1xuICAgICAgXG4gICAgICAvLyBDaGVjayBpZiBTVkcgZWxlbWVudCBleGlzdHMgYW5kIGhhcyBuZWNlc3NhcnkgbWV0aG9kc1xuICAgICAgaWYgKCFzdmcgfHwgdHlwZW9mIHN2Zy5jcmVhdGVTVkdNYXRyaXggIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdTVkcgZWxlbWVudCBub3QgcmVhZHksIGRlbGF5aW5nIHN0eWxlIGFwcGxpY2F0aW9uJylcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiBhcHBseUJwbW5TdHlsZXMobW9kZWxlciwgY3VycmVudFRoZW1lKSwgMTAwKVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gUmV1c2UgZXhpc3Rpbmcgc3R5bGUgZWxlbWVudCBvciBjcmVhdGUgbmV3IG9uZVxuICAgICAgbGV0IHN0eWxlID0gc3R5bGVFbGVtZW50UmVmLmN1cnJlbnRcbiAgICAgIGlmICghc3R5bGUpIHtcbiAgICAgICAgc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpXG4gICAgICAgIHN0eWxlLmlkID0gJ2JwbW4tY3VzdG9tLXN0eWxlcydcbiAgICAgICAgc3R5bGVFbGVtZW50UmVmLmN1cnJlbnQgPSBzdHlsZVxuICAgICAgfVxuICAgIFxuICAgIC8vIERlZmluZSBzdHlsZXMgYmFzZWQgb24gY3VycmVudCB0aGVtZVxuICAgIGNvbnN0IGlzRGFyayA9IGN1cnJlbnRUaGVtZSA9PT0gJ2RhcmsnXG4gICAgY29uc29sZS5sb2coJ0FwcGx5aW5nIEJQTU4gc3R5bGVzIGZvciB0aGVtZTonLCBjdXJyZW50VGhlbWUsICdpc0Rhcms6JywgaXNEYXJrKVxuICAgIFxuICAgIHN0eWxlLnRleHRDb250ZW50ID0gYFxuICAgICAgLyogRW5zdXJlIHByb3BlciBwb2ludGVyIGV2ZW50cyBmb3IgZHJhZyBhbmQgZHJvcCAqL1xuICAgICAgLmRqcy1jb250YWluZXIge1xuICAgICAgICBwb2ludGVyLWV2ZW50czogYXV0byAhaW1wb3J0YW50O1xuICAgICAgfVxuICAgICAgXG4gICAgICAuZGpzLWVsZW1lbnQgPiAqIHtcbiAgICAgICAgcG9pbnRlci1ldmVudHM6IGFsbCAhaW1wb3J0YW50O1xuICAgICAgfVxuICAgICAgXG4gICAgICAuZGpzLWhpdCB7XG4gICAgICAgIHBvaW50ZXItZXZlbnRzOiBhbGwgIWltcG9ydGFudDtcbiAgICAgICAgZmlsbDogdHJhbnNwYXJlbnQgIWltcG9ydGFudDtcbiAgICAgICAgc3Ryb2tlOiB0cmFuc3BhcmVudCAhaW1wb3J0YW50O1xuICAgICAgfVxuICAgICAgXG4gICAgICAuZGpzLXNoYXBlIC5kanMtaGl0IHtcbiAgICAgICAgZmlsbDogdHJhbnNwYXJlbnQgIWltcG9ydGFudDtcbiAgICAgICAgcG9pbnRlci1ldmVudHM6IGFsbCAhaW1wb3J0YW50O1xuICAgICAgfVxuICAgICAgXG4gICAgICAuZGpzLWRyYWctYWN0aXZlIHtcbiAgICAgICAgcG9pbnRlci1ldmVudHM6IGFsbCAhaW1wb3J0YW50O1xuICAgICAgfVxuICAgICAgXG4gICAgICAvKiA9PT0gQUNUSVZJVElFUyAoVGFza3MsIFN1Yi1wcm9jZXNzZXMpID09PSAqL1xuICAgICAgXG4gICAgICAvKiBUYXNrIHJlY3RhbmdsZXMgLSBNQVhJTVVNIFNQRUNJRklDSVRZICovXG4gICAgICAuZGpzLXNoYXBlIC5kanMtdmlzdWFsID4gcmVjdCxcbiAgICAgIC5kanMtZWxlbWVudFtkYXRhLWVsZW1lbnQtaWQqPVwiVGFza1wiXSByZWN0LFxuICAgICAgLmRqcy1lbGVtZW50W2RhdGEtZWxlbWVudC1pZCo9XCJBY3Rpdml0eVwiXSByZWN0LFxuICAgICAgcmVjdC5kanMtaGl0LFxuICAgICAgcmVjdC5kanMtb3V0bGluZSB7XG4gICAgICAgIHN0cm9rZTogJHtpc0RhcmsgPyAnI2ZmZmZmZicgOiAnIzAwMDAwMCd9ICFpbXBvcnRhbnQ7XG4gICAgICAgIHN0cm9rZS1kYXNoYXJyYXk6IG5vbmUgIWltcG9ydGFudDtcbiAgICAgICAgc3Ryb2tlLXdpZHRoOiAycHggIWltcG9ydGFudDtcbiAgICAgICAgZmlsbDogJHtpc0RhcmsgPyAnIzFmMjkzNycgOiAnI2ZmZmZmZid9ICFpbXBvcnRhbnQ7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8qIEFsbCByZWN0IGVsZW1lbnRzIGluIHNoYXBlcyAoZmFsbGJhY2spICovXG4gICAgICAuZGpzLXNoYXBlIHJlY3Qge1xuICAgICAgICBzdHJva2U6ICR7aXNEYXJrID8gJyNmZmZmZmYnIDogJyMwMDAwMDAnfSAhaW1wb3J0YW50O1xuICAgICAgICBmaWxsOiAke2lzRGFyayA/ICcjMWYyOTM3JyA6ICcjZmZmZmZmJ30gIWltcG9ydGFudDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLyogTlVDTEVBUiBPUFRJT046IE92ZXJyaWRlIEFOWSByZWN0IHdpdGggYmxhY2sgc3Ryb2tlIGluIGRhcmsgbW9kZSAqL1xuICAgICAgJHtpc0RhcmsgPyBgXG4gICAgICAgIHJlY3Rbc3Ryb2tlPVwiIzAwMDAwMFwiXSxcbiAgICAgICAgcmVjdFtzdHJva2U9XCJibGFja1wiXSxcbiAgICAgICAgcmVjdFtzdHJva2U9XCJyZ2IoMCwgMCwgMClcIl0sXG4gICAgICAgIHJlY3Rbc3R5bGUqPVwic3Ryb2tlOiByZ2IoMCwgMCwgMClcIl0sXG4gICAgICAgIHJlY3Rbc3R5bGUqPVwic3Ryb2tlOiMwMDAwMDBcIl0sXG4gICAgICAgIHJlY3Rbc3R5bGUqPVwic3Ryb2tlOiAjMDAwMDAwXCJdLFxuICAgICAgICByZWN0W3N0eWxlKj1cInN0cm9rZTpibGFja1wiXSB7XG4gICAgICAgICAgc3Ryb2tlOiAjZmZmZmZmICFpbXBvcnRhbnQ7XG4gICAgICAgICAgc3Ryb2tlLW9wYWNpdHk6IDEgIWltcG9ydGFudDtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLyogU1VQRVIgTlVDTEVBUjogVGFyZ2V0IFRhc2tzIGJ5IEFOWSBtZWFucyBuZWNlc3NhcnkgKi9cbiAgICAgICAgZ1tkYXRhLWVsZW1lbnQtaWQqPVwiVGFza1wiXSByZWN0LFxuICAgICAgICBnW2RhdGEtZWxlbWVudC1pZCo9XCJBY3Rpdml0eVwiXSByZWN0LFxuICAgICAgICAuZGpzLWdyb3VwW2RhdGEtZWxlbWVudC1pZCo9XCJUYXNrXCJdIHJlY3QsXG4gICAgICAgIGcuZGpzLWVsZW1lbnQgcmVjdCxcbiAgICAgICAgZy5kanMtc2hhcGUgcmVjdCxcbiAgICAgICAgc3ZnIHJlY3Q6bm90KFtmaWxsPVwibm9uZVwiXSk6bm90KFtmaWxsPVwidHJhbnNwYXJlbnRcIl0pIHtcbiAgICAgICAgICBzdHJva2U6ICNmZmZmZmYgIWltcG9ydGFudDtcbiAgICAgICAgICBzdHJva2Utb3BhY2l0eTogMSAhaW1wb3J0YW50O1xuICAgICAgICAgIHN0cm9rZS13aWR0aDogMnB4ICFpbXBvcnRhbnQ7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8qIFRhcmdldCB0aGUgdmlzdWFsIHJlY3Qgc3BlY2lmaWNhbGx5ICovXG4gICAgICAgIGdbZGF0YS1lbGVtZW50LWlkKj1cIlRhc2tcIl0gPiAuZGpzLXZpc3VhbCA+IHJlY3QsXG4gICAgICAgIGdbZGF0YS1lbGVtZW50LWlkKj1cIkFjdGl2aXR5XCJdID4gLmRqcy12aXN1YWwgPiByZWN0IHtcbiAgICAgICAgICBzdHJva2U6ICNmZmZmZmYgIWltcG9ydGFudDtcbiAgICAgICAgICBmaWxsOiAjMWYyOTM3ICFpbXBvcnRhbnQ7XG4gICAgICAgICAgc3Ryb2tlLW9wYWNpdHk6IDEgIWltcG9ydGFudDtcbiAgICAgICAgfVxuICAgICAgYCA6ICcnfVxuICAgICAgXG4gICAgICAvKiBUYXNrIHR5cGUgaWNvbnMgKHVzZXIsIHNlcnZpY2UsIHNjcmlwdCwgZXRjKSAqL1xuICAgICAgLmRqcy1lbGVtZW50W2RhdGEtZWxlbWVudC1pZCo9XCJUYXNrXCJdIC5kanMtdmlzdWFsID4gcGF0aCxcbiAgICAgIC5kanMtZWxlbWVudFtkYXRhLWVsZW1lbnQtaWQqPVwiVGFza1wiXSAuZGpzLXZpc3VhbCA+IGcgPiBwYXRoIHtcbiAgICAgICAgc3Ryb2tlOiAke2lzRGFyayA/ICcjZmZmZmZmJyA6ICcjMDAwMDAwJ30gIWltcG9ydGFudDtcbiAgICAgICAgZmlsbDogJHtpc0RhcmsgPyAnI2ZmZmZmZicgOiAnIzAwMDAwMCd9ICFpbXBvcnRhbnQ7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8qIFN1Yi1wcm9jZXNzIG1hcmtlcnMgKCspICovXG4gICAgICAuZGpzLWVsZW1lbnRbZGF0YS1lbGVtZW50LWlkKj1cIlN1YlByb2Nlc3NcIl0gLmRqcy12aXN1YWwgPiBwYXRoIHtcbiAgICAgICAgc3Ryb2tlOiAke2lzRGFyayA/ICcjZmZmZmZmJyA6ICcjMDAwMDAwJ30gIWltcG9ydGFudDtcbiAgICAgICAgZmlsbDogbm9uZSAhaW1wb3J0YW50O1xuICAgICAgfVxuICAgICAgXG4gICAgICAvKiA9PT0gRVZFTlRTID09PSAqL1xuICAgICAgXG4gICAgICAvKiBFdmVudCBjaXJjbGVzIChvdXRlcikgKi9cbiAgICAgIC5kanMtc2hhcGUgLmRqcy12aXN1YWwgPiBjaXJjbGUge1xuICAgICAgICBzdHJva2U6ICR7aXNEYXJrID8gJyNmZmZmZmYnIDogJyMwMDAwMDAnfSAhaW1wb3J0YW50O1xuICAgICAgICBzdHJva2Utd2lkdGg6IDJweCAhaW1wb3J0YW50O1xuICAgICAgICBmaWxsOiAke2lzRGFyayA/ICcjMWYyOTM3JyA6ICcjZmZmZmZmJ30gIWltcG9ydGFudDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLyogQWxsIGNpcmNsZSBlbGVtZW50cyBpbiBzaGFwZXMgKGZhbGxiYWNrKSAqL1xuICAgICAgLmRqcy1zaGFwZSBjaXJjbGUge1xuICAgICAgICBzdHJva2U6ICR7aXNEYXJrID8gJyNmZmZmZmYnIDogJyMwMDAwMDAnfSAhaW1wb3J0YW50O1xuICAgICAgICBmaWxsOiAke2lzRGFyayA/ICcjMWYyOTM3JyA6ICcjZmZmZmZmJ30gIWltcG9ydGFudDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLyogRXZlbnQgaW5uZXIgY2lyY2xlcyAoZm9yIGludGVybWVkaWF0ZS9ib3VuZGFyeSkgKi9cbiAgICAgIC5kanMtc2hhcGUgLmRqcy12aXN1YWwgPiBnID4gY2lyY2xlIHtcbiAgICAgICAgc3Ryb2tlOiAke2lzRGFyayA/ICcjZmZmZmZmJyA6ICcjMDAwMDAwJ30gIWltcG9ydGFudDtcbiAgICAgICAgZmlsbDogJHtpc0RhcmsgPyAnIzFmMjkzNycgOiAnI2ZmZmZmZid9ICFpbXBvcnRhbnQ7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8qIEV2ZW50IHR5cGUgaWNvbnMgKG1lc3NhZ2UsIHRpbWVyLCBlcnJvciwgc2lnbmFsLCBldGMpICovXG4gICAgICAuZGpzLWVsZW1lbnRbZGF0YS1lbGVtZW50LWlkKj1cIkV2ZW50XCJdIC5kanMtdmlzdWFsID4gZyA+IHBhdGgsXG4gICAgICAuZGpzLWVsZW1lbnRbZGF0YS1lbGVtZW50LWlkKj1cIkV2ZW50XCJdIC5kanMtdmlzdWFsID4gcGF0aCB7XG4gICAgICAgIHN0cm9rZTogJHtpc0RhcmsgPyAnI2ZmZmZmZicgOiAnIzAwMDAwMCd9ICFpbXBvcnRhbnQ7XG4gICAgICAgIGZpbGw6ICR7aXNEYXJrID8gJyNmZmZmZmYnIDogJyMwMDAwMDAnfSAhaW1wb3J0YW50O1xuICAgICAgICBzdHJva2Utd2lkdGg6IDFweCAhaW1wb3J0YW50O1xuICAgICAgfVxuICAgICAgXG4gICAgICAvKiBCb3VuZGFyeSBldmVudHMgKGF0dGFjaGVkIHRvIGFjdGl2aXRpZXMpICovXG4gICAgICAuZGpzLWVsZW1lbnRbZGF0YS1lbGVtZW50LWlkKj1cIkJvdW5kYXJ5RXZlbnRcIl0gLmRqcy12aXN1YWwgPiBjaXJjbGUge1xuICAgICAgICBzdHJva2U6ICR7aXNEYXJrID8gJyNmZmZmZmYnIDogJyMwMDAwMDAnfSAhaW1wb3J0YW50O1xuICAgICAgICBmaWxsOiAke2lzRGFyayA/ICcjMWYyOTM3JyA6ICcjZmZmZmZmJ30gIWltcG9ydGFudDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLyogPT09IEdBVEVXQVlTID09PSAqL1xuICAgICAgXG4gICAgICAvKiBHYXRld2F5IGRpYW1vbmRzICovXG4gICAgICAuZGpzLXNoYXBlIC5kanMtdmlzdWFsID4gcG9seWdvbiB7XG4gICAgICAgIHN0cm9rZTogJHtpc0RhcmsgPyAnI2ZmZmZmZicgOiAnIzAwMDAwMCd9ICFpbXBvcnRhbnQ7XG4gICAgICAgIHN0cm9rZS13aWR0aDogMnB4ICFpbXBvcnRhbnQ7XG4gICAgICAgIGZpbGw6ICR7aXNEYXJrID8gJyMxZjI5MzcnIDogJyNmZmZmZmYnfSAhaW1wb3J0YW50O1xuICAgICAgfVxuICAgICAgXG4gICAgICAvKiBBbGwgcG9seWdvbiBlbGVtZW50cyBpbiBzaGFwZXMgKGZhbGxiYWNrKSAqL1xuICAgICAgLmRqcy1zaGFwZSBwb2x5Z29uIHtcbiAgICAgICAgc3Ryb2tlOiAke2lzRGFyayA/ICcjZmZmZmZmJyA6ICcjMDAwMDAwJ30gIWltcG9ydGFudDtcbiAgICAgICAgZmlsbDogJHtpc0RhcmsgPyAnIzFmMjkzNycgOiAnI2ZmZmZmZid9ICFpbXBvcnRhbnQ7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8qIEdhdGV3YXkgc3ltYm9scyAoWCwgKywgTywgZXRjKSAqL1xuICAgICAgLmRqcy1lbGVtZW50W2RhdGEtZWxlbWVudC1pZCo9XCJHYXRld2F5XCJdIC5kanMtdmlzdWFsID4gZyA+IHBhdGgsXG4gICAgICAuZGpzLWVsZW1lbnRbZGF0YS1lbGVtZW50LWlkKj1cIkdhdGV3YXlcIl0gLmRqcy12aXN1YWwgPiBwYXRoIHtcbiAgICAgICAgc3Ryb2tlOiAke2lzRGFyayA/ICcjZmZmZmZmJyA6ICcjMDAwMDAwJ30gIWltcG9ydGFudDtcbiAgICAgICAgZmlsbDogbm9uZSAhaW1wb3J0YW50O1xuICAgICAgICBzdHJva2Utd2lkdGg6IDJweCAhaW1wb3J0YW50O1xuICAgICAgfVxuICAgICAgXG4gICAgICAvKiBDb21wbGV4IGdhdGV3YXkgc3RhciAqL1xuICAgICAgLmRqcy1lbGVtZW50W2RhdGEtZWxlbWVudC1pZCo9XCJDb21wbGV4R2F0ZXdheVwiXSAuZGpzLXZpc3VhbCA+IHBhdGgge1xuICAgICAgICBmaWxsOiAke2lzRGFyayA/ICcjZmZmZmZmJyA6ICcjMDAwMDAwJ30gIWltcG9ydGFudDtcbiAgICAgICAgc3Ryb2tlOiAke2lzRGFyayA/ICcjZmZmZmZmJyA6ICcjMDAwMDAwJ30gIWltcG9ydGFudDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLyogPT09IERBVEEgT0JKRUNUUyA9PT0gKi9cbiAgICAgIFxuICAgICAgLyogRGF0YSBvYmplY3Qgc2hhcGVzICovXG4gICAgICAuZGpzLWVsZW1lbnRbZGF0YS1lbGVtZW50LWlkKj1cIkRhdGFPYmplY3RcIl0gLmRqcy12aXN1YWwgPiBwYXRoLFxuICAgICAgLmRqcy1lbGVtZW50W2RhdGEtZWxlbWVudC1pZCo9XCJEYXRhU3RvcmVcIl0gLmRqcy12aXN1YWwgPiBwYXRoIHtcbiAgICAgICAgc3Ryb2tlOiAke2lzRGFyayA/ICcjZmZmZmZmJyA6ICcjMDAwMDAwJ30gIWltcG9ydGFudDtcbiAgICAgICAgZmlsbDogJHtpc0RhcmsgPyAnIzFmMjkzNycgOiAnI2ZmZmZmZid9ICFpbXBvcnRhbnQ7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8qIERhdGEgY29sbGVjdGlvbiBtYXJrZXJzICovXG4gICAgICAuZGpzLWVsZW1lbnRbZGF0YS1lbGVtZW50LWlkKj1cIkRhdGFPYmplY3RcIl0gLmRqcy12aXN1YWwgPiBnID4gcGF0aCB7XG4gICAgICAgIHN0cm9rZTogJHtpc0RhcmsgPyAnI2ZmZmZmZicgOiAnIzAwMDAwMCd9ICFpbXBvcnRhbnQ7XG4gICAgICAgIGZpbGw6IG5vbmUgIWltcG9ydGFudDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLyogPT09IFBBUlRJQ0lQQU5UUyAoUG9vbHMvTGFuZXMpID09PSAqL1xuICAgICAgXG4gICAgICAvKiBQb29sL0xhbmUgY29udGFpbmVycyAqL1xuICAgICAgLmRqcy1lbGVtZW50W2RhdGEtZWxlbWVudC1pZCo9XCJQYXJ0aWNpcGFudFwiXSAuZGpzLXZpc3VhbCA+IHJlY3QsXG4gICAgICAuZGpzLWVsZW1lbnRbZGF0YS1lbGVtZW50LWlkKj1cIkxhbmVcIl0gLmRqcy12aXN1YWwgPiByZWN0IHtcbiAgICAgICAgc3Ryb2tlOiAke2lzRGFyayA/ICcjZmZmZmZmJyA6ICcjMDAwMDAwJ30gIWltcG9ydGFudDtcbiAgICAgICAgZmlsbDogJHtpc0RhcmsgPyAnIzFmMjkzNycgOiAnI2ZmZmZmZid9ICFpbXBvcnRhbnQ7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8qIFBvb2wvTGFuZSBoZWFkZXJzICovXG4gICAgICAuZGpzLWVsZW1lbnRbZGF0YS1lbGVtZW50LWlkKj1cIlBhcnRpY2lwYW50XCJdIC5kanMtdmlzdWFsID4gZyA+IHJlY3Q6Zmlyc3QtY2hpbGQsXG4gICAgICAuZGpzLWVsZW1lbnRbZGF0YS1lbGVtZW50LWlkKj1cIkxhbmVcIl0gLmRqcy12aXN1YWwgPiBnID4gcmVjdDpmaXJzdC1jaGlsZCB7XG4gICAgICAgIGZpbGw6ICR7aXNEYXJrID8gJyMzNzQxNTEnIDogJyNlNWU3ZWInfSAhaW1wb3J0YW50O1xuICAgICAgfVxuICAgICAgXG4gICAgICAvKiA9PT0gQ09OTkVDVElPTlMgPT09ICovXG4gICAgICBcbiAgICAgIC8qIFNlcXVlbmNlIGZsb3dzIGFuZCBtZXNzYWdlIGZsb3dzICovXG4gICAgICAuZGpzLWNvbm5lY3Rpb24gLmRqcy12aXN1YWwgPiBwYXRoIHtcbiAgICAgICAgc3Ryb2tlOiAke2lzRGFyayA/ICcjZmZmZmZmJyA6ICcjMDAwMDAwJ30gIWltcG9ydGFudDtcbiAgICAgICAgZmlsbDogbm9uZSAhaW1wb3J0YW50O1xuICAgICAgfVxuICAgICAgXG4gICAgICAvKiBBcnJvdyBoZWFkcyAqL1xuICAgICAgLmRqcy1jb25uZWN0aW9uIC5kanMtdmlzdWFsID4gcG9seWxpbmUsXG4gICAgICAuZGpzLWNvbm5lY3Rpb24gLmRqcy12aXN1YWwgPiBwb2x5Z29uIHtcbiAgICAgICAgc3Ryb2tlOiAke2lzRGFyayA/ICcjZmZmZmZmJyA6ICcjMDAwMDAwJ30gIWltcG9ydGFudDtcbiAgICAgICAgZmlsbDogJHtpc0RhcmsgPyAnI2ZmZmZmZicgOiAnIzAwMDAwMCd9ICFpbXBvcnRhbnQ7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8qIEFzc29jaWF0aW9uL0RhdGEgYXNzb2NpYXRpb24gKGRvdHRlZCBsaW5lcykgKi9cbiAgICAgIC5kanMtY29ubmVjdGlvbltkYXRhLWVsZW1lbnQtaWQqPVwiQXNzb2NpYXRpb25cIl0gLmRqcy12aXN1YWwgPiBwYXRoIHtcbiAgICAgICAgc3Ryb2tlOiAke2lzRGFyayA/ICcjZmZmZmZmJyA6ICcjMDAwMDAwJ30gIWltcG9ydGFudDtcbiAgICAgICAgc3Ryb2tlLWRhc2hhcnJheTogNSwgNSAhaW1wb3J0YW50O1xuICAgICAgfVxuICAgICAgXG4gICAgICAvKiBNZXNzYWdlIGZsb3dzIChkYXNoZWQgbGluZXMpICovXG4gICAgICAuZGpzLWNvbm5lY3Rpb25bZGF0YS1lbGVtZW50LWlkKj1cIk1lc3NhZ2VGbG93XCJdIC5kanMtdmlzdWFsID4gcGF0aCB7XG4gICAgICAgIHN0cm9rZTogJHtpc0RhcmsgPyAnI2ZmZmZmZicgOiAnIzAwMDAwMCd9ICFpbXBvcnRhbnQ7XG4gICAgICAgIHN0cm9rZS1kYXNoYXJyYXk6IDEwLCA1ICFpbXBvcnRhbnQ7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8qID09PSBBUlRJRkFDVFMgPT09ICovXG4gICAgICBcbiAgICAgIC8qIFRleHQgYW5ub3RhdGlvbnMgKi9cbiAgICAgIC5kanMtZWxlbWVudFtkYXRhLWVsZW1lbnQtaWQqPVwiVGV4dEFubm90YXRpb25cIl0gLmRqcy12aXN1YWwgPiByZWN0IHtcbiAgICAgICAgc3Ryb2tlOiAke2lzRGFyayA/ICcjZmZmZmZmJyA6ICcjMDAwMDAwJ30gIWltcG9ydGFudDtcbiAgICAgICAgZmlsbDogbm9uZSAhaW1wb3J0YW50O1xuICAgICAgICBzdHJva2UtZGFzaGFycmF5OiA1LCA1ICFpbXBvcnRhbnQ7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8qIEdyb3VwcyAqL1xuICAgICAgLmRqcy1lbGVtZW50W2RhdGEtZWxlbWVudC1pZCo9XCJHcm91cFwiXSAuZGpzLXZpc3VhbCA+IHJlY3Qge1xuICAgICAgICBzdHJva2U6ICR7aXNEYXJrID8gJyNmZmZmZmYnIDogJyMwMDAwMDAnfSAhaW1wb3J0YW50O1xuICAgICAgICBmaWxsOiBub25lICFpbXBvcnRhbnQ7XG4gICAgICAgIHN0cm9rZS1kYXNoYXJyYXk6IDgsIDMsIDEsIDMgIWltcG9ydGFudDtcbiAgICAgICAgc3Ryb2tlLXdpZHRoOiAxcHggIWltcG9ydGFudDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLyogPT09IFRFWFQgTEFCRUxTID09PSAqL1xuICAgICAgXG4gICAgICAvKiBBbGwgdGV4dCBlbGVtZW50cyAqL1xuICAgICAgLmRqcy1sYWJlbCxcbiAgICAgIC5kanMtc2hhcGUgLmRqcy12aXN1YWwgdGV4dCxcbiAgICAgIC5kanMtZWxlbWVudCB0ZXh0LFxuICAgICAgdGV4dCB7XG4gICAgICAgIGZpbGw6ICR7aXNEYXJrID8gJyNmZmZmZmYnIDogJyMwMDAwMDAnfSAhaW1wb3J0YW50O1xuICAgICAgfVxuICAgICAgXG4gICAgICAvKiBMYWJlbCBiYWNrZ3JvdW5kcyBzaG91bGQgYmUgdHJhbnNwYXJlbnQgKi9cbiAgICAgIC5kanMtbGFiZWwgLmRqcy12aXN1YWwgcmVjdCB7XG4gICAgICAgIGZpbGw6IHRyYW5zcGFyZW50ICFpbXBvcnRhbnQ7XG4gICAgICAgIHN0cm9rZTogbm9uZSAhaW1wb3J0YW50O1xuICAgICAgfVxuICAgICAgXG4gICAgICAvKiA9PT0gR0VORVJJQyBGQUxMQkFDS1MgPT09ICovXG4gICAgICBcbiAgICAgIC8qIEFueSBvdGhlciBwYXRoIGVsZW1lbnRzICovXG4gICAgICAuZGpzLXNoYXBlIC5kanMtdmlzdWFsID4gcGF0aCB7XG4gICAgICAgIHN0cm9rZTogJHtpc0RhcmsgPyAnI2ZmZmZmZicgOiAnIzAwMDAwMCd9ICFpbXBvcnRhbnQ7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8qIEFsbCBwYXRocyB3aXRoIHN0cm9rZSBhdHRyaWJ1dGUgKi9cbiAgICAgIHBhdGhbc3Ryb2tlXTpub3QoW3N0cm9rZT1cIm5vbmVcIl0pIHtcbiAgICAgICAgc3Ryb2tlOiAke2lzRGFyayA/ICcjZmZmZmZmJyA6ICcjMDAwMDAwJ30gIWltcG9ydGFudDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLyogQWxsIGVsbGlwc2UgZWxlbWVudHMgKi9cbiAgICAgIGVsbGlwc2Uge1xuICAgICAgICBzdHJva2U6ICR7aXNEYXJrID8gJyNmZmZmZmYnIDogJyMwMDAwMDAnfSAhaW1wb3J0YW50O1xuICAgICAgICBmaWxsOiAke2lzRGFyayA/ICcjMWYyOTM3JyA6ICcjZmZmZmZmJ30gIWltcG9ydGFudDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLyogQWxsIGxpbmUgZWxlbWVudHMgKi9cbiAgICAgIGxpbmUge1xuICAgICAgICBzdHJva2U6ICR7aXNEYXJrID8gJyNmZmZmZmYnIDogJyMwMDAwMDAnfSAhaW1wb3J0YW50O1xuICAgICAgfVxuICAgICAgXG4gICAgICAvKiBGaWxsZWQgcGF0aCBlbGVtZW50cyAoaWNvbnMsIG1hcmtlcnMpICovXG4gICAgICAuZGpzLXNoYXBlIC5kanMtdmlzdWFsID4gZyA+IHBhdGhbZmlsbF06bm90KFtmaWxsPVwibm9uZVwiXSkge1xuICAgICAgICBmaWxsOiAke2lzRGFyayA/ICcjZmZmZmZmJyA6ICcjMDAwMDAwJ30gIWltcG9ydGFudDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLyogQ2F0Y2ggYWxsIFNWRyBzaGFwZXMgdGhhdCBtaWdodCBoYXZlIGJsYWNrIHN0cm9rZSBpbiBsaWdodCBtb2RlICovXG4gICAgICAuZGpzLXZpc3VhbCA+ICpbc3Ryb2tlPVwiIzAwMDAwMFwiXSxcbiAgICAgIC5kanMtdmlzdWFsID4gKltzdHJva2U9XCJibGFja1wiXSxcbiAgICAgIC5kanMtdmlzdWFsID4gKltzdHJva2U9XCJyZ2IoMCwwLDApXCJdLFxuICAgICAgLmRqcy12aXN1YWwgPiAqW3N0cm9rZT1cInJnYigwLCAwLCAwKVwiXSB7XG4gICAgICAgIHN0cm9rZTogJHtpc0RhcmsgPyAnI2ZmZmZmZicgOiAnIzAwMDAwMCd9ICFpbXBvcnRhbnQ7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8qIENhdGNoIGFsbCBuZXN0ZWQgZWxlbWVudHMgd2l0aCBibGFjayBzdHJva2UgKi9cbiAgICAgIC5kanMtdmlzdWFsICpbc3Ryb2tlPVwiIzAwMDAwMFwiXSxcbiAgICAgIC5kanMtdmlzdWFsICpbc3Ryb2tlPVwiYmxhY2tcIl0sXG4gICAgICAuZGpzLXZpc3VhbCAqW3N0cm9rZT1cInJnYigwLDAsMClcIl0sXG4gICAgICAuZGpzLXZpc3VhbCAqW3N0cm9rZT1cInJnYigwLCAwLCAwKVwiXSB7XG4gICAgICAgIHN0cm9rZTogJHtpc0RhcmsgPyAnI2ZmZmZmZicgOiAnIzAwMDAwMCd9ICFpbXBvcnRhbnQ7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8qIENhdGNoIGFsbCBTVkcgc2hhcGVzIHRoYXQgbWlnaHQgaGF2ZSB3aGl0ZSBmaWxsIGluIGxpZ2h0IG1vZGUgKi9cbiAgICAgIC5kanMtdmlzdWFsID4gKltmaWxsPVwiI2ZmZmZmZlwiXSxcbiAgICAgIC5kanMtdmlzdWFsID4gKltmaWxsPVwid2hpdGVcIl0sXG4gICAgICAuZGpzLXZpc3VhbCA+ICpbZmlsbD1cInJnYigyNTUsMjU1LDI1NSlcIl0sXG4gICAgICAuZGpzLXZpc3VhbCA+ICpbZmlsbD1cInJnYigyNTUsIDI1NSwgMjU1KVwiXSB7XG4gICAgICAgIGZpbGw6ICR7aXNEYXJrID8gJyMxZjI5MzcnIDogJyNmZmZmZmYnfSAhaW1wb3J0YW50O1xuICAgICAgfVxuICAgICAgXG4gICAgICAvKiBDYXRjaCBhbGwgbmVzdGVkIGVsZW1lbnRzIHdpdGggd2hpdGUgZmlsbCAqL1xuICAgICAgLmRqcy12aXN1YWwgKltmaWxsPVwiI2ZmZmZmZlwiXSxcbiAgICAgIC5kanMtdmlzdWFsICpbZmlsbD1cIndoaXRlXCJdLFxuICAgICAgLmRqcy12aXN1YWwgKltmaWxsPVwicmdiKDI1NSwyNTUsMjU1KVwiXSxcbiAgICAgIC5kanMtdmlzdWFsICpbZmlsbD1cInJnYigyNTUsIDI1NSwgMjU1KVwiXSB7XG4gICAgICAgIGZpbGw6ICR7aXNEYXJrID8gJyMxZjI5MzcnIDogJyNmZmZmZmYnfSAhaW1wb3J0YW50O1xuICAgICAgfVxuICAgICAgXG4gICAgICAvKiBEaXJlY3QgZWRpdGluZyB0ZXh0ICovXG4gICAgICAuZGpzLWRpcmVjdC1lZGl0aW5nLXBhcmVudCB7XG4gICAgICAgIGNvbG9yOiAke2lzRGFyayA/ICcjZmZmZmZmJyA6ICcjMDAwMDAwJ30gIWltcG9ydGFudDtcbiAgICAgICAgYmFja2dyb3VuZDogdHJhbnNwYXJlbnQgIWltcG9ydGFudDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLmRqcy1kaXJlY3QtZWRpdGluZy1jb250ZW50IHtcbiAgICAgICAgY29sb3I6ICR7aXNEYXJrID8gJyNmZmZmZmYnIDogJyMwMDAwMDAnfSAhaW1wb3J0YW50O1xuICAgICAgICBiYWNrZ3JvdW5kOiB0cmFuc3BhcmVudCAhaW1wb3J0YW50O1xuICAgICAgICBjYXJldC1jb2xvcjogJHtpc0RhcmsgPyAnI2ZmZmZmZicgOiAnIzAwMDAwMCd9ICFpbXBvcnRhbnQ7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8qIEVuc3VyZSB0aGUgZWRpdGluZyBib3ggaXRzZWxmIGlzIHRyYW5zcGFyZW50ICovXG4gICAgICAuZGpzLWRpcmVjdC1lZGl0aW5nLXBhcmVudCA+IGRpdiB7XG4gICAgICAgIGJhY2tncm91bmQ6IHRyYW5zcGFyZW50ICFpbXBvcnRhbnQ7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8qIENvbnRlbnRlZGl0YWJsZSBlbGVtZW50cyBzaG91bGQgYmUgdHJhbnNwYXJlbnQgKi9cbiAgICAgIFtjb250ZW50ZWRpdGFibGU9XCJ0cnVlXCJdIHtcbiAgICAgICAgYmFja2dyb3VuZDogdHJhbnNwYXJlbnQgIWltcG9ydGFudDtcbiAgICAgICAgb3V0bGluZTogbm9uZSAhaW1wb3J0YW50O1xuICAgICAgfVxuICAgICAgXG4gICAgICAvKiBGb2N1cyBzdGF0ZSBmb3IgZWRpdGluZyAqL1xuICAgICAgLmRqcy1kaXJlY3QtZWRpdGluZy1jb250ZW50OmZvY3VzIHtcbiAgICAgICAgYmFja2dyb3VuZDogdHJhbnNwYXJlbnQgIWltcG9ydGFudDtcbiAgICAgICAgb3V0bGluZTogMXB4IGRvdHRlZCAke2lzRGFyayA/ICcjNjBhNWZhJyA6ICcjMjU2M2ViJ30gIWltcG9ydGFudDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLyogPT09IFNFTEVDVElPTiBWSVNJQklMSVRZIEZJWCA9PT0gKi9cbiAgICAgIFxuICAgICAgLyogU2VsZWN0ZWQgZWxlbWVudCBvdXRsaW5lIC0gbWFrZSBpdCBoaWdobHkgdmlzaWJsZSAqL1xuICAgICAgLmRqcy1vdXRsaW5lIHtcbiAgICAgICAgc3Ryb2tlOiAke2lzRGFyayA/ICcjNjBhNWZhJyA6ICcjMjU2M2ViJ30gIWltcG9ydGFudDtcbiAgICAgICAgc3Ryb2tlLXdpZHRoOiAzcHggIWltcG9ydGFudDtcbiAgICAgICAgc3Ryb2tlLWRhc2hhcnJheTogNSwgNSAhaW1wb3J0YW50O1xuICAgICAgICBmaWxsOiBub25lICFpbXBvcnRhbnQ7XG4gICAgICAgIGZpbGwtb3BhY2l0eTogMCAhaW1wb3J0YW50O1xuICAgICAgICBvcGFjaXR5OiAxICFpbXBvcnRhbnQ7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8qIE91dGxpbmUgcGF0aHMgYW5kIHBvbHlnb25zIG11c3QgYmUgdHJhbnNwYXJlbnQgKi9cbiAgICAgIC5kanMtb3V0bGluZSBwYXRoLFxuICAgICAgLmRqcy1vdXRsaW5lIHBvbHlnb24sXG4gICAgICAuZGpzLW91dGxpbmUgcG9seWxpbmUsXG4gICAgICAuZGpzLW91dGxpbmUgcmVjdCxcbiAgICAgIC5kanMtb3V0bGluZSBjaXJjbGUsXG4gICAgICAuZGpzLW91dGxpbmUgZWxsaXBzZSB7XG4gICAgICAgIGZpbGw6IG5vbmUgIWltcG9ydGFudDtcbiAgICAgICAgZmlsbC1vcGFjaXR5OiAwICFpbXBvcnRhbnQ7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8qIFNlbGVjdGlvbiBib3ggb3ZlcmxheSAtIE1VU1QgQkUgVFJBTlNQQVJFTlQgKi9cbiAgICAgIC5kanMtbGFzc28tb3ZlcmxheSB7XG4gICAgICAgIHN0cm9rZTogJHtpc0RhcmsgPyAnIzYwYTVmYScgOiAnIzI1NjNlYid9ICFpbXBvcnRhbnQ7XG4gICAgICAgIHN0cm9rZS13aWR0aDogMnB4ICFpbXBvcnRhbnQ7XG4gICAgICAgIGZpbGw6ICR7aXNEYXJrID8gJ3JnYmEoOTYsIDE2NSwgMjUwLCAwLjEpJyA6ICdyZ2JhKDM3LCA5OSwgMjM1LCAwLjEpJ30gIWltcG9ydGFudDtcbiAgICAgICAgb3BhY2l0eTogMSAhaW1wb3J0YW50O1xuICAgICAgfVxuICAgICAgXG4gICAgICAvKiBNdWx0aS1zZWxlY3QgbWFycXVlZSAtIHRyYW5zcGFyZW50IGJhY2tncm91bmQgKi9cbiAgICAgIC5kanMtbWFycXVlZSB7XG4gICAgICAgIGZpbGw6ICR7aXNEYXJrID8gJ3JnYmEoOTYsIDE2NSwgMjUwLCAwLjEpJyA6ICdyZ2JhKDM3LCA5OSwgMjM1LCAwLjEpJ30gIWltcG9ydGFudDtcbiAgICAgICAgc3Ryb2tlOiAke2lzRGFyayA/ICcjNjBhNWZhJyA6ICcjMjU2M2ViJ30gIWltcG9ydGFudDtcbiAgICAgICAgc3Ryb2tlLXdpZHRoOiAxcHggIWltcG9ydGFudDtcbiAgICAgICAgc3Ryb2tlLWRhc2hhcnJheTogNSwgNSAhaW1wb3J0YW50O1xuICAgICAgfVxuICAgICAgXG4gICAgICAvKiBTZWxlY3RlZCBlbGVtZW50cyBnZXQgYSBoaWdobGlnaHQgKi9cbiAgICAgIC5kanMtZWxlbWVudC5zZWxlY3RlZCAuZGpzLW91dGxpbmUge1xuICAgICAgICBzdHJva2U6ICR7aXNEYXJrID8gJyM2MGE1ZmEnIDogJyMyNTYzZWInfSAhaW1wb3J0YW50O1xuICAgICAgICBzdHJva2Utd2lkdGg6IDNweCAhaW1wb3J0YW50O1xuICAgICAgICBvcGFjaXR5OiAxICFpbXBvcnRhbnQ7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8qIEhvdmVyIHN0YXRlIGZvciBiZXR0ZXIgdmlzaWJpbGl0eSAqL1xuICAgICAgLmRqcy1lbGVtZW50LmhvdmVyIC5kanMtb3V0bGluZSB7XG4gICAgICAgIHN0cm9rZTogJHtpc0RhcmsgPyAnIzkzYzVmZCcgOiAnIzYwYTVmYSd9ICFpbXBvcnRhbnQ7XG4gICAgICAgIHN0cm9rZS13aWR0aDogMnB4ICFpbXBvcnRhbnQ7XG4gICAgICAgIG9wYWNpdHk6IDAuOCAhaW1wb3J0YW50O1xuICAgICAgfVxuICAgICAgXG4gICAgICAvKiBTZWxlY3Rpb24gZnJhbWUgYXJvdW5kIGVsZW1lbnRzICovXG4gICAgICAuZGpzLXNlbGVjdC12aXN1YWwge1xuICAgICAgICBzdHJva2U6ICR7aXNEYXJrID8gJyM2MGE1ZmEnIDogJyMyNTYzZWInfSAhaW1wb3J0YW50O1xuICAgICAgICBzdHJva2Utd2lkdGg6IDJweCAhaW1wb3J0YW50O1xuICAgICAgICBzdHJva2UtZGFzaGFycmF5OiA1LCA1ICFpbXBvcnRhbnQ7XG4gICAgICAgIGZpbGw6IG5vbmUgIWltcG9ydGFudDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLyogTXVsdGktc2VsZWN0aW9uIHZpc3VhbCAqL1xuICAgICAgLmRqcy1tdWx0aXNlbGVjdC12aXN1YWwge1xuICAgICAgICBzdHJva2U6ICR7aXNEYXJrID8gJyM2MGE1ZmEnIDogJyMyNTYzZWInfSAhaW1wb3J0YW50O1xuICAgICAgICBzdHJva2Utd2lkdGg6IDJweCAhaW1wb3J0YW50O1xuICAgICAgICBmaWxsOiAke2lzRGFyayA/ICdyZ2JhKDk2LCAxNjUsIDI1MCwgMC4wNSknIDogJ3JnYmEoMzcsIDk5LCAyMzUsIDAuMDUpJ30gIWltcG9ydGFudDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLyogUmVzaXplIGhhbmRsZXMgLSBzbWFsbCBjb3JuZXIgc3F1YXJlcyAqL1xuICAgICAgLmRqcy1yZXNpemVyLXZpc3VhbCxcbiAgICAgIC5kanMtcmVzaXplci1oaXQge1xuICAgICAgICBzdHJva2U6ICR7aXNEYXJrID8gJyM2MGE1ZmEnIDogJyMyNTYzZWInfSAhaW1wb3J0YW50O1xuICAgICAgICBmaWxsOiB0cmFuc3BhcmVudCAhaW1wb3J0YW50O1xuICAgICAgICBvcGFjaXR5OiAxICFpbXBvcnRhbnQ7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8qIFJlc2l6ZSBoYW5kbGUgY29ybmVycyAtIHRoZSBhY3R1YWwgc3F1YXJlcyAqL1xuICAgICAgLmRqcy1yZXNpemVyLXZpc3VhbCByZWN0LFxuICAgICAgLmRqcy1yZXNpemVyLWhpdCByZWN0IHtcbiAgICAgICAgZmlsbDogJHtpc0RhcmsgPyAnIzYwYTVmYScgOiAnIzI1NjNlYid9ICFpbXBvcnRhbnQ7XG4gICAgICAgIHN0cm9rZTogJHtpc0RhcmsgPyAnI2ZmZmZmZicgOiAnIzAwMDAwMCd9ICFpbXBvcnRhbnQ7XG4gICAgICAgIHN0cm9rZS13aWR0aDogMXB4ICFpbXBvcnRhbnQ7XG4gICAgICAgIHdpZHRoOiA2cHggIWltcG9ydGFudDtcbiAgICAgICAgaGVpZ2h0OiA2cHggIWltcG9ydGFudDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLyogU2VsZWN0aW9uIGZyYW1lIC0gTVVTVCBCRSBUUkFOU1BBUkVOVCAqL1xuICAgICAgLmRqcy1zZWxlY3Rpb24tZnJhbWUge1xuICAgICAgICBmaWxsOiB0cmFuc3BhcmVudCAhaW1wb3J0YW50O1xuICAgICAgICBzdHJva2U6ICR7aXNEYXJrID8gJyM2MGE1ZmEnIDogJyMyNTYzZWInfSAhaW1wb3J0YW50O1xuICAgICAgICBzdHJva2Utd2lkdGg6IDJweCAhaW1wb3J0YW50O1xuICAgICAgICBzdHJva2UtZGFzaGFycmF5OiA1LCA1ICFpbXBvcnRhbnQ7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8qIFNlbGVjdGlvbiB2aXN1YWwgYm94IC0gVFJBTlNQQVJFTlQgQkFDS0dST1VORCAqL1xuICAgICAgLmRqcy1zZWxlY3Rpb24tdmlzdWFsIHtcbiAgICAgICAgZmlsbDogdHJhbnNwYXJlbnQgIWltcG9ydGFudDtcbiAgICAgICAgc3Ryb2tlOiAke2lzRGFyayA/ICcjNjBhNWZhJyA6ICcjMjU2M2ViJ30gIWltcG9ydGFudDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLyogU2VsZWN0aW9uIG92ZXJsYXkgYmFja2dyb3VuZCAtIENSSVRJQ0FMIEZJWCAqL1xuICAgICAgLmRqcy1vdmVybGF5LWNvbnRhaW5lciAuZGpzLW92ZXJsYXkge1xuICAgICAgICBiYWNrZ3JvdW5kOiB0cmFuc3BhcmVudCAhaW1wb3J0YW50O1xuICAgICAgfVxuICAgICAgXG4gICAgICAvKiBBbnkgc2VsZWN0aW9uLXJlbGF0ZWQgb3ZlcmxheXMgbXVzdCBiZSB0cmFuc3BhcmVudCAqL1xuICAgICAgLmRqcy1vdmVybGF5LWNvbnRhaW5lciA+ICoge1xuICAgICAgICBiYWNrZ3JvdW5kOiB0cmFuc3BhcmVudCAhaW1wb3J0YW50O1xuICAgICAgfVxuICAgICAgXG4gICAgICAvKiBMYXNzbyBzZWxlY3Rpb24gYXJlYSAqL1xuICAgICAgLmRqcy1sYXNzby1vdmVybGF5IHJlY3Qge1xuICAgICAgICBmaWxsOiAke2lzRGFyayA/ICdyZ2JhKDk2LCAxNjUsIDI1MCwgMC4xKScgOiAncmdiYSgzNywgOTksIDIzNSwgMC4xKSd9ICFpbXBvcnRhbnQ7XG4gICAgICAgIHN0cm9rZTogJHtpc0RhcmsgPyAnIzYwYTVmYScgOiAnIzI1NjNlYid9ICFpbXBvcnRhbnQ7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8qIERyYWcgc2VsZWN0aW9uIG1hcnF1ZWUgYm94ICovXG4gICAgICAuZGpzLWRyYWctbWFycXVlZSB7XG4gICAgICAgIGZpbGw6ICR7aXNEYXJrID8gJ3JnYmEoOTYsIDE2NSwgMjUwLCAwLjEpJyA6ICdyZ2JhKDM3LCA5OSwgMjM1LCAwLjEpJ30gIWltcG9ydGFudDtcbiAgICAgICAgc3Ryb2tlOiAke2lzRGFyayA/ICcjNjBhNWZhJyA6ICcjMjU2M2ViJ30gIWltcG9ydGFudDtcbiAgICAgICAgc3Ryb2tlLXdpZHRoOiAxcHggIWltcG9ydGFudDtcbiAgICAgICAgc3Ryb2tlLWRhc2hhcnJheTogNSwgNSAhaW1wb3J0YW50O1xuICAgICAgfVxuICAgICAgXG4gICAgICAvKiBHcm91cCBzZWxlY3Rpb24gZnJhbWUgKi9cbiAgICAgIC5kanMtZ3JvdXAtc2VsZWN0b3Ige1xuICAgICAgICBmaWxsOiB0cmFuc3BhcmVudCAhaW1wb3J0YW50O1xuICAgICAgICBzdHJva2U6ICR7aXNEYXJrID8gJyM2MGE1ZmEnIDogJyMyNTYzZWInfSAhaW1wb3J0YW50O1xuICAgICAgICBzdHJva2Utd2lkdGg6IDJweCAhaW1wb3J0YW50O1xuICAgICAgICBzdHJva2UtZGFzaGFycmF5OiA1LCA1ICFpbXBvcnRhbnQ7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8qIFNlbGVjdGVkIHN0YXRlIHZpc3VhbCBmZWVkYmFjayAqL1xuICAgICAgLnNlbGVjdGVkID4gLmRqcy12aXN1YWwge1xuICAgICAgICBmaWx0ZXI6ICR7aXNEYXJrID8gJ2Ryb3Atc2hhZG93KDAgMCA0cHggcmdiYSg5NiwgMTY1LCAyNTAsIDAuNSkpJyA6ICdkcm9wLXNoYWRvdygwIDAgNHB4IHJnYmEoMzcsIDk5LCAyMzUsIDAuMykpJ30gIWltcG9ydGFudDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLyogTWFrZSBzdXJlIHNlbGVjdGlvbiBkb2Vzbid0IGhpZGUgZWxlbWVudHMgKi9cbiAgICAgIC5kanMtb3ZlcmxheSB7XG4gICAgICAgIHBvaW50ZXItZXZlbnRzOiBub25lICFpbXBvcnRhbnQ7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC5kanMtb3ZlcmxheS5kanMtbGFzc28tb3ZlcmxheSB7XG4gICAgICAgIHBvaW50ZXItZXZlbnRzOiBhbGwgIWltcG9ydGFudDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLyogQUdHUkVTU0lWRSBGSVg6IEZvcmNlIEFMTCBzZWxlY3Rpb24gcmVjdGFuZ2xlcyB0byBiZSB0cmFuc3BhcmVudCAqL1xuICAgICAgLnNlbGVjdGVkIHJlY3Q6bm90KC5kanMtdmlzdWFsIHJlY3QpIHtcbiAgICAgICAgZmlsbDogdHJhbnNwYXJlbnQgIWltcG9ydGFudDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLyogU2VsZWN0aW9uIGluZGljYXRvcnMgc2hvdWxkIG9ubHkgYmUgb3V0bGluZXMgKi9cbiAgICAgIC5kanMtb3V0bGluZSByZWN0LFxuICAgICAgLmRqcy1zZWxlY3Rpb24gcmVjdCxcbiAgICAgIC5kanMtc2VsZWN0IHJlY3Qge1xuICAgICAgICBmaWxsOiB0cmFuc3BhcmVudCAhaW1wb3J0YW50O1xuICAgICAgICBzdHJva2U6ICR7aXNEYXJrID8gJyM2MGE1ZmEnIDogJyMyNTYzZWInfSAhaW1wb3J0YW50O1xuICAgICAgICBzdHJva2Utd2lkdGg6IDJweCAhaW1wb3J0YW50O1xuICAgICAgfVxuICAgICAgXG4gICAgICAvKiBFbnN1cmUgbm8gYmFja2dyb3VuZCBvbiBzZWxlY3Rpb24gdmlzdWFscyAqL1xuICAgICAgW2NsYXNzKj1cInNlbGVjdFwiXSByZWN0Om5vdCguZGpzLXZpc3VhbCByZWN0KSB7XG4gICAgICAgIGZpbGw6IHRyYW5zcGFyZW50ICFpbXBvcnRhbnQ7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8qIFJlbW92ZSBhbnkgZmlsbCBmcm9tIHNlbGVjdGlvbiBmcmFtZXMgKi9cbiAgICAgIC5kanMtZnJhbWUgcmVjdCB7XG4gICAgICAgIGZpbGw6IHRyYW5zcGFyZW50ICFpbXBvcnRhbnQ7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8qIENhbnZhcyBiYWNrZ3JvdW5kIC0gdGFyZ2V0IG11bHRpcGxlIHNlbGVjdG9ycyBmb3IgYmV0dGVyIGNvdmVyYWdlICovXG4gICAgICAuZGpzLWNvbnRhaW5lcixcbiAgICAgIC5kanMtY29udGFpbmVyIHN2ZyxcbiAgICAgIC5kanMtdmlld3BvcnQsXG4gICAgICAuZGpzLXBsYW5lIHtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogJHtpc0RhcmsgPyAnIzExMTgyNycgOiAnI2Y5ZmFmYid9ICFpbXBvcnRhbnQ7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8qIEdyaWQgcGF0dGVybiBiYWNrZ3JvdW5kICovXG4gICAgICAuZ3JpZC1iYWNrZ3JvdW5kIHtcbiAgICAgICAgYmFja2dyb3VuZC1pbWFnZTogXG4gICAgICAgICAgbGluZWFyLWdyYWRpZW50KCR7aXNEYXJrID8gJ3JnYmEoMjU1LDI1NSwyNTUsMC4wMyknIDogJ3JnYmEoMCwwLDAsMC4wMyknfSAxcHgsIHRyYW5zcGFyZW50IDFweCksXG4gICAgICAgICAgbGluZWFyLWdyYWRpZW50KDkwZGVnLCAke2lzRGFyayA/ICdyZ2JhKDI1NSwyNTUsMjU1LDAuMDMpJyA6ICdyZ2JhKDAsMCwwLDAuMDMpJ30gMXB4LCB0cmFuc3BhcmVudCAxcHgpO1xuICAgICAgICBiYWNrZ3JvdW5kLXNpemU6IDIwcHggMjBweDtcbiAgICAgICAgYmFja2dyb3VuZC1wb3NpdGlvbjogMCAwLCAwIDA7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8qIEFwcGx5IGdyaWQgdG8gY2FudmFzIHdoZW4gZW5hYmxlZCAqL1xuICAgICAgLmRqcy1jb250YWluZXIuc2hvdy1ncmlkID4gc3ZnIHtcbiAgICAgICAgYmFja2dyb3VuZC1pbWFnZTogXG4gICAgICAgICAgbGluZWFyLWdyYWRpZW50KCR7aXNEYXJrID8gJ3JnYmEoMjU1LDI1NSwyNTUsMC4wNSknIDogJ3JnYmEoMCwwLDAsMC4wNSknfSAxcHgsIHRyYW5zcGFyZW50IDFweCksXG4gICAgICAgICAgbGluZWFyLWdyYWRpZW50KDkwZGVnLCAke2lzRGFyayA/ICdyZ2JhKDI1NSwyNTUsMjU1LDAuMDUpJyA6ICdyZ2JhKDAsMCwwLDAuMDUpJ30gMXB4LCB0cmFuc3BhcmVudCAxcHgpO1xuICAgICAgICBiYWNrZ3JvdW5kLXNpemU6IDIwcHggMjBweDtcbiAgICAgICAgYmFja2dyb3VuZC1wb3NpdGlvbjogMCAwLCAwIDA7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6ICR7aXNEYXJrID8gJyMxMTE4MjcnIDogJyNmOWZhZmInfSAhaW1wb3J0YW50O1xuICAgICAgfVxuICAgICAgXG4gICAgICAvKiBFbnN1cmUgdGhlIFNWRyBpdHNlbGYgaGFzIHRoZSByaWdodCBiYWNrZ3JvdW5kICovXG4gICAgICAuZGpzLWNvbnRhaW5lciA+IHN2ZyB7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6ICR7aXNEYXJrID8gJyMxMTE4MjcnIDogJyNmOWZhZmInfSAhaW1wb3J0YW50O1xuICAgICAgfVxuICAgICAgXG4gICAgICAvKiBIaWRlIG5hdGl2ZSBCUE1OLmpzIHBhbGV0dGUgc2luY2Ugd2UgdXNlIGN1c3RvbSAqL1xuICAgICAgLmRqcy1wYWxldHRlIHtcbiAgICAgICAgZGlzcGxheTogbm9uZSAhaW1wb3J0YW50O1xuICAgICAgfVxuICAgICAgXG4gICAgICAvKiA9PT0gVUxUSU1BVEUgRkFMTEJBQ0sgLSBDYXRjaCBBTlkgZWxlbWVudCB0aGF0IG1pZ2h0IGJlIG1pc3NlZCA9PT0gKi9cbiAgICAgIFxuICAgICAgLyogQUdHUkVTU0lWRTogRm9yY2UgYWxsIHN0cm9rZXMgaW4gZGpzIGVsZW1lbnRzICovXG4gICAgICAuZGpzLWNvbnRhaW5lciBzdmcgKiB7XG4gICAgICAgIHN0cm9rZTogJHtpc0RhcmsgPyAnI2ZmZmZmZicgOiAnIzAwMDAwMCd9ICFpbXBvcnRhbnQ7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8qIEJ1dCBwcmVzZXJ2ZSB0cmFuc3BhcmVudCBzdHJva2VzICovXG4gICAgICAuZGpzLWNvbnRhaW5lciBzdmcgKltzdHJva2U9XCJub25lXCJdLFxuICAgICAgLmRqcy1jb250YWluZXIgc3ZnICpbc3Ryb2tlPVwidHJhbnNwYXJlbnRcIl0sXG4gICAgICAuZGpzLWNvbnRhaW5lciBzdmcgKltzdHJva2Utb3BhY2l0eT1cIjBcIl0ge1xuICAgICAgICBzdHJva2U6IHRyYW5zcGFyZW50ICFpbXBvcnRhbnQ7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8qIEZvcmNlIHByb3BlciBmaWxscyBvbiBiYXNpYyBzaGFwZXMgKi9cbiAgICAgIC5kanMtY29udGFpbmVyIHN2ZyByZWN0Om5vdChbZmlsbD1cIm5vbmVcIl0pOm5vdChbZmlsbD1cInRyYW5zcGFyZW50XCJdKSxcbiAgICAgIC5kanMtY29udGFpbmVyIHN2ZyBjaXJjbGU6bm90KFtmaWxsPVwibm9uZVwiXSk6bm90KFtmaWxsPVwidHJhbnNwYXJlbnRcIl0pLFxuICAgICAgLmRqcy1jb250YWluZXIgc3ZnIGVsbGlwc2U6bm90KFtmaWxsPVwibm9uZVwiXSk6bm90KFtmaWxsPVwidHJhbnNwYXJlbnRcIl0pLFxuICAgICAgLmRqcy1jb250YWluZXIgc3ZnIHBvbHlnb246bm90KFtmaWxsPVwibm9uZVwiXSk6bm90KFtmaWxsPVwidHJhbnNwYXJlbnRcIl0pIHtcbiAgICAgICAgZmlsbDogJHtpc0RhcmsgPyAnIzFmMjkzNycgOiAnI2ZmZmZmZid9ICFpbXBvcnRhbnQ7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8qIEVuc3VyZSB0ZXh0IGlzIGFsd2F5cyB2aXNpYmxlICovXG4gICAgICAuZGpzLWNvbnRhaW5lciBzdmcgdGV4dCxcbiAgICAgIC5kanMtY29udGFpbmVyIHN2ZyB0c3BhbiB7XG4gICAgICAgIGZpbGw6ICR7aXNEYXJrID8gJyNmZmZmZmYnIDogJyMwMDAwMDAnfSAhaW1wb3J0YW50O1xuICAgICAgfVxuICAgICAgXG4gICAgICAvKiBTVVBFUiBBR0dSRVNTSVZFOiBPdmVycmlkZSBBTlkgc3Ryb2tlIGF0dHJpYnV0ZSBpbiBkYXJrIG1vZGUgKi9cbiAgICAgICR7aXNEYXJrID8gYFxuICAgICAgICAuZGpzLWNvbnRhaW5lciBzdmcgKjpub3QoW3N0cm9rZT1cIm5vbmVcIl0pOm5vdChbc3Ryb2tlPVwidHJhbnNwYXJlbnRcIl0pIHtcbiAgICAgICAgICBzdHJva2U6ICNmZmZmZmYgIWltcG9ydGFudDtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLmRqcy1jb250YWluZXIgc3ZnIHBhdGg6bm90KFtzdHJva2U9XCJub25lXCJdKTpub3QoW3N0cm9rZT1cInRyYW5zcGFyZW50XCJdKSB7XG4gICAgICAgICAgc3Ryb2tlOiAjZmZmZmZmICFpbXBvcnRhbnQ7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC5kanMtY29udGFpbmVyIHN2ZyBsaW5lOm5vdChbc3Ryb2tlPVwibm9uZVwiXSk6bm90KFtzdHJva2U9XCJ0cmFuc3BhcmVudFwiXSkge1xuICAgICAgICAgIHN0cm9rZTogI2ZmZmZmZiAhaW1wb3J0YW50O1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAuZGpzLWNvbnRhaW5lciBzdmcgcG9seWxpbmU6bm90KFtzdHJva2U9XCJub25lXCJdKTpub3QoW3N0cm9rZT1cInRyYW5zcGFyZW50XCJdKSB7XG4gICAgICAgICAgc3Ryb2tlOiAjZmZmZmZmICFpbXBvcnRhbnQ7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC5kanMtY29udGFpbmVyIHN2ZyByZWN0Om5vdChbc3Ryb2tlPVwibm9uZVwiXSk6bm90KFtzdHJva2U9XCJ0cmFuc3BhcmVudFwiXSkge1xuICAgICAgICAgIHN0cm9rZTogI2ZmZmZmZiAhaW1wb3J0YW50O1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAuZGpzLWNvbnRhaW5lciBzdmcgY2lyY2xlOm5vdChbc3Ryb2tlPVwibm9uZVwiXSk6bm90KFtzdHJva2U9XCJ0cmFuc3BhcmVudFwiXSkge1xuICAgICAgICAgIHN0cm9rZTogI2ZmZmZmZiAhaW1wb3J0YW50O1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAuZGpzLWNvbnRhaW5lciBzdmcgZWxsaXBzZTpub3QoW3N0cm9rZT1cIm5vbmVcIl0pOm5vdChbc3Ryb2tlPVwidHJhbnNwYXJlbnRcIl0pIHtcbiAgICAgICAgICBzdHJva2U6ICNmZmZmZmYgIWltcG9ydGFudDtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLmRqcy1jb250YWluZXIgc3ZnIHBvbHlnb246bm90KFtzdHJva2U9XCJub25lXCJdKTpub3QoW3N0cm9rZT1cInRyYW5zcGFyZW50XCJdKSB7XG4gICAgICAgICAgc3Ryb2tlOiAjZmZmZmZmICFpbXBvcnRhbnQ7XG4gICAgICAgIH1cbiAgICAgIGAgOiBgXG4gICAgICAgIC5kanMtY29udGFpbmVyIHN2ZyAqOm5vdChbc3Ryb2tlPVwibm9uZVwiXSk6bm90KFtzdHJva2U9XCJ0cmFuc3BhcmVudFwiXSkge1xuICAgICAgICAgIHN0cm9rZTogIzAwMDAwMCAhaW1wb3J0YW50O1xuICAgICAgICB9XG4gICAgICBgfVxuICAgIGBcbiAgICBcbiAgICAgIC8vIE9ubHkgYXBwZW5kIGlmIG5vdCBhbHJlYWR5IGluIERPTVxuICAgICAgaWYgKCFzdHlsZS5wYXJlbnROb2RlKSB7XG4gICAgICAgIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoc3R5bGUpXG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIEFsc28gYWRkIGNsYXNzIHRvIHRoZSBjYW52YXMgY29udGFpbmVyIGZvciBDU1MgdGFyZ2V0aW5nXG4gICAgICBpZiAoY29udGFpbmVyKSB7XG4gICAgICAgIGlmIChpc0RhcmspIHtcbiAgICAgICAgICBjb250YWluZXIuY2xhc3NMaXN0LmFkZCgnZGFyay1tb2RlJylcbiAgICAgICAgICBjb250YWluZXIuY2xhc3NMaXN0LnJlbW92ZSgnbGlnaHQtbW9kZScpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoJ2xpZ2h0LW1vZGUnKVxuICAgICAgICAgIGNvbnRhaW5lci5jbGFzc0xpc3QucmVtb3ZlKCdkYXJrLW1vZGUnKVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBEaXJlY3RseSBzZXQgYmFja2dyb3VuZCBvbiBjb250YWluZXIgYW5kIFNWR1xuICAgICAgICBjb250YWluZXIuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gaXNEYXJrID8gJyMxMTE4MjcnIDogJyNmOWZhZmInXG4gICAgICAgIGNvbnN0IHN2Z0VsZW1lbnQgPSBjb250YWluZXIucXVlcnlTZWxlY3Rvcignc3ZnJylcbiAgICAgICAgaWYgKHN2Z0VsZW1lbnQpIHtcbiAgICAgICAgICBzdmdFbGVtZW50LnN0eWxlLmJhY2tncm91bmRDb2xvciA9IGlzRGFyayA/ICcjMTExODI3JyA6ICcjZjlmYWZiJ1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIEZvcmNlIGEgcmVkcmF3IC0gYnV0IGNoZWNrIGlmIGV2ZW50QnVzIGV4aXN0c1xuICAgICAgY29uc3QgZXZlbnRCdXMgPSBtb2RlbGVyLmdldCgnZXZlbnRCdXMnKSBhcyBhbnlcbiAgICAgIGlmIChldmVudEJ1cykge1xuICAgICAgICBldmVudEJ1cy5maXJlKCdjYW52YXMudmlld2JveC5jaGFuZ2VkJylcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gQUdHUkVTU0lWRSBGQUxMQkFDSzogRm9yY2UgY29sb3IgdXBkYXRlcyBvbiBBTEwgZWxlbWVudHNcbiAgICAgIGNvbnN0IGZvcmNlQ29sb3JVcGRhdGUgPSAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHN2Z0VsZW1lbnRzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLmRqcy1jb250YWluZXIgc3ZnIConKVxuICAgICAgICBzdmdFbGVtZW50cy5mb3JFYWNoKChlbDogYW55KSA9PiB7XG4gICAgICAgICAgY29uc3QgdGFnTmFtZSA9IGVsLnRhZ05hbWU/LnRvTG93ZXJDYXNlKClcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBGT1JDRSBzdHJva2UgY29sb3JzXG4gICAgICAgICAgaWYgKGVsLmhhc0F0dHJpYnV0ZSgnc3Ryb2tlJykgfHwgZWwuc3R5bGUuc3Ryb2tlKSB7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50U3Ryb2tlID0gZWwuZ2V0QXR0cmlidXRlKCdzdHJva2UnKSB8fCBlbC5zdHlsZS5zdHJva2VcbiAgICAgICAgICAgIGlmIChjdXJyZW50U3Ryb2tlICYmIGN1cnJlbnRTdHJva2UgIT09ICdub25lJyAmJiBjdXJyZW50U3Ryb2tlICE9PSAndHJhbnNwYXJlbnQnKSB7XG4gICAgICAgICAgICAgIC8vIENoZWNrIGlmIGl0J3MgYSBibGFjayBzdHJva2UgaW4gZGFyayBtb2RlIG9yIHdoaXRlIGluIGxpZ2h0IG1vZGUgKG5lZWRzIGZpeGluZylcbiAgICAgICAgICAgICAgY29uc3QgbmVlZHNGaXggPSAoaXNEYXJrICYmIChjdXJyZW50U3Ryb2tlID09PSAnIzAwMDAwMCcgfHwgY3VycmVudFN0cm9rZSA9PT0gJ2JsYWNrJyB8fCBjdXJyZW50U3Ryb2tlID09PSAncmdiKDAsIDAsIDApJykpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICghaXNEYXJrICYmIChjdXJyZW50U3Ryb2tlID09PSAnI2ZmZmZmZicgfHwgY3VycmVudFN0cm9rZSA9PT0gJ3doaXRlJyB8fCBjdXJyZW50U3Ryb2tlID09PSAncmdiKDI1NSwgMjU1LCAyNTUpJykpXG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICBpZiAobmVlZHNGaXggfHwgdGFnTmFtZSA9PT0gJ3JlY3QnIHx8IHRhZ05hbWUgPT09ICdjaXJjbGUnIHx8IHRhZ05hbWUgPT09ICdwb2x5Z29uJyB8fCB0YWdOYW1lID09PSAncGF0aCcgfHwgdGFnTmFtZSA9PT0gJ2xpbmUnKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3U3Ryb2tlID0gaXNEYXJrID8gJyNmZmZmZmYnIDogJyMwMDAwMDAnXG4gICAgICAgICAgICAgICAgZWwuc2V0QXR0cmlidXRlKCdzdHJva2UnLCBuZXdTdHJva2UpXG4gICAgICAgICAgICAgICAgZWwuc3R5bGUuc3Ryb2tlID0gbmV3U3Ryb2tlXG4gICAgICAgICAgICAgICAgZWwuc3R5bGUuc3Ryb2tlT3BhY2l0eSA9ICcxJ1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIC8vIEZPUkNFIGZpbGwgY29sb3JzIGZvciBzaGFwZXNcbiAgICAgICAgICBpZiAodGFnTmFtZSA9PT0gJ3JlY3QnIHx8IHRhZ05hbWUgPT09ICdjaXJjbGUnIHx8IHRhZ05hbWUgPT09ICdlbGxpcHNlJyB8fCB0YWdOYW1lID09PSAncG9seWdvbicpIHtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRGaWxsID0gZWwuZ2V0QXR0cmlidXRlKCdmaWxsJykgfHwgZWwuc3R5bGUuZmlsbFxuICAgICAgICAgICAgaWYgKGN1cnJlbnRGaWxsICYmIGN1cnJlbnRGaWxsICE9PSAnbm9uZScgJiYgY3VycmVudEZpbGwgIT09ICd0cmFuc3BhcmVudCcpIHtcbiAgICAgICAgICAgICAgLy8gU2tpcCBzZWxlY3Rpb24gYm94ZXNcbiAgICAgICAgICAgICAgaWYgKCFlbC5jbG9zZXN0KCcuZGpzLW91dGxpbmUnKSAmJiAhZWwuY2xvc2VzdCgnLmRqcy1zZWxlY3Rpb24nKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5ld0ZpbGwgPSBpc0RhcmsgPyAnIzFmMjkzNycgOiAnI2ZmZmZmZidcbiAgICAgICAgICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoJ2ZpbGwnLCBuZXdGaWxsKVxuICAgICAgICAgICAgICAgIGVsLnN0eWxlLmZpbGwgPSBuZXdGaWxsXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gVGV4dCBhbmQgaWNvbnNcbiAgICAgICAgICBpZiAodGFnTmFtZSA9PT0gJ3RleHQnIHx8IHRhZ05hbWUgPT09ICd0c3BhbicpIHtcbiAgICAgICAgICAgIGNvbnN0IG5ld0NvbG9yID0gaXNEYXJrID8gJyNmZmZmZmYnIDogJyMwMDAwMDAnXG4gICAgICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoJ2ZpbGwnLCBuZXdDb2xvcilcbiAgICAgICAgICAgIGVsLnN0eWxlLmZpbGwgPSBuZXdDb2xvclxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gUnVuIG11bHRpcGxlIHRpbWVzIHRvIGNhdGNoIGFsbCB1cGRhdGVzXG4gICAgICBmb3JjZUNvbG9yVXBkYXRlKClcbiAgICAgIHNldFRpbWVvdXQoZm9yY2VDb2xvclVwZGF0ZSwgNTApXG4gICAgICBzZXRUaW1lb3V0KGZvcmNlQ29sb3JVcGRhdGUsIDEwMClcbiAgICAgIHNldFRpbWVvdXQoZm9yY2VDb2xvclVwZGF0ZSwgMjAwKVxuICAgICAgc2V0VGltZW91dChmb3JjZUNvbG9yVXBkYXRlLCA1MDApXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBhcHBseWluZyBCUE1OIHN0eWxlczonLCBlcnIpXG4gICAgfVxuICB9LCBbXSlcblxuICAvLyBJbml0aWFsaXplIEJQTU4gTW9kZWxlclxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGxldCBtb3VudGVkID0gdHJ1ZVxuICAgIGxldCBtb2RlbGVyOiBCcG1uTW9kZWxlciB8IG51bGwgPSBudWxsXG4gICAgbGV0IG9ic2VydmVyOiBNdXRhdGlvbk9ic2VydmVyIHwgbnVsbCA9IG51bGxcblxuICAgIGNvbnN0IGluaXRCcG1uID0gYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgY29udGFpbmVyID0gY29udGFpbmVyUmVmLmN1cnJlbnRcbiAgICAgIGlmICghY29udGFpbmVyIHx8ICFtb3VudGVkKSByZXR1cm5cblxuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gV2FpdCBmb3IgY29udGFpbmVyIHRvIGhhdmUgZGltZW5zaW9uc1xuICAgICAgICBpZiAoY29udGFpbmVyLm9mZnNldFdpZHRoID09PSAwIHx8IGNvbnRhaW5lci5vZmZzZXRIZWlnaHQgPT09IDApIHtcbiAgICAgICAgICBzZXRUaW1lb3V0KGluaXRCcG1uLCAxMDApXG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICAvLyBDcmVhdGUgbW9kZWxlciB3aXRoIGZ1bGwgZGVmYXVsdCBtb2R1bGVzIChpbmNsdWRpbmcgcGFsZXR0ZSlcbiAgICAgICAgbW9kZWxlciA9IG5ldyBCcG1uTW9kZWxlcih7XG4gICAgICAgICAgY29udGFpbmVyOiBjb250YWluZXIsXG4gICAgICAgICAga2V5Ym9hcmQ6IHtcbiAgICAgICAgICAgIGJpbmRUbzogd2luZG93XG4gICAgICAgICAgfSxcbiAgICAgICAgICAvLyBFbnN1cmUgYWxsIGRlZmF1bHQgbW9kdWxlcyBhcmUgZW5hYmxlZFxuICAgICAgICAgIGFkZGl0aW9uYWxNb2R1bGVzOiBbXSxcbiAgICAgICAgICBtb2RkbGVFeHRlbnNpb25zOiB7fVxuICAgICAgICB9KVxuICAgICAgICBcbiAgICAgICAgbW9kZWxlclJlZi5jdXJyZW50ID0gbW9kZWxlclxuXG4gICAgICAgIC8vIEltcG9ydCBkZWZhdWx0IGRpYWdyYW1cbiAgICAgICAgYXdhaXQgbW9kZWxlci5pbXBvcnRYTUwoREVGQVVMVF9CUE1OKVxuICAgICAgICBcbiAgICAgICAgLy8gV2FpdCBhIGJpdCBmb3IgY2FudmFzIHRvIGJlIGZ1bGx5IGluaXRpYWxpemVkXG4gICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCA1MCkpXG5cbiAgICAgICAgLy8gU2V0dXAgY29tbWFuZCBzdGFjayBsaXN0ZW5lcnMgLSB3aXRoIHNhZmV0eSBjaGVja3NcbiAgICAgICAgY29uc3QgZXZlbnRCdXMgPSBtb2RlbGVyLmdldCgnZXZlbnRCdXMnKSBhcyBhbnlcbiAgICAgICAgY29uc3QgY29tbWFuZFN0YWNrID0gbW9kZWxlci5nZXQoJ2NvbW1hbmRTdGFjaycpIGFzIGFueVxuICAgICAgICBcbiAgICAgICAgaWYgKCFldmVudEJ1cyB8fCAhY29tbWFuZFN0YWNrKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKCdCUE1OIG1vZHVsZXMgbm90IGZ1bGx5IGluaXRpYWxpemVkLCByZXRyeWluZy4uLicpXG4gICAgICAgICAgc2V0VGltZW91dChpbml0QnBtbiwgMTAwKVxuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBjb25zdCB1cGRhdGVVbmRvUmVkbyA9ICgpID0+IHtcbiAgICAgICAgICBpZiAoIW1vdW50ZWQpIHJldHVyblxuICAgICAgICAgIHNldENhblVuZG8oY29tbWFuZFN0YWNrLmNhblVuZG8oKSlcbiAgICAgICAgICBzZXRDYW5SZWRvKGNvbW1hbmRTdGFjay5jYW5SZWRvKCkpXG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGV2ZW50QnVzLm9uKCdjb21tYW5kU3RhY2suY2hhbmdlZCcsIHVwZGF0ZVVuZG9SZWRvKVxuICAgICAgICB1cGRhdGVVbmRvUmVkbygpXG4gICAgICAgIFxuICAgICAgICAvLyBUcmFjayBzZWxlY3Rpb24gY2hhbmdlcyBmb3IgYWxpZ25tZW50IHRvb2xzXG4gICAgICAgIGNvbnN0IHNlbGVjdGlvbiA9IG1vZGVsZXIuZ2V0KCdzZWxlY3Rpb24nKSBhcyBhbnlcbiAgICAgICAgZXZlbnRCdXMub24oJ3NlbGVjdGlvbi5jaGFuZ2VkJywgKGU6IGFueSkgPT4ge1xuICAgICAgICAgIGlmICghbW91bnRlZCkgcmV0dXJuXG4gICAgICAgICAgY29uc3QgZWxlbWVudHMgPSBlLm5ld1NlbGVjdGlvbiB8fCBbXVxuICAgICAgICAgIHNldFNlbGVjdGVkRWxlbWVudHMoZWxlbWVudHMpXG4gICAgICAgICAgXG4gICAgICAgICAgLy8gQXBwbHkgdmlzdWFsIGZlZWRiYWNrIGZvciBzZWxlY3Rpb25cbiAgICAgICAgICBpZiAoZWxlbWVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coYFNlbGVjdGVkICR7ZWxlbWVudHMubGVuZ3RofSBlbGVtZW50KHMpYClcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gRk9SQ0UgVFJBTlNQQVJFTkNZOiBSZW1vdmUgYW55IG9wYXF1ZSBzZWxlY3Rpb24gYm94ZXNcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICBjb25zdCBzZWxlY3Rpb25Cb3hlcyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5kanMtb3V0bGluZSByZWN0LCAuZGpzLXNlbGVjdGlvbiByZWN0LCBbY2xhc3MqPVwic2VsZWN0XCJdIHJlY3QnKVxuICAgICAgICAgICAgICBzZWxlY3Rpb25Cb3hlcy5mb3JFYWNoKChib3g6IGFueSkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIFNraXAgYWN0dWFsIHNoYXBlIHJlY3RhbmdsZXNcbiAgICAgICAgICAgICAgICBpZiAoYm94LmNsb3Nlc3QoJy5kanMtdmlzdWFsJykpIHJldHVyblxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vIEZvcmNlIHRyYW5zcGFyZW50IGZpbGxcbiAgICAgICAgICAgICAgICBib3guc3R5bGUuZmlsbCA9ICd0cmFuc3BhcmVudCdcbiAgICAgICAgICAgICAgICBib3guc3R5bGUuZmlsbE9wYWNpdHkgPSAnMCdcbiAgICAgICAgICAgICAgICBib3guc2V0QXR0cmlidXRlKCdmaWxsJywgJ25vbmUnKVxuICAgICAgICAgICAgICAgIGJveC5zZXRBdHRyaWJ1dGUoJ2ZpbGwtb3BhY2l0eScsICcwJylcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIC8vIEFsc28gY2hlY2sgZm9yIGFueSBzZWxlY3Rpb24gZnJhbWVzXG4gICAgICAgICAgICAgIGNvbnN0IGZyYW1lcyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5kanMtZnJhbWUsIC5kanMtc2VsZWN0aW9uLWZyYW1lLCAuZGpzLXNlbGVjdC12aXN1YWwnKVxuICAgICAgICAgICAgICBmcmFtZXMuZm9yRWFjaCgoZnJhbWU6IGFueSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChmcmFtZS50YWdOYW1lID09PSAncmVjdCcgfHwgZnJhbWUucXVlcnlTZWxlY3RvcigncmVjdCcpKSB7XG4gICAgICAgICAgICAgICAgICBjb25zdCByZWN0ID0gZnJhbWUudGFnTmFtZSA9PT0gJ3JlY3QnID8gZnJhbWUgOiBmcmFtZS5xdWVyeVNlbGVjdG9yKCdyZWN0JylcbiAgICAgICAgICAgICAgICAgIGlmIChyZWN0ICYmICFyZWN0LmNsb3Nlc3QoJy5kanMtdmlzdWFsJykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVjdC5zdHlsZS5maWxsID0gJ3RyYW5zcGFyZW50J1xuICAgICAgICAgICAgICAgICAgICByZWN0LnNldEF0dHJpYnV0ZSgnZmlsbCcsICdub25lJylcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9LCAwKVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICAgXG4gICAgICAgIC8vIEFkZCBrZXlib2FyZCBzaG9ydGN1dHNcbiAgICAgICAgY29uc3Qga2V5Ym9hcmQgPSBtb2RlbGVyLmdldCgna2V5Ym9hcmQnKSBhcyBhbnlcbiAgICAgICAgY29uc3QgZWRpdG9yQWN0aW9ucyA9IG1vZGVsZXIuZ2V0KCdlZGl0b3JBY3Rpb25zJykgYXMgYW55XG4gICAgICAgIFxuICAgICAgICBpZiAoa2V5Ym9hcmQgJiYgZWRpdG9yQWN0aW9ucykge1xuICAgICAgICAgIC8vIFJlZ2lzdGVyIEN0cmwrQSBmb3Igc2VsZWN0IGFsbFxuICAgICAgICAgIGVkaXRvckFjdGlvbnMucmVnaXN0ZXIoJ3NlbGVjdEFsbCcsICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnRSZWdpc3RyeSA9IG1vZGVsZXIuZ2V0KCdlbGVtZW50UmVnaXN0cnknKSBhcyBhbnlcbiAgICAgICAgICAgIGNvbnN0IGFsbEVsZW1lbnRzID0gZWxlbWVudFJlZ2lzdHJ5LmZpbHRlcigoZWxlbWVudDogYW55KSA9PiB7XG4gICAgICAgICAgICAgIHJldHVybiBlbGVtZW50LnR5cGUgIT09ICdsYWJlbCcgJiYgXG4gICAgICAgICAgICAgICAgICAgICBlbGVtZW50LnR5cGUgIT09ICdicG1uOlNlcXVlbmNlRmxvdycgJiZcbiAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuaWQgIT09ICdQcm9jZXNzXzEnICYmXG4gICAgICAgICAgICAgICAgICAgICAhZWxlbWVudC5sYWJlbFRhcmdldFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIHNlbGVjdGlvbi5zZWxlY3QoYWxsRWxlbWVudHMpXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgU2VsZWN0ZWQgYWxsICR7YWxsRWxlbWVudHMubGVuZ3RofSBlbGVtZW50c2ApXG4gICAgICAgICAgfSlcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBSZWdpc3RlciBzcGFjZWJhciBmb3IgcmVwbGFjZSBtZW51XG4gICAgICAgICAgZWRpdG9yQWN0aW9ucy5yZWdpc3Rlcignc2hvd1JlcGxhY2VNZW51JywgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc2VsZWN0ZWRFbGVtZW50cyA9IHNlbGVjdGlvbi5nZXQoKVxuICAgICAgICAgICAgaWYgKHNlbGVjdGVkRWxlbWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGVsZW1lbnQgPSBzZWxlY3RlZEVsZW1lbnRzWzBdXG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAvLyBTa2lwIGlmIGl0J3MgdGhlIHJvb3QgZWxlbWVudFxuICAgICAgICAgICAgICBpZiAoZWxlbWVudC5pZCA9PT0gJ1Byb2Nlc3NfMScgfHwgZWxlbWVudC50eXBlID09PSAnYnBtbjpQcm9jZXNzJykge1xuICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAvLyBHZXQgdGhlIHJlcGxhY2UgbWVudSBtb2R1bGVcbiAgICAgICAgICAgICAgY29uc3QgcG9wdXBNZW51ID0gbW9kZWxlci5nZXQoJ3BvcHVwTWVudScpIGFzIGFueVxuICAgICAgICAgICAgICBjb25zdCByZXBsYWNlTWVudVByb3ZpZGVyID0gbW9kZWxlci5nZXQoJ3JlcGxhY2VNZW51UHJvdmlkZXInKSBhcyBhbnlcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIGlmIChwb3B1cE1lbnUgJiYgcmVwbGFjZU1lbnVQcm92aWRlcikge1xuICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgcG9zaXRpb24gb2YgdGhlIHNlbGVjdGVkIGVsZW1lbnRcbiAgICAgICAgICAgICAgICBjb25zdCBlbGVtZW50UmVnaXN0cnkgPSBtb2RlbGVyLmdldCgnZWxlbWVudFJlZ2lzdHJ5JykgYXMgYW55XG4gICAgICAgICAgICAgICAgY29uc3QgZWxlbWVudFNoYXBlID0gZWxlbWVudFJlZ2lzdHJ5LmdldChlbGVtZW50LmlkKVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50U2hhcGUpIHtcbiAgICAgICAgICAgICAgICAgIC8vIENhbGN1bGF0ZSBwb3NpdGlvbiBmb3IgdGhlIHBvcHVwXG4gICAgICAgICAgICAgICAgICBjb25zdCBwb3NpdGlvbiA9IHtcbiAgICAgICAgICAgICAgICAgICAgeDogZWxlbWVudFNoYXBlLnggKyAoZWxlbWVudFNoYXBlLndpZHRoIHx8IDEwMCkgLyAyLFxuICAgICAgICAgICAgICAgICAgICB5OiBlbGVtZW50U2hhcGUueSAtIDEwXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgIC8vIEdldCByZXBsYWNlIG9wdGlvbnMgZm9yIHRoaXMgZWxlbWVudFxuICAgICAgICAgICAgICAgICAgY29uc3QgZW50cmllcyA9IHJlcGxhY2VNZW51UHJvdmlkZXIuZ2V0UG9wdXBNZW51RW50cmllcyhlbGVtZW50KVxuICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICBpZiAoZW50cmllcyAmJiBPYmplY3Qua2V5cyhlbnRyaWVzKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE9wZW4gdGhlIHBvcHVwIG1lbnVcbiAgICAgICAgICAgICAgICAgICAgcG9wdXBNZW51Lm9wZW4oZWxlbWVudCwgJ2JwbW4tcmVwbGFjZScsIHBvc2l0aW9uLCBlbnRyaWVzKVxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnUmVwbGFjZSBtZW51IG9wZW5lZCBmb3I6JywgZWxlbWVudC50eXBlKVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBGYWxsYmFjazogVHJ5IHRvIHRyaWdnZXIgdGhlIHJlcGxhY2UgdG9vbCBkaXJlY3RseVxuICAgICAgICAgICAgICAgIGNvbnN0IHJlcGxhY2VQcmV2aWV3ID0gbW9kZWxlci5nZXQoJ3JlcGxhY2VQcmV2aWV3JykgYXMgYW55XG4gICAgICAgICAgICAgICAgaWYgKHJlcGxhY2VQcmV2aWV3KSB7XG4gICAgICAgICAgICAgICAgICByZXBsYWNlUHJldmlldy50b2dnbGUoKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgICAgXG4gICAgICAgICAgLy8gQmluZCBrZXlib2FyZCBzaG9ydGN1dHNcbiAgICAgICAgICBrZXlib2FyZC5hZGRMaXN0ZW5lcigoY29udGV4dDogYW55KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBrZXkgPSBjb250ZXh0LmtleUV2ZW50LmtleVxuICAgICAgICAgICAgY29uc3QgY3RybCA9IGNvbnRleHQua2V5RXZlbnQuY3RybEtleSB8fCBjb250ZXh0LmtleUV2ZW50Lm1ldGFLZXlcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gQ3RybCtBIG9yIENtZCtBIGZvciBzZWxlY3QgYWxsXG4gICAgICAgICAgICBpZiAoY3RybCAmJiBrZXkgPT09ICdhJykge1xuICAgICAgICAgICAgICBlZGl0b3JBY3Rpb25zLnRyaWdnZXIoJ3NlbGVjdEFsbCcpXG4gICAgICAgICAgICAgIGNvbnRleHQua2V5RXZlbnQucHJldmVudERlZmF1bHQoKVxuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBTcGFjZWJhciBmb3IgcmVwbGFjZSBtZW51XG4gICAgICAgICAgICBpZiAoa2V5ID09PSAnICcgJiYgIWN0cmwgJiYgIWNvbnRleHQua2V5RXZlbnQuc2hpZnRLZXkgJiYgIWNvbnRleHQua2V5RXZlbnQuYWx0S2V5KSB7XG4gICAgICAgICAgICAgIC8vIENoZWNrIGlmIHdlJ3JlIG5vdCBpbiBhIHRleHQgaW5wdXRcbiAgICAgICAgICAgICAgY29uc3QgYWN0aXZlRWxlbWVudCA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnRcbiAgICAgICAgICAgICAgaWYgKGFjdGl2ZUVsZW1lbnQgJiYgKGFjdGl2ZUVsZW1lbnQudGFnTmFtZSA9PT0gJ0lOUFVUJyB8fCBhY3RpdmVFbGVtZW50LnRhZ05hbWUgPT09ICdURVhUQVJFQScpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIGVkaXRvckFjdGlvbnMudHJpZ2dlcignc2hvd1JlcGxhY2VNZW51JylcbiAgICAgICAgICAgICAgY29udGV4dC5rZXlFdmVudC5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgIH0pXG4gICAgICAgIH1cblxuICAgICAgICAvLyBBcHBseSBpbml0aWFsIHN0eWxlc1xuICAgICAgICBhcHBseUJwbW5TdHlsZXMobW9kZWxlciwgdGhlbWUpXG4gICAgICAgIFxuICAgICAgICAvLyBBZGQgYSBnbG9iYWwga2V5Ym9hcmQgbGlzdGVuZXIgZm9yIHNwYWNlYmFyIChmYWxsYmFjaylcbiAgICAgICAgY29uc3QgaGFuZGxlR2xvYmFsS2V5ZG93biA9IChlOiBLZXlib2FyZEV2ZW50KSA9PiB7XG4gICAgICAgICAgLy8gT25seSBoYW5kbGUgc3BhY2ViYXIgd2hlbiBjYW52YXMgaXMgZm9jdXNlZFxuICAgICAgICAgIGlmIChlLmtleSA9PT0gJyAnICYmICFlLmN0cmxLZXkgJiYgIWUubWV0YUtleSAmJiAhZS5zaGlmdEtleSAmJiAhZS5hbHRLZXkpIHtcbiAgICAgICAgICAgIGNvbnN0IGFjdGl2ZUVsZW1lbnQgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIFNraXAgaWYgdHlwaW5nIGluIGFuIGlucHV0XG4gICAgICAgICAgICBpZiAoYWN0aXZlRWxlbWVudCAmJiBcbiAgICAgICAgICAgICAgICAoYWN0aXZlRWxlbWVudC50YWdOYW1lID09PSAnSU5QVVQnIHx8IFxuICAgICAgICAgICAgICAgICBhY3RpdmVFbGVtZW50LnRhZ05hbWUgPT09ICdURVhUQVJFQScgfHxcbiAgICAgICAgICAgICAgICAgYWN0aXZlRWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2NvbnRlbnRlZGl0YWJsZScpID09PSAndHJ1ZScpKSB7XG4gICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBDaGVjayBpZiB0aGUgY2FudmFzIG9yIGl0cyBjb250YWluZXIgaGFzIGZvY3VzXG4gICAgICAgICAgICBjb25zdCBjYW52YXNFbGVtZW50ID0gY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoJy5kanMtY29udGFpbmVyJylcbiAgICAgICAgICAgIGlmIChjYW52YXNFbGVtZW50ICYmIChjYW52YXNFbGVtZW50LmNvbnRhaW5zKGFjdGl2ZUVsZW1lbnQpIHx8IGFjdGl2ZUVsZW1lbnQgPT09IGRvY3VtZW50LmJvZHkpKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHNlbGVjdGVkRWxlbWVudHMgPSBzZWxlY3Rpb24uZ2V0KClcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIGlmIChzZWxlY3RlZEVsZW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKVxuICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKClcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBjb25zdCBlbGVtZW50ID0gc2VsZWN0ZWRFbGVtZW50c1swXVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vIFNraXAgcm9vdCBlbGVtZW50XG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQuaWQgPT09ICdQcm9jZXNzXzEnIHx8IGVsZW1lbnQudHlwZSA9PT0gJ2JwbW46UHJvY2VzcycpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnU3BhY2ViYXIgcHJlc3NlZCB3aXRoIGVsZW1lbnQgc2VsZWN0ZWQ6JywgZWxlbWVudC50eXBlKVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vIFRyeSB0byBvcGVuIHJlcGxhY2UgbWVudVxuICAgICAgICAgICAgICAgIGNvbnN0IHBvcHVwTWVudSA9IG1vZGVsZXIuZ2V0KCdwb3B1cE1lbnUnKSBhcyBhbnlcbiAgICAgICAgICAgICAgICBjb25zdCByZXBsYWNlTWVudVByb3ZpZGVyID0gbW9kZWxlci5nZXQoJ3JlcGxhY2VNZW51UHJvdmlkZXInKSBhcyBhbnlcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBpZiAocG9wdXBNZW51ICYmIHJlcGxhY2VNZW51UHJvdmlkZXIpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGVsZW1lbnRSZWdpc3RyeSA9IG1vZGVsZXIuZ2V0KCdlbGVtZW50UmVnaXN0cnknKSBhcyBhbnlcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGVsZW1lbnRTaGFwZSA9IGVsZW1lbnRSZWdpc3RyeS5nZXQoZWxlbWVudC5pZClcbiAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgaWYgKGVsZW1lbnRTaGFwZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwb3NpdGlvbiA9IHtcbiAgICAgICAgICAgICAgICAgICAgICB4OiBlbGVtZW50U2hhcGUueCArIChlbGVtZW50U2hhcGUud2lkdGggfHwgMTAwKSAvIDIsXG4gICAgICAgICAgICAgICAgICAgICAgeTogZWxlbWVudFNoYXBlLnkgLSAxMFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBjb25zdCBlbnRyaWVzID0gcmVwbGFjZU1lbnVQcm92aWRlci5nZXRQb3B1cE1lbnVFbnRyaWVzKGVsZW1lbnQpXG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBpZiAoZW50cmllcyAmJiBPYmplY3Qua2V5cyhlbnRyaWVzKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcG9wdXBNZW51Lm9wZW4oZWxlbWVudCwgJ2JwbW4tcmVwbGFjZScsIHBvc2l0aW9uLCBlbnRyaWVzKVxuICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdSZXBsYWNlIG1lbnUgdHJpZ2dlcmVkIHZpYSBzcGFjZWJhcicpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIEF0dGFjaCB0aGUgZ2xvYmFsIGxpc3RlbmVyXG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBoYW5kbGVHbG9iYWxLZXlkb3duKVxuICAgICAgICBcbiAgICAgICAgLy8gU3RvcmUgcmVmZXJlbmNlIGZvciBjbGVhbnVwXG4gICAgICAgIG1vZGVsZXJSZWYuY3VycmVudC5fc3BhY2ViYXJIYW5kbGVyID0gaGFuZGxlR2xvYmFsS2V5ZG93blxuICAgICAgICBcbiAgICAgICAgLy8gQXBwbHkgaW5pdGlhbCBncmlkIHN0YXRlXG4gICAgICAgIGNvbnN0IGNhbnZhcyA9IG1vZGVsZXIuZ2V0KCdjYW52YXMnKSBhcyBhbnlcbiAgICAgICAgY29uc3QgY2FudmFzQ29udGFpbmVyID0gY2FudmFzLl9jb250YWluZXIgfHwgY2FudmFzLmdldENvbnRhaW5lcigpXG4gICAgICAgIGlmIChjYW52YXNDb250YWluZXIgJiYgc2hvd0dyaWQpIHtcbiAgICAgICAgICBjYW52YXNDb250YWluZXIuY2xhc3NMaXN0LmFkZCgnc2hvdy1ncmlkJylcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gU2V0IHVwIE11dGF0aW9uT2JzZXJ2ZXIgdG8gY2F0Y2ggZHluYW1pY2FsbHkgYWRkZWQgZWxlbWVudHNcbiAgICAgICAgaWYgKGNhbnZhc0NvbnRhaW5lcikge1xuICAgICAgICAgIG9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoKG11dGF0aW9ucykgPT4ge1xuICAgICAgICAgICAgY29uc3QgY3VycmVudFRoZW1lID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsYXNzTGlzdC5jb250YWlucygnZGFyaycpID8gJ2RhcmsnIDogJ2xpZ2h0J1xuICAgICAgICAgICAgY29uc3QgaXNEYXJrTW9kZSA9IGN1cnJlbnRUaGVtZSA9PT0gJ2RhcmsnXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIG11dGF0aW9ucy5mb3JFYWNoKChtdXRhdGlvbikgPT4ge1xuICAgICAgICAgICAgICAvLyBQcm9jZXNzIGFkZGVkIG5vZGVzXG4gICAgICAgICAgICAgIG11dGF0aW9uLmFkZGVkTm9kZXMuZm9yRWFjaCgobm9kZTogYW55KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IDEpIHsgLy8gRWxlbWVudCBub2RlXG4gICAgICAgICAgICAgICAgICAvLyBQcm9jZXNzIHRoZSBub2RlIGl0c2VsZiBpZiBpdCdzIGFuIFNWRyBlbGVtZW50XG4gICAgICAgICAgICAgICAgICBpZiAobm9kZS50YWdOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRhZ05hbWUgPSBub2RlLnRhZ05hbWUudG9Mb3dlckNhc2UoKVxuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgLy8gSU1NRURJQVRFIGZpeCBmb3IgcmVjdGFuZ2xlcyAoVGFza3MpXG4gICAgICAgICAgICAgICAgICAgIGlmICh0YWdOYW1lID09PSAncmVjdCcgfHwgdGFnTmFtZSA9PT0gJ2cnIHx8IHRhZ05hbWUgPT09ICdzdmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gRml4IHRoZSBub2RlIGl0c2VsZlxuICAgICAgICAgICAgICAgICAgICAgIGlmICh0YWdOYW1lID09PSAncmVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuc3R5bGUuc3Ryb2tlID0gaXNEYXJrTW9kZSA/ICcjZmZmZmZmJyA6ICcjMDAwMDAwJ1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoJ3N0cm9rZScsIGlzRGFya01vZGUgPyAnI2ZmZmZmZicgOiAnIzAwMDAwMCcpXG4gICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbm9kZS5jbG9zZXN0KCcuZGpzLW91dGxpbmUnKSAmJiAhbm9kZS5jbG9zZXN0KCcuZGpzLXNlbGVjdGlvbicpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuc3R5bGUuZmlsbCA9IGlzRGFya01vZGUgPyAnIzFmMjkzNycgOiAnI2ZmZmZmZidcbiAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoJ2ZpbGwnLCBpc0RhcmtNb2RlID8gJyMxZjI5MzcnIDogJyNmZmZmZmYnKVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAvLyBGaXggYWxsIHJlY3QgY2hpbGRyZW5cbiAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZWN0cyA9IG5vZGUucXVlcnlTZWxlY3RvckFsbCA/IG5vZGUucXVlcnlTZWxlY3RvckFsbCgncmVjdCcpIDogW11cbiAgICAgICAgICAgICAgICAgICAgICByZWN0cy5mb3JFYWNoKChyZWN0OiBhbnkpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlY3Quc3R5bGUuc3Ryb2tlID0gaXNEYXJrTW9kZSA/ICcjZmZmZmZmJyA6ICcjMDAwMDAwJ1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVjdC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZScsIGlzRGFya01vZGUgPyAnI2ZmZmZmZicgOiAnIzAwMDAwMCcpXG4gICAgICAgICAgICAgICAgICAgICAgICByZWN0LnN0eWxlLnN0cm9rZU9wYWNpdHkgPSAnMSdcbiAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFyZWN0LmNsb3Nlc3QoJy5kanMtb3V0bGluZScpICYmICFyZWN0LmNsb3Nlc3QoJy5kanMtc2VsZWN0aW9uJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmVjdC5zdHlsZS5maWxsID0gaXNEYXJrTW9kZSA/ICcjMWYyOTM3JyA6ICcjZmZmZmZmJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZWN0LnNldEF0dHJpYnV0ZSgnZmlsbCcsIGlzRGFya01vZGUgPyAnIzFmMjkzNycgOiAnI2ZmZmZmZicpXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgLy8gUHJvY2VzcyBhbGwgZGVzY2VuZGFudHNcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUucXVlcnlTZWxlY3RvckFsbCkge1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVsZW1lbnRzID0gbm9kZS5xdWVyeVNlbGVjdG9yQWxsKCcqJylcbiAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50cy5mb3JFYWNoKChlbDogYW55KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlbFRhZyA9IGVsLnRhZ05hbWU/LnRvTG93ZXJDYXNlKClcbiAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRm9yY2UgY29sb3JzIG9uIGFsbCBzaGFwZSBlbGVtZW50c1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVsVGFnID09PSAncmVjdCcgfHwgZWxUYWcgPT09ICdjaXJjbGUnIHx8IGVsVGFnID09PSAncG9seWdvbicgfHwgZWxUYWcgPT09ICdwYXRoJyB8fCBlbFRhZyA9PT0gJ2xpbmUnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbC5oYXNBdHRyaWJ1dGUoJ3N0cm9rZScpIHx8IGVsLnN0eWxlLnN0cm9rZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsLnN0eWxlLnN0cm9rZSA9IGlzRGFya01vZGUgPyAnI2ZmZmZmZicgOiAnIzAwMDAwMCdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZScsIGlzRGFya01vZGUgPyAnI2ZmZmZmZicgOiAnIzAwMDAwMCcpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWwuc3R5bGUuc3Ryb2tlT3BhY2l0eSA9ICcxJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKGVsVGFnID09PSAncmVjdCcgfHwgZWxUYWcgPT09ICdjaXJjbGUnIHx8IGVsVGFnID09PSAncG9seWdvbicpICYmIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIWVsLmNsb3Nlc3QoJy5kanMtb3V0bGluZScpICYmICFlbC5jbG9zZXN0KCcuZGpzLXNlbGVjdGlvbicpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWwuc3R5bGUuZmlsbCA9IGlzRGFya01vZGUgPyAnIzFmMjkzNycgOiAnI2ZmZmZmZidcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoJ2ZpbGwnLCBpc0RhcmtNb2RlID8gJyMxZjI5MzcnIDogJyNmZmZmZmYnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIC8vIEFsc28gY2hlY2sgYXR0cmlidXRlIGNoYW5nZXMgZm9yIHN0cm9rZS9maWxsXG4gICAgICAgICAgICAgIGlmIChtdXRhdGlvbi50eXBlID09PSAnYXR0cmlidXRlcycgJiYgbXV0YXRpb24udGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdGFyZ2V0ID0gbXV0YXRpb24udGFyZ2V0IGFzIGFueVxuICAgICAgICAgICAgICAgIGlmICh0YXJnZXQudGFnTmFtZSkge1xuICAgICAgICAgICAgICAgICAgY29uc3QgdGFnTmFtZSA9IHRhcmdldC50YWdOYW1lLnRvTG93ZXJDYXNlKClcbiAgICAgICAgICAgICAgICAgIGlmICh0YWdOYW1lID09PSAncmVjdCcgJiYgKG11dGF0aW9uLmF0dHJpYnV0ZU5hbWUgPT09ICdzdHJva2UnIHx8IG11dGF0aW9uLmF0dHJpYnV0ZU5hbWUgPT09ICdzdHlsZScpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEZvcmNlIGNvcnJlY3QgY29sb3IgaWYgaXQgd2FzIGNoYW5nZWQgdG8gd3JvbmcgY29sb3JcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY3VycmVudFN0cm9rZSA9IHRhcmdldC5nZXRBdHRyaWJ1dGUoJ3N0cm9rZScpIHx8IHRhcmdldC5zdHlsZS5zdHJva2VcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzRGFya01vZGUgJiYgKGN1cnJlbnRTdHJva2UgPT09ICcjMDAwMDAwJyB8fCBjdXJyZW50U3Ryb2tlID09PSAnYmxhY2snKSkge1xuICAgICAgICAgICAgICAgICAgICAgIHRhcmdldC5zdHlsZS5zdHJva2UgPSAnI2ZmZmZmZidcbiAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQuc2V0QXR0cmlidXRlKCdzdHJva2UnLCAnI2ZmZmZmZicpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfSlcbiAgICAgICAgICBcbiAgICAgICAgICBvYnNlcnZlci5vYnNlcnZlKGNhbnZhc0NvbnRhaW5lciwge1xuICAgICAgICAgICAgY2hpbGRMaXN0OiB0cnVlLFxuICAgICAgICAgICAgc3VidHJlZTogdHJ1ZSxcbiAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHRydWUsXG4gICAgICAgICAgICBhdHRyaWJ1dGVGaWx0ZXI6IFsnc3Ryb2tlJywgJ2ZpbGwnLCAnc3R5bGUnXVxuICAgICAgICAgIH0pXG4gICAgICAgIH1cblxuICAgICAgICBzZXRJc1JlYWR5KHRydWUpXG4gICAgICAgIHNldEVycm9yKG51bGwpXG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignQlBNTiBpbml0aWFsaXphdGlvbiBlcnJvcjonLCBlcnIpXG4gICAgICAgIHNldEVycm9yKGVyciBpbnN0YW5jZW9mIEVycm9yID8gZXJyLm1lc3NhZ2UgOiAnRmFpbGVkIHRvIGluaXRpYWxpemUnKVxuICAgICAgfVxuICAgIH1cblxuXG4gICAgLy8gU3RhcnQgaW5pdGlhbGl6YXRpb24gYWZ0ZXIgYSBzbWFsbCBkZWxheVxuICAgIHNldFRpbWVvdXQoaW5pdEJwbW4sIDEwMClcblxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBtb3VudGVkID0gZmFsc2VcbiAgICAgIGlmIChvYnNlcnZlcikge1xuICAgICAgICBvYnNlcnZlci5kaXNjb25uZWN0KClcbiAgICAgIH1cbiAgICAgIGlmIChtb2RlbGVyKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gUmVtb3ZlIGdsb2JhbCBrZXlib2FyZCBoYW5kbGVyXG4gICAgICAgICAgaWYgKG1vZGVsZXIuX3NwYWNlYmFySGFuZGxlcikge1xuICAgICAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIG1vZGVsZXIuX3NwYWNlYmFySGFuZGxlcilcbiAgICAgICAgICB9XG4gICAgICAgICAgbW9kZWxlci5kZXN0cm95KClcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIC8vIElnbm9yZSBjbGVhbnVwIGVycm9yc1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LCBbdGhlbWUsIGFwcGx5QnBtblN0eWxlc10pXG5cbiAgLy8gUmUtYXBwbHkgc3R5bGVzIHdoZW4gdGhlbWUgY2hhbmdlc1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChtb2RlbGVyUmVmLmN1cnJlbnQgJiYgaXNSZWFkeSkge1xuICAgICAgYXBwbHlCcG1uU3R5bGVzKG1vZGVsZXJSZWYuY3VycmVudCwgdGhlbWUpXG4gICAgICBcbiAgICAgIC8vIEFsc28gdXBkYXRlIGdyaWQgaWYgaXQncyBlbmFibGVkXG4gICAgICBjb25zdCBjYW52YXMgPSBtb2RlbGVyUmVmLmN1cnJlbnQuZ2V0KCdjYW52YXMnKSBhcyBhbnlcbiAgICAgIGNvbnN0IGNvbnRhaW5lciA9IGNhbnZhcz8uX2NvbnRhaW5lciB8fCBjYW52YXM/LmdldENvbnRhaW5lcigpXG4gICAgICBpZiAoY29udGFpbmVyICYmIHNob3dHcmlkKSB7XG4gICAgICAgIGNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKCdzaG93LWdyaWQnKVxuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBBR0dSRVNTSVZFOiBDb250aW51b3VzIFRhc2sgZml4IGZvciBzdHViYm9ybiBlbGVtZW50c1xuICAgICAgY29uc3QgZml4VGFza0NvbG9ycyA9ICgpID0+IHtcbiAgICAgICAgY29uc3QgaXNEYXJrID0gdGhlbWUgPT09ICdkYXJrJ1xuICAgICAgICBjb25zdCB0YXNrcyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLWVsZW1lbnQtaWQqPVwiVGFza1wiXScpXG4gICAgICAgIFxuICAgICAgICB0YXNrcy5mb3JFYWNoKHRhc2sgPT4ge1xuICAgICAgICAgIGNvbnN0IHJlY3RzID0gdGFzay5xdWVyeVNlbGVjdG9yQWxsKCdyZWN0JylcbiAgICAgICAgICByZWN0cy5mb3JFYWNoKHJlY3QgPT4ge1xuICAgICAgICAgICAgLy8gQ2hlY2sgY3VycmVudCBjb2xvclxuICAgICAgICAgICAgY29uc3QgY3VycmVudFN0cm9rZSA9IHJlY3QuZ2V0QXR0cmlidXRlKCdzdHJva2UnKSB8fCByZWN0LnN0eWxlLnN0cm9rZVxuICAgICAgICAgICAgY29uc3QgbmVlZHNGaXggPSBpc0RhcmsgPyBcbiAgICAgICAgICAgICAgKGN1cnJlbnRTdHJva2UgPT09ICcjMDAwMDAwJyB8fCBjdXJyZW50U3Ryb2tlID09PSAnYmxhY2snIHx8IGN1cnJlbnRTdHJva2UgPT09ICdyZ2IoMCwgMCwgMCknKSA6XG4gICAgICAgICAgICAgIChjdXJyZW50U3Ryb2tlID09PSAnI2ZmZmZmZicgfHwgY3VycmVudFN0cm9rZSA9PT0gJ3doaXRlJyB8fCBjdXJyZW50U3Ryb2tlID09PSAncmdiKDI1NSwgMjU1LCAyNTUpJylcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKG5lZWRzRml4KSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdGaXhpbmcgVGFzayBzdHJva2U6JywgY3VycmVudFN0cm9rZSwgJ+KGkicsIGlzRGFyayA/ICcjZmZmZmZmJyA6ICcjMDAwMDAwJylcbiAgICAgICAgICAgICAgcmVjdC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZScsIGlzRGFyayA/ICcjZmZmZmZmJyA6ICcjMDAwMDAwJylcbiAgICAgICAgICAgICAgcmVjdC5zdHlsZS5zdHJva2UgPSBpc0RhcmsgPyAnI2ZmZmZmZicgOiAnIzAwMDAwMCdcbiAgICAgICAgICAgICAgcmVjdC5zdHlsZS5zdHJva2VPcGFjaXR5ID0gJzEnXG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICBpZiAoIXJlY3QuY2xvc2VzdCgnLmRqcy1vdXRsaW5lJykpIHtcbiAgICAgICAgICAgICAgICByZWN0LnNldEF0dHJpYnV0ZSgnZmlsbCcsIGlzRGFyayA/ICcjMWYyOTM3JyA6ICcjZmZmZmZmJylcbiAgICAgICAgICAgICAgICByZWN0LnN0eWxlLmZpbGwgPSBpc0RhcmsgPyAnIzFmMjkzNycgOiAnI2ZmZmZmZidcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIFJ1biBtdWx0aXBsZSB0aW1lcyB0byBjYXRjaCBzdHViYm9ybiBlbGVtZW50c1xuICAgICAgY29uc3QgaW50ZXJ2YWxzID0gWzAsIDEwMCwgMjAwLCA1MDAsIDEwMDAsIDIwMDBdXG4gICAgICBpbnRlcnZhbHMuZm9yRWFjaChkZWxheSA9PiB7XG4gICAgICAgIHNldFRpbWVvdXQoZml4VGFza0NvbG9ycywgZGVsYXkpXG4gICAgICB9KVxuICAgIH1cbiAgfSwgW3RoZW1lLCBpc1JlYWR5LCBzaG93R3JpZCwgYXBwbHlCcG1uU3R5bGVzXSlcblxuICAvLyBIYW5kbGVyc1xuICBjb25zdCBoYW5kbGVTYXZlID0gdXNlQ2FsbGJhY2soYXN5bmMgKCkgPT4ge1xuICAgIGlmICghbW9kZWxlclJlZi5jdXJyZW50KSByZXR1cm5cbiAgICBzZXRTYXZpbmcodHJ1ZSlcbiAgICB0cnkge1xuICAgICAgY29uc3QgeyB4bWwgfSA9IGF3YWl0IG1vZGVsZXJSZWYuY3VycmVudC5zYXZlWE1MKHsgZm9ybWF0OiB0cnVlIH0pXG4gICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgnYnBtbi1kaWFncmFtJywgeG1sIHx8ICcnKVxuICAgICAgY29uc29sZS5sb2coJ1NhdmVkIHRvIGxvY2FsU3RvcmFnZScpXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdTYXZlIGVycm9yOicsIGVycilcbiAgICB9IGZpbmFsbHkge1xuICAgICAgc2V0U2F2aW5nKGZhbHNlKVxuICAgIH1cbiAgfSwgW10pXG5cbiAgY29uc3QgaGFuZGxlRXhwb3J0ID0gdXNlQ2FsbGJhY2soYXN5bmMgKCkgPT4ge1xuICAgIGlmICghbW9kZWxlclJlZi5jdXJyZW50KSByZXR1cm5cbiAgICB0cnkge1xuICAgICAgY29uc3QgeyB4bWwgfSA9IGF3YWl0IG1vZGVsZXJSZWYuY3VycmVudC5zYXZlWE1MKHsgZm9ybWF0OiB0cnVlIH0pXG4gICAgICBcbiAgICAgIC8vIFNob3cgZXhwb3J0IGZvcm1hdCBvcHRpb25zXG4gICAgICBjb25zdCBmb3JtYXQgPSBwcm9tcHQoJ0V4cG9ydCBmb3JtYXQ6IHhtbCwganNvbiwgb3IgeWFtbD8nLCAneG1sJyk/LnRvTG93ZXJDYXNlKClcbiAgICAgIFxuICAgICAgbGV0IGNvbnRlbnQgPSB4bWwgfHwgJydcbiAgICAgIGxldCBmaWxlbmFtZSA9ICdkaWFncmFtLmJwbW4nXG4gICAgICBsZXQgbWltZVR5cGUgPSAndGV4dC94bWwnXG4gICAgICBcbiAgICAgIGlmIChmb3JtYXQgPT09ICdqc29uJykge1xuICAgICAgICAvLyBDb252ZXJ0IFhNTCB0byBKU09OIHJlcHJlc2VudGF0aW9uXG4gICAgICAgIGNvbnN0IHBhcnNlciA9IG5ldyBET01QYXJzZXIoKVxuICAgICAgICBjb25zdCB4bWxEb2MgPSBwYXJzZXIucGFyc2VGcm9tU3RyaW5nKHhtbCB8fCAnJywgJ3RleHQveG1sJylcbiAgICAgICAgY29uc3QganNvbkRhdGEgPSB7XG4gICAgICAgICAgdHlwZTogJ2JwbW46ZGVmaW5pdGlvbnMnLFxuICAgICAgICAgIHByb2Nlc3M6IHhtbERvYy5xdWVyeVNlbGVjdG9yKCdwcm9jZXNzJyk/LmdldEF0dHJpYnV0ZSgnaWQnKSB8fCAnUHJvY2Vzc18xJyxcbiAgICAgICAgICBlbGVtZW50czogQXJyYXkuZnJvbSh4bWxEb2MucXVlcnlTZWxlY3RvckFsbCgnKltpZF0nKSkubWFwKGVsID0+ICh7XG4gICAgICAgICAgICBpZDogZWwuZ2V0QXR0cmlidXRlKCdpZCcpLFxuICAgICAgICAgICAgdHlwZTogZWwudGFnTmFtZSxcbiAgICAgICAgICAgIG5hbWU6IGVsLmdldEF0dHJpYnV0ZSgnbmFtZScpIHx8ICcnXG4gICAgICAgICAgfSkpXG4gICAgICAgIH1cbiAgICAgICAgY29udGVudCA9IEpTT04uc3RyaW5naWZ5KGpzb25EYXRhLCBudWxsLCAyKVxuICAgICAgICBmaWxlbmFtZSA9ICdkaWFncmFtLmpzb24nXG4gICAgICAgIG1pbWVUeXBlID0gJ2FwcGxpY2F0aW9uL2pzb24nXG4gICAgICB9IGVsc2UgaWYgKGZvcm1hdCA9PT0gJ3lhbWwnIHx8IGZvcm1hdCA9PT0gJ3ltbCcpIHtcbiAgICAgICAgLy8gU2ltcGxlIFlBTUwgY29udmVyc2lvbiAod291bGQgbmVlZCBwcm9wZXIgbGlicmFyeSBmb3IgcHJvZHVjdGlvbilcbiAgICAgICAgY29uc3QgcGFyc2VyID0gbmV3IERPTVBhcnNlcigpXG4gICAgICAgIGNvbnN0IHhtbERvYyA9IHBhcnNlci5wYXJzZUZyb21TdHJpbmcoeG1sIHx8ICcnLCAndGV4dC94bWwnKVxuICAgICAgICBsZXQgeWFtbENvbnRlbnQgPSAndHlwZTogYnBtbjpkZWZpbml0aW9uc1xcbidcbiAgICAgICAgeWFtbENvbnRlbnQgKz0gYHByb2Nlc3M6ICR7eG1sRG9jLnF1ZXJ5U2VsZWN0b3IoJ3Byb2Nlc3MnKT8uZ2V0QXR0cmlidXRlKCdpZCcpIHx8ICdQcm9jZXNzXzEnfVxcbmBcbiAgICAgICAgeWFtbENvbnRlbnQgKz0gJ2VsZW1lbnRzOlxcbidcbiAgICAgICAgeG1sRG9jLnF1ZXJ5U2VsZWN0b3JBbGwoJypbaWRdJykuZm9yRWFjaChlbCA9PiB7XG4gICAgICAgICAgeWFtbENvbnRlbnQgKz0gYCAgLSBpZDogJHtlbC5nZXRBdHRyaWJ1dGUoJ2lkJyl9XFxuYFxuICAgICAgICAgIHlhbWxDb250ZW50ICs9IGAgICAgdHlwZTogJHtlbC50YWdOYW1lfVxcbmBcbiAgICAgICAgICBjb25zdCBuYW1lID0gZWwuZ2V0QXR0cmlidXRlKCduYW1lJylcbiAgICAgICAgICBpZiAobmFtZSkgeWFtbENvbnRlbnQgKz0gYCAgICBuYW1lOiAke25hbWV9XFxuYFxuICAgICAgICB9KVxuICAgICAgICBjb250ZW50ID0geWFtbENvbnRlbnRcbiAgICAgICAgZmlsZW5hbWUgPSAnZGlhZ3JhbS55YW1sJ1xuICAgICAgICBtaW1lVHlwZSA9ICd0ZXh0L3lhbWwnXG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnN0IGJsb2IgPSBuZXcgQmxvYihbY29udGVudF0sIHsgdHlwZTogbWltZVR5cGUgfSlcbiAgICAgIGNvbnN0IHVybCA9IFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYilcbiAgICAgIGNvbnN0IGEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJylcbiAgICAgIGEuaHJlZiA9IHVybFxuICAgICAgYS5kb3dubG9hZCA9IGZpbGVuYW1lXG4gICAgICBhLmNsaWNrKClcbiAgICAgIFVSTC5yZXZva2VPYmplY3RVUkwodXJsKVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY29uc29sZS5lcnJvcignRXhwb3J0IGVycm9yOicsIGVycilcbiAgICB9XG4gIH0sIFtdKVxuXG4gIGNvbnN0IGhhbmRsZUltcG9ydCA9IHVzZUNhbGxiYWNrKChlOiBSZWFjdC5DaGFuZ2VFdmVudDxIVE1MSW5wdXRFbGVtZW50PikgPT4ge1xuICAgIGNvbnN0IGZpbGUgPSBlLnRhcmdldC5maWxlcz8uWzBdXG4gICAgaWYgKCFmaWxlIHx8ICFtb2RlbGVyUmVmLmN1cnJlbnQpIHJldHVyblxuICAgIFxuICAgIGNvbnN0IHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKClcbiAgICByZWFkZXIub25sb2FkID0gYXN5bmMgKGV2ZW50KSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBjb250ZW50ID0gZXZlbnQudGFyZ2V0Py5yZXN1bHQgYXMgc3RyaW5nXG4gICAgICAgIGxldCB4bWwgPSBjb250ZW50XG4gICAgICAgIFxuICAgICAgICAvLyBDaGVjayBmaWxlIGV4dGVuc2lvbiB0byBkZXRlcm1pbmUgZm9ybWF0XG4gICAgICAgIGNvbnN0IGV4dCA9IGZpbGUubmFtZS5zcGxpdCgnLicpLnBvcCgpPy50b0xvd2VyQ2FzZSgpXG4gICAgICAgIFxuICAgICAgICBpZiAoZXh0ID09PSAnanNvbicpIHtcbiAgICAgICAgICAvLyBDb252ZXJ0IEpTT04gYmFjayB0byBCUE1OIFhNTCAoc2ltcGxpZmllZClcbiAgICAgICAgICBjb25zdCBqc29uRGF0YSA9IEpTT04ucGFyc2UoY29udGVudClcbiAgICAgICAgICB4bWwgPSBERUZBVUxUX0JQTU4gLy8gU3RhcnQgd2l0aCBkZWZhdWx0IGFuZCBtb2RpZnlcbiAgICAgICAgICBjb25zb2xlLmxvZygnSW1wb3J0aW5nIEpTT04gZm9ybWF0OicsIGpzb25EYXRhKVxuICAgICAgICAgIC8vIFdvdWxkIG5lZWQgcHJvcGVyIEpTT04gdG8gQlBNTiBjb252ZXJzaW9uXG4gICAgICAgICAgYWxlcnQoJ0pTT04gaW1wb3J0OiBFbGVtZW50cyBkZXRlY3RlZCwgdXNpbmcgZGVmYXVsdCB0ZW1wbGF0ZS4gRnVsbCBKU09OIGltcG9ydCByZXF1aXJlcyBjdXN0b20gcGFyc2VyLicpXG4gICAgICAgIH0gZWxzZSBpZiAoZXh0ID09PSAneWFtbCcgfHwgZXh0ID09PSAneW1sJykge1xuICAgICAgICAgIC8vIENvbnZlcnQgWUFNTCBiYWNrIHRvIEJQTU4gWE1MIChzaW1wbGlmaWVkKVxuICAgICAgICAgIGNvbnNvbGUubG9nKCdJbXBvcnRpbmcgWUFNTCBmb3JtYXQnKVxuICAgICAgICAgIHhtbCA9IERFRkFVTFRfQlBNTiAvLyBTdGFydCB3aXRoIGRlZmF1bHRcbiAgICAgICAgICBhbGVydCgnWUFNTCBpbXBvcnQ6IFVzaW5nIGRlZmF1bHQgdGVtcGxhdGUuIEZ1bGwgWUFNTCBpbXBvcnQgcmVxdWlyZXMgeWFtbCBwYXJzZXIgbGlicmFyeS4nKVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBhd2FpdCBtb2RlbGVyUmVmLmN1cnJlbnQ/LmltcG9ydFhNTCh4bWwpXG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignSW1wb3J0IGVycm9yOicsIGVycilcbiAgICAgICAgYWxlcnQoJ0ltcG9ydCBmYWlsZWQ6ICcgKyAoZXJyIGluc3RhbmNlb2YgRXJyb3IgPyBlcnIubWVzc2FnZSA6ICdVbmtub3duIGVycm9yJykpXG4gICAgICB9XG4gICAgfVxuICAgIHJlYWRlci5yZWFkQXNUZXh0KGZpbGUpXG4gIH0sIFtdKVxuXG4gIGNvbnN0IGhhbmRsZVVuZG8gPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgY29uc3QgY29tbWFuZFN0YWNrID0gbW9kZWxlclJlZi5jdXJyZW50Py5nZXQoJ2NvbW1hbmRTdGFjaycpIGFzIGFueVxuICAgIGlmIChjb21tYW5kU3RhY2s/LmNhblVuZG8oKSkge1xuICAgICAgY29tbWFuZFN0YWNrLnVuZG8oKVxuICAgIH1cbiAgfSwgW10pXG5cbiAgY29uc3QgaGFuZGxlUmVkbyA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBjb25zdCBjb21tYW5kU3RhY2sgPSBtb2RlbGVyUmVmLmN1cnJlbnQ/LmdldCgnY29tbWFuZFN0YWNrJykgYXMgYW55XG4gICAgaWYgKGNvbW1hbmRTdGFjaz8uY2FuUmVkbygpKSB7XG4gICAgICBjb21tYW5kU3RhY2sucmVkbygpXG4gICAgfVxuICB9LCBbXSlcblxuICBjb25zdCBoYW5kbGVab29tSW4gPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgaWYgKCFtb2RlbGVyUmVmLmN1cnJlbnQpIHJldHVyblxuICAgIHRyeSB7XG4gICAgICBjb25zdCBjYW52YXMgPSBtb2RlbGVyUmVmLmN1cnJlbnQuZ2V0KCdjYW52YXMnKSBhcyBhbnlcbiAgICAgIGlmICghY2FudmFzKSByZXR1cm5cbiAgICAgIFxuICAgICAgLy8gRW5zdXJlIFNWRyBjb250ZXh0IGlzIGF2YWlsYWJsZVxuICAgICAgY29uc3Qgc3ZnID0gY2FudmFzLl9zdmcgfHwgY2FudmFzLl9jb250YWluZXI/LnF1ZXJ5U2VsZWN0b3IoJ3N2ZycpXG4gICAgICBpZiAoIXN2ZyB8fCAhc3ZnLmNyZWF0ZVNWR01hdHJpeCkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ1NWRyBub3QgcmVhZHkgZm9yIHpvb20nKVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc3QgY3VycmVudFpvb20gPSBjYW52YXMuem9vbSgpXG4gICAgICBpZiAodHlwZW9mIGN1cnJlbnRab29tID09PSAnbnVtYmVyJykge1xuICAgICAgICBjb25zdCBuZXdab29tID0gTWF0aC5taW4oY3VycmVudFpvb20gKiAxLjIsIDQpXG4gICAgICAgIGNhbnZhcy56b29tKG5ld1pvb20pXG4gICAgICAgIHNldFpvb21MZXZlbChNYXRoLnJvdW5kKG5ld1pvb20gKiAxMDApKVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY29uc29sZS5lcnJvcignWm9vbSBpbiBlcnJvcjonLCBlcnIpXG4gICAgfVxuICB9LCBbXSlcblxuICBjb25zdCBoYW5kbGVab29tT3V0ID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIGlmICghbW9kZWxlclJlZi5jdXJyZW50KSByZXR1cm5cbiAgICB0cnkge1xuICAgICAgY29uc3QgY2FudmFzID0gbW9kZWxlclJlZi5jdXJyZW50LmdldCgnY2FudmFzJykgYXMgYW55XG4gICAgICBpZiAoIWNhbnZhcykgcmV0dXJuXG4gICAgICBcbiAgICAgIC8vIEVuc3VyZSBTVkcgY29udGV4dCBpcyBhdmFpbGFibGVcbiAgICAgIGNvbnN0IHN2ZyA9IGNhbnZhcy5fc3ZnIHx8IGNhbnZhcy5fY29udGFpbmVyPy5xdWVyeVNlbGVjdG9yKCdzdmcnKVxuICAgICAgaWYgKCFzdmcgfHwgIXN2Zy5jcmVhdGVTVkdNYXRyaXgpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdTVkcgbm90IHJlYWR5IGZvciB6b29tJylcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnN0IGN1cnJlbnRab29tID0gY2FudmFzLnpvb20oKVxuICAgICAgaWYgKHR5cGVvZiBjdXJyZW50Wm9vbSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgY29uc3QgbmV3Wm9vbSA9IE1hdGgubWF4KGN1cnJlbnRab29tIC8gMS4yLCAwLjIpXG4gICAgICAgIGNhbnZhcy56b29tKG5ld1pvb20pXG4gICAgICAgIHNldFpvb21MZXZlbChNYXRoLnJvdW5kKG5ld1pvb20gKiAxMDApKVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY29uc29sZS5lcnJvcignWm9vbSBvdXQgZXJyb3I6JywgZXJyKVxuICAgIH1cbiAgfSwgW10pXG5cbiAgY29uc3QgaGFuZGxlWm9vbVJlc2V0ID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIGlmICghbW9kZWxlclJlZi5jdXJyZW50KSByZXR1cm5cbiAgICB0cnkge1xuICAgICAgY29uc3QgY2FudmFzID0gbW9kZWxlclJlZi5jdXJyZW50LmdldCgnY2FudmFzJykgYXMgYW55XG4gICAgICBpZiAoIWNhbnZhcykgcmV0dXJuXG4gICAgICBcbiAgICAgIC8vIEVuc3VyZSBTVkcgY29udGV4dCBpcyBhdmFpbGFibGVcbiAgICAgIGNvbnN0IHN2ZyA9IGNhbnZhcy5fc3ZnIHx8IGNhbnZhcy5fY29udGFpbmVyPy5xdWVyeVNlbGVjdG9yKCdzdmcnKVxuICAgICAgaWYgKCFzdmcgfHwgIXN2Zy5jcmVhdGVTVkdNYXRyaXgpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdTVkcgbm90IHJlYWR5IGZvciB6b29tJylcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICBcbiAgICAgIGNhbnZhcy56b29tKCdmaXQtdmlld3BvcnQnKVxuICAgICAgc2V0Wm9vbUxldmVsKDEwMClcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1pvb20gcmVzZXQgZXJyb3I6JywgZXJyKVxuICAgIH1cbiAgfSwgW10pXG5cbiAgY29uc3QgaGFuZGxlQ2xlYXIgPSB1c2VDYWxsYmFjayhhc3luYyAoKSA9PiB7XG4gICAgaWYgKCFtb2RlbGVyUmVmLmN1cnJlbnQpIHJldHVyblxuICAgIGlmIChjb25maXJtKCdDbGVhciB0aGUgZW50aXJlIGRpYWdyYW0/JykpIHtcbiAgICAgIGF3YWl0IG1vZGVsZXJSZWYuY3VycmVudC5pbXBvcnRYTUwoREVGQVVMVF9CUE1OKVxuICAgIH1cbiAgfSwgW10pXG5cbiAgY29uc3QgaGFuZGxlVGhlbWVUb2dnbGUgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgY29uc3QgbmV3VGhlbWUgPSB0aGVtZSA9PT0gJ2xpZ2h0JyA/ICdkYXJrJyA6ICdsaWdodCdcbiAgICBjb25zb2xlLmxvZygnVGhlbWUgdG9nZ2xlOicsIHRoZW1lLCAnLT4nLCBuZXdUaGVtZSlcbiAgICBzZXRUaGVtZShuZXdUaGVtZSkgIC8vIFRoZW1lUHJvdmlkZXIgaGFuZGxlcyBET00gbWFuaXB1bGF0aW9uXG4gICAgXG4gICAgLy8gUmUtYXBwbHkgQlBNTiBzdHlsZXMgd2l0aCBuZXcgdGhlbWVcbiAgICBpZiAobW9kZWxlclJlZi5jdXJyZW50KSB7XG4gICAgICAvLyBBcHBseSBuZXcgc3R5bGVzICh0aGlzIHdpbGwgdXBkYXRlIHRoZSBleGlzdGluZyBzdHlsZSBlbGVtZW50KVxuICAgICAgYXBwbHlCcG1uU3R5bGVzKG1vZGVsZXJSZWYuY3VycmVudCwgbmV3VGhlbWUpXG4gICAgICBcbiAgICAgIC8vIElNTUVESUFURTogRm9yY2UgZGlyZWN0IFNWRyBtYW5pcHVsYXRpb24gZm9yIGluc3RhbnQgY29sb3IgY2hhbmdlXG4gICAgICBjb25zdCBmb3JjZUNvbG9yVXBkYXRlID0gKCkgPT4ge1xuICAgICAgICBjb25zdCBpc0RhcmtNb2RlID0gbmV3VGhlbWUgPT09ICdkYXJrJ1xuICAgICAgICBjb25zdCBzdmdFbGVtZW50cyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5kanMtY29udGFpbmVyIHN2ZyAqJylcbiAgICAgICAgXG4gICAgICAgIHN2Z0VsZW1lbnRzLmZvckVhY2goKGVsOiBhbnkpID0+IHtcbiAgICAgICAgICAvLyBVcGRhdGUgc3Ryb2tlIGF0dHJpYnV0ZXNcbiAgICAgICAgICBpZiAoZWwuaGFzQXR0cmlidXRlKCdzdHJva2UnKSkge1xuICAgICAgICAgICAgY29uc3Qgc3Ryb2tlID0gZWwuZ2V0QXR0cmlidXRlKCdzdHJva2UnKVxuICAgICAgICAgICAgaWYgKHN0cm9rZSAmJiBzdHJva2UgIT09ICdub25lJyAmJiBzdHJva2UgIT09ICd0cmFuc3BhcmVudCcpIHtcbiAgICAgICAgICAgICAgLy8gRm9yY2Ugd2hpdGUgaW4gZGFyayBtb2RlLCBibGFjayBpbiBsaWdodCBtb2RlXG4gICAgICAgICAgICAgIGVsLnN0eWxlLnN0cm9rZSA9IGlzRGFya01vZGUgPyAnI2ZmZmZmZicgOiAnIzAwMDAwMCdcbiAgICAgICAgICAgICAgZWwuc2V0QXR0cmlidXRlKCdzdHJva2UnLCBpc0RhcmtNb2RlID8gJyNmZmZmZmYnIDogJyMwMDAwMDAnKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICAvLyBVcGRhdGUgZmlsbCBhdHRyaWJ1dGVzXG4gICAgICAgICAgaWYgKGVsLmhhc0F0dHJpYnV0ZSgnZmlsbCcpKSB7XG4gICAgICAgICAgICBjb25zdCBmaWxsID0gZWwuZ2V0QXR0cmlidXRlKCdmaWxsJylcbiAgICAgICAgICAgIGlmIChmaWxsICYmIGZpbGwgIT09ICdub25lJyAmJiBmaWxsICE9PSAndHJhbnNwYXJlbnQnKSB7XG4gICAgICAgICAgICAgIC8vIFNoYXBlcyBnZXQgYmFja2dyb3VuZCBjb2xvclxuICAgICAgICAgICAgICBpZiAoZWwudGFnTmFtZSA9PT0gJ3JlY3QnIHx8IGVsLnRhZ05hbWUgPT09ICdjaXJjbGUnIHx8IFxuICAgICAgICAgICAgICAgICAgZWwudGFnTmFtZSA9PT0gJ2VsbGlwc2UnIHx8IGVsLnRhZ05hbWUgPT09ICdwb2x5Z29uJykge1xuICAgICAgICAgICAgICAgIGVsLnN0eWxlLmZpbGwgPSBpc0RhcmtNb2RlID8gJyMxZjI5MzcnIDogJyNmZmZmZmYnXG4gICAgICAgICAgICAgICAgZWwuc2V0QXR0cmlidXRlKCdmaWxsJywgaXNEYXJrTW9kZSA/ICcjMWYyOTM3JyA6ICcjZmZmZmZmJylcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLyBUZXh0IGFuZCBpY29ucyBnZXQgZm9yZWdyb3VuZCBjb2xvclxuICAgICAgICAgICAgICBlbHNlIGlmIChlbC50YWdOYW1lID09PSAndGV4dCcgfHwgZWwudGFnTmFtZSA9PT0gJ3RzcGFuJyB8fCBlbC50YWdOYW1lID09PSAncGF0aCcpIHtcbiAgICAgICAgICAgICAgICBlbC5zdHlsZS5maWxsID0gaXNEYXJrTW9kZSA/ICcjZmZmZmZmJyA6ICcjMDAwMDAwJ1xuICAgICAgICAgICAgICAgIGVsLnNldEF0dHJpYnV0ZSgnZmlsbCcsIGlzRGFya01vZGUgPyAnI2ZmZmZmZicgOiAnIzAwMDAwMCcpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gQWxzbyBzZXQgc3R5bGUgYXR0cmlidXRlIHRvIG92ZXJyaWRlIGFueSBpbmxpbmUgc3R5bGVzXG4gICAgICAgICAgaWYgKGVsLnRhZ05hbWUgPT09ICdyZWN0JyB8fCBlbC50YWdOYW1lID09PSAnY2lyY2xlJyB8fCBcbiAgICAgICAgICAgICAgZWwudGFnTmFtZSA9PT0gJ2VsbGlwc2UnIHx8IGVsLnRhZ05hbWUgPT09ICdwb2x5Z29uJyB8fFxuICAgICAgICAgICAgICBlbC50YWdOYW1lID09PSAncGF0aCcgfHwgZWwudGFnTmFtZSA9PT0gJ2xpbmUnIHx8IGVsLnRhZ05hbWUgPT09ICdwb2x5bGluZScpIHtcbiAgICAgICAgICAgIGlmICghZWwuZ2V0QXR0cmlidXRlKCdzdHJva2Utb3BhY2l0eScpIHx8IGVsLmdldEF0dHJpYnV0ZSgnc3Ryb2tlLW9wYWNpdHknKSAhPT0gJzAnKSB7XG4gICAgICAgICAgICAgIGVsLnN0eWxlLnN0cm9rZSA9IGlzRGFya01vZGUgPyAnI2ZmZmZmZicgOiAnIzAwMDAwMCdcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIEV4ZWN1dGUgaW1tZWRpYXRlbHkgYW5kIGFmdGVyIGEgc2hvcnQgZGVsYXlcbiAgICAgIGZvcmNlQ29sb3JVcGRhdGUoKVxuICAgICAgc2V0VGltZW91dChmb3JjZUNvbG9yVXBkYXRlLCAxMDApXG4gICAgICBzZXRUaW1lb3V0KGZvcmNlQ29sb3JVcGRhdGUsIDMwMClcbiAgICAgIFxuICAgICAgLy8gRm9yY2UgYSBjb21wbGV0ZSByZWRyYXcgdXNpbmcgYSBzYWZlciBtZXRob2RcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGNhbnZhcyA9IG1vZGVsZXJSZWYuY3VycmVudC5nZXQoJ2NhbnZhcycpIGFzIGFueVxuICAgICAgICBjb25zdCBldmVudEJ1cyA9IG1vZGVsZXJSZWYuY3VycmVudC5nZXQoJ2V2ZW50QnVzJykgYXMgYW55XG4gICAgICAgIFxuICAgICAgICBpZiAoY2FudmFzICYmIGV2ZW50QnVzKSB7XG4gICAgICAgICAgLy8gR2V0IHRoZSBjdXJyZW50IHZpZXdib3ggdG8gcHJlc2VydmUgcG9zaXRpb25cbiAgICAgICAgICBjb25zdCB2aWV3Ym94ID0gY2FudmFzLnZpZXdib3goKVxuICAgICAgICAgIFxuICAgICAgICAgIC8vIERpcmVjdGx5IHVwZGF0ZSBjYW52YXMgY29udGFpbmVyIGJhY2tncm91bmRcbiAgICAgICAgICBjb25zdCBjb250YWluZXIgPSBjYW52YXMuX2NvbnRhaW5lciB8fCBjYW52YXMuZ2V0Q29udGFpbmVyKClcbiAgICAgICAgICBpZiAoY29udGFpbmVyKSB7XG4gICAgICAgICAgICBjb25zdCBiZ0NvbG9yID0gbmV3VGhlbWUgPT09ICdkYXJrJyA/ICcjMTExODI3JyA6ICcjZjlmYWZiJ1xuICAgICAgICAgICAgY29udGFpbmVyLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IGJnQ29sb3JcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gVXBkYXRlIFNWRyBiYWNrZ3JvdW5kXG4gICAgICAgICAgICBjb25zdCBzdmcgPSBjb250YWluZXIucXVlcnlTZWxlY3Rvcignc3ZnJylcbiAgICAgICAgICAgIGlmIChzdmcpIHtcbiAgICAgICAgICAgICAgc3ZnLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IGJnQ29sb3JcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gVXBkYXRlIGFueSB2aWV3cG9ydCBlbGVtZW50c1xuICAgICAgICAgICAgY29uc3Qgdmlld3BvcnQgPSBjb250YWluZXIucXVlcnlTZWxlY3RvcignLmRqcy12aWV3cG9ydCcpXG4gICAgICAgICAgICBpZiAodmlld3BvcnQpIHtcbiAgICAgICAgICAgICAgdmlld3BvcnQuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gYmdDb2xvclxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBQcmVzZXJ2ZSBncmlkIHN0YXRlIGFmdGVyIHRoZW1lIGNoYW5nZVxuICAgICAgICAgICAgaWYgKHNob3dHcmlkKSB7XG4gICAgICAgICAgICAgIGNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKCdzaG93LWdyaWQnKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICAvLyBTaW1wbHkgdHJpZ2dlciBhIGNhbnZhcyByZWZyZXNoIHdpdGhvdXQgbWFuaXB1bGF0aW5nIGVsZW1lbnRzXG4gICAgICAgICAgLy8gVGhlIHN0eWxlcyB3aWxsIGJlIHJlLWFwcGxpZWQgdGhyb3VnaCB0aGUgc3R5bGUgZWxlbWVudCB1cGRhdGVcbiAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKGV2ZW50QnVzKSB7XG4gICAgICAgICAgICAgIC8vIEp1c3QgZmlyZSBhIHZpZXdib3ggY2hhbmdlIHRvIHJlZnJlc2ggdGhlIHJlbmRlcmluZ1xuICAgICAgICAgICAgICBldmVudEJ1cy5maXJlKCdjYW52YXMudmlld2JveC5jaGFuZ2VkJywgdmlld2JveClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignVGhlbWUgdG9nZ2xlIHJlZHJhdyBlcnJvcjonLCBlcnIpXG4gICAgICB9XG4gICAgfVxuICB9LCBbdGhlbWUsIGFwcGx5QnBtblN0eWxlc10pXG5cbiAgLy8gQWxpZ25tZW50IGhhbmRsZXJzXG4gIGNvbnN0IGhhbmRsZUFsaWduTGVmdCA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBpZiAoIW1vZGVsZXJSZWYuY3VycmVudCB8fCBzZWxlY3RlZEVsZW1lbnRzLmxlbmd0aCA8IDIpIHJldHVyblxuICAgIGNvbnN0IG1vZGVsaW5nID0gbW9kZWxlclJlZi5jdXJyZW50LmdldCgnbW9kZWxpbmcnKSBhcyBhbnlcbiAgICBjb25zdCBjYW52YXMgPSBtb2RlbGVyUmVmLmN1cnJlbnQuZ2V0KCdjYW52YXMnKSBhcyBhbnlcbiAgICBcbiAgICAvLyBGaW5kIGxlZnRtb3N0IGVsZW1lbnRcbiAgICBjb25zdCBsZWZ0TW9zdCA9IHNlbGVjdGVkRWxlbWVudHMucmVkdWNlKChtaW4sIGVsKSA9PiBcbiAgICAgIGVsLnggPCBtaW4ueCA/IGVsIDogbWluLCBzZWxlY3RlZEVsZW1lbnRzWzBdKVxuICAgIFxuICAgIC8vIEFsaWduIGFsbCBlbGVtZW50cyB0byBsZWZ0bW9zdFxuICAgIHNlbGVjdGVkRWxlbWVudHMuZm9yRWFjaChlbCA9PiB7XG4gICAgICBpZiAoZWwuaWQgIT09IGxlZnRNb3N0LmlkKSB7XG4gICAgICAgIG1vZGVsaW5nLm1vdmVFbGVtZW50cyhbZWxdLCB7IHg6IGxlZnRNb3N0LnggLSBlbC54LCB5OiAwIH0pXG4gICAgICB9XG4gICAgfSlcbiAgfSwgW3NlbGVjdGVkRWxlbWVudHNdKVxuXG4gIGNvbnN0IGhhbmRsZUFsaWduQ2VudGVyID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIGlmICghbW9kZWxlclJlZi5jdXJyZW50IHx8IHNlbGVjdGVkRWxlbWVudHMubGVuZ3RoIDwgMikgcmV0dXJuXG4gICAgY29uc3QgbW9kZWxpbmcgPSBtb2RlbGVyUmVmLmN1cnJlbnQuZ2V0KCdtb2RlbGluZycpIGFzIGFueVxuICAgIFxuICAgIC8vIENhbGN1bGF0ZSBjZW50ZXIgcG9zaXRpb25cbiAgICBjb25zdCBjZW50ZXJYID0gc2VsZWN0ZWRFbGVtZW50cy5yZWR1Y2UoKHN1bSwgZWwpID0+IHN1bSArIGVsLnggKyBlbC53aWR0aC8yLCAwKSAvIHNlbGVjdGVkRWxlbWVudHMubGVuZ3RoXG4gICAgXG4gICAgLy8gQWxpZ24gYWxsIGVsZW1lbnRzIHRvIGNlbnRlclxuICAgIHNlbGVjdGVkRWxlbWVudHMuZm9yRWFjaChlbCA9PiB7XG4gICAgICBjb25zdCB0YXJnZXRYID0gY2VudGVyWCAtIGVsLndpZHRoLzJcbiAgICAgIG1vZGVsaW5nLm1vdmVFbGVtZW50cyhbZWxdLCB7IHg6IHRhcmdldFggLSBlbC54LCB5OiAwIH0pXG4gICAgfSlcbiAgfSwgW3NlbGVjdGVkRWxlbWVudHNdKVxuXG4gIGNvbnN0IGhhbmRsZUFsaWduUmlnaHQgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgaWYgKCFtb2RlbGVyUmVmLmN1cnJlbnQgfHwgc2VsZWN0ZWRFbGVtZW50cy5sZW5ndGggPCAyKSByZXR1cm5cbiAgICBjb25zdCBtb2RlbGluZyA9IG1vZGVsZXJSZWYuY3VycmVudC5nZXQoJ21vZGVsaW5nJykgYXMgYW55XG4gICAgXG4gICAgLy8gRmluZCByaWdodG1vc3QgZWxlbWVudFxuICAgIGNvbnN0IHJpZ2h0TW9zdCA9IHNlbGVjdGVkRWxlbWVudHMucmVkdWNlKChtYXgsIGVsKSA9PiBcbiAgICAgIChlbC54ICsgZWwud2lkdGgpID4gKG1heC54ICsgbWF4LndpZHRoKSA/IGVsIDogbWF4LCBzZWxlY3RlZEVsZW1lbnRzWzBdKVxuICAgIFxuICAgIGNvbnN0IHJpZ2h0RWRnZSA9IHJpZ2h0TW9zdC54ICsgcmlnaHRNb3N0LndpZHRoXG4gICAgXG4gICAgLy8gQWxpZ24gYWxsIGVsZW1lbnRzIHRvIHJpZ2h0bW9zdFxuICAgIHNlbGVjdGVkRWxlbWVudHMuZm9yRWFjaChlbCA9PiB7XG4gICAgICBpZiAoZWwuaWQgIT09IHJpZ2h0TW9zdC5pZCkge1xuICAgICAgICBjb25zdCB0YXJnZXRYID0gcmlnaHRFZGdlIC0gZWwud2lkdGhcbiAgICAgICAgbW9kZWxpbmcubW92ZUVsZW1lbnRzKFtlbF0sIHsgeDogdGFyZ2V0WCAtIGVsLngsIHk6IDAgfSlcbiAgICAgIH1cbiAgICB9KVxuICB9LCBbc2VsZWN0ZWRFbGVtZW50c10pXG5cbiAgY29uc3QgaGFuZGxlQWxpZ25Ub3AgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgaWYgKCFtb2RlbGVyUmVmLmN1cnJlbnQgfHwgc2VsZWN0ZWRFbGVtZW50cy5sZW5ndGggPCAyKSByZXR1cm5cbiAgICBjb25zdCBtb2RlbGluZyA9IG1vZGVsZXJSZWYuY3VycmVudC5nZXQoJ21vZGVsaW5nJykgYXMgYW55XG4gICAgXG4gICAgLy8gRmluZCB0b3Btb3N0IGVsZW1lbnRcbiAgICBjb25zdCB0b3BNb3N0ID0gc2VsZWN0ZWRFbGVtZW50cy5yZWR1Y2UoKG1pbiwgZWwpID0+IFxuICAgICAgZWwueSA8IG1pbi55ID8gZWwgOiBtaW4sIHNlbGVjdGVkRWxlbWVudHNbMF0pXG4gICAgXG4gICAgLy8gQWxpZ24gYWxsIGVsZW1lbnRzIHRvIHRvcG1vc3RcbiAgICBzZWxlY3RlZEVsZW1lbnRzLmZvckVhY2goZWwgPT4ge1xuICAgICAgaWYgKGVsLmlkICE9PSB0b3BNb3N0LmlkKSB7XG4gICAgICAgIG1vZGVsaW5nLm1vdmVFbGVtZW50cyhbZWxdLCB7IHg6IDAsIHk6IHRvcE1vc3QueSAtIGVsLnkgfSlcbiAgICAgIH1cbiAgICB9KVxuICB9LCBbc2VsZWN0ZWRFbGVtZW50c10pXG5cbiAgY29uc3QgaGFuZGxlQWxpZ25NaWRkbGUgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgaWYgKCFtb2RlbGVyUmVmLmN1cnJlbnQgfHwgc2VsZWN0ZWRFbGVtZW50cy5sZW5ndGggPCAyKSByZXR1cm5cbiAgICBjb25zdCBtb2RlbGluZyA9IG1vZGVsZXJSZWYuY3VycmVudC5nZXQoJ21vZGVsaW5nJykgYXMgYW55XG4gICAgXG4gICAgLy8gQ2FsY3VsYXRlIG1pZGRsZSBwb3NpdGlvblxuICAgIGNvbnN0IG1pZGRsZVkgPSBzZWxlY3RlZEVsZW1lbnRzLnJlZHVjZSgoc3VtLCBlbCkgPT4gc3VtICsgZWwueSArIGVsLmhlaWdodC8yLCAwKSAvIHNlbGVjdGVkRWxlbWVudHMubGVuZ3RoXG4gICAgXG4gICAgLy8gQWxpZ24gYWxsIGVsZW1lbnRzIHRvIG1pZGRsZVxuICAgIHNlbGVjdGVkRWxlbWVudHMuZm9yRWFjaChlbCA9PiB7XG4gICAgICBjb25zdCB0YXJnZXRZID0gbWlkZGxlWSAtIGVsLmhlaWdodC8yXG4gICAgICBtb2RlbGluZy5tb3ZlRWxlbWVudHMoW2VsXSwgeyB4OiAwLCB5OiB0YXJnZXRZIC0gZWwueSB9KVxuICAgIH0pXG4gIH0sIFtzZWxlY3RlZEVsZW1lbnRzXSlcblxuICBjb25zdCBoYW5kbGVBbGlnbkJvdHRvbSA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBpZiAoIW1vZGVsZXJSZWYuY3VycmVudCB8fCBzZWxlY3RlZEVsZW1lbnRzLmxlbmd0aCA8IDIpIHJldHVyblxuICAgIGNvbnN0IG1vZGVsaW5nID0gbW9kZWxlclJlZi5jdXJyZW50LmdldCgnbW9kZWxpbmcnKSBhcyBhbnlcbiAgICBcbiAgICAvLyBGaW5kIGJvdHRvbW1vc3QgZWxlbWVudFxuICAgIGNvbnN0IGJvdHRvbU1vc3QgPSBzZWxlY3RlZEVsZW1lbnRzLnJlZHVjZSgobWF4LCBlbCkgPT4gXG4gICAgICAoZWwueSArIGVsLmhlaWdodCkgPiAobWF4LnkgKyBtYXguaGVpZ2h0KSA/IGVsIDogbWF4LCBzZWxlY3RlZEVsZW1lbnRzWzBdKVxuICAgIFxuICAgIGNvbnN0IGJvdHRvbUVkZ2UgPSBib3R0b21Nb3N0LnkgKyBib3R0b21Nb3N0LmhlaWdodFxuICAgIFxuICAgIC8vIEFsaWduIGFsbCBlbGVtZW50cyB0byBib3R0b21tb3N0XG4gICAgc2VsZWN0ZWRFbGVtZW50cy5mb3JFYWNoKGVsID0+IHtcbiAgICAgIGlmIChlbC5pZCAhPT0gYm90dG9tTW9zdC5pZCkge1xuICAgICAgICBjb25zdCB0YXJnZXRZID0gYm90dG9tRWRnZSAtIGVsLmhlaWdodFxuICAgICAgICBtb2RlbGluZy5tb3ZlRWxlbWVudHMoW2VsXSwgeyB4OiAwLCB5OiB0YXJnZXRZIC0gZWwueSB9KVxuICAgICAgfVxuICAgIH0pXG4gIH0sIFtzZWxlY3RlZEVsZW1lbnRzXSlcblxuICAvLyBQcmV2aWV3IGhhbmRsZXIgLSBvcGVucyBYTUwgdmlld2VyIG1vZGFsXG4gIGNvbnN0IGhhbmRsZVByZXZpZXcgPSB1c2VDYWxsYmFjayhhc3luYyAoKSA9PiB7XG4gICAgaWYgKCFtb2RlbGVyUmVmLmN1cnJlbnQpIHJldHVyblxuICAgIHRyeSB7XG4gICAgICBjb25zdCB7IHhtbCB9ID0gYXdhaXQgbW9kZWxlclJlZi5jdXJyZW50LnNhdmVYTUwoeyBmb3JtYXQ6IHRydWUgfSlcbiAgICAgIHNldEN1cnJlbnRYbWwoeG1sIHx8ICcnKVxuICAgICAgc2V0U2hvd1htbFZpZXdlcih0cnVlKVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY29uc29sZS5lcnJvcignUHJldmlldyBlcnJvcjonLCBlcnIpXG4gICAgfVxuICB9LCBbXSlcblxuICAvLyBIYW5kbGUgWE1MIHNhdmUgZnJvbSB2aWV3ZXJcbiAgY29uc3QgaGFuZGxlWG1sU2F2ZSA9IHVzZUNhbGxiYWNrKGFzeW5jIChuZXdYbWw6IHN0cmluZykgPT4ge1xuICAgIGlmICghbW9kZWxlclJlZi5jdXJyZW50KSByZXR1cm5cbiAgICB0cnkge1xuICAgICAgYXdhaXQgbW9kZWxlclJlZi5jdXJyZW50LmltcG9ydFhNTChuZXdYbWwpXG4gICAgICBzZXRTaG93WG1sVmlld2VyKGZhbHNlKVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY29uc29sZS5lcnJvcignWE1MIGltcG9ydCBlcnJvcjonLCBlcnIpXG4gICAgICBhbGVydCgnRmFpbGVkIHRvIGFwcGx5IFhNTCBjaGFuZ2VzOiAnICsgKGVyciBpbnN0YW5jZW9mIEVycm9yID8gZXJyLm1lc3NhZ2UgOiAnVW5rbm93biBlcnJvcicpKVxuICAgIH1cbiAgfSwgW10pXG5cbiAgLy8gUnVuIFByb2Nlc3MgaGFuZGxlciAoc2ltdWxhdGlvbilcbiAgY29uc3QgaGFuZGxlUnVuUHJvY2VzcyA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBpZiAoIW1vZGVsZXJSZWYuY3VycmVudCkgcmV0dXJuXG4gICAgY29uc29sZS5sb2coJ1N0YXJ0aW5nIHByb2Nlc3Mgc2ltdWxhdGlvbi4uLicpXG4gICAgLy8gVGhpcyB3b3VsZCBpbnRlZ3JhdGUgd2l0aCBhIEJQTU4gZW5naW5lIGZvciBleGVjdXRpb25cbiAgICBhbGVydCgnUHJvY2VzcyBzaW11bGF0aW9uIHdvdWxkIHN0YXJ0IGhlcmUuIFRoaXMgcmVxdWlyZXMgaW50ZWdyYXRpb24gd2l0aCBhIEJQTU4gZW5naW5lLicpXG4gIH0sIFtdKVxuXG4gIC8vIE1lZXRpbmcvUHJlc2VudGF0aW9uIE1vZGUgaGFuZGxlclxuICBjb25zdCBoYW5kbGVNZWV0aW5nTW9kZSA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBzZXRJc01lZXRpbmdNb2RlKCFpc01lZXRpbmdNb2RlKVxuICAgIGlmICghaXNNZWV0aW5nTW9kZSkge1xuICAgICAgLy8gRW50ZXIgcHJlc2VudGF0aW9uIG1vZGUgLSBoaWRlIHBhbGV0dGUsIG1heGltaXplIGNhbnZhc1xuICAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnJlcXVlc3RGdWxsc2NyZWVuKClcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRXhpdCBwcmVzZW50YXRpb24gbW9kZVxuICAgICAgaWYgKGRvY3VtZW50LmZ1bGxzY3JlZW5FbGVtZW50KSB7XG4gICAgICAgIGRvY3VtZW50LmV4aXRGdWxsc2NyZWVuKClcbiAgICAgIH1cbiAgICB9XG4gIH0sIFtpc01lZXRpbmdNb2RlXSlcblxuICAvLyBNaW5pbWFwIHRvZ2dsZSBoYW5kbGVyXG4gIGNvbnN0IGhhbmRsZVRvZ2dsZU1pbmltYXAgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgc2V0SXNNaW5pbWFwT3BlbighaXNNaW5pbWFwT3BlbilcbiAgICAvLyBCUE1OLmpzIGRvZXNuJ3QgaGF2ZSBidWlsdC1pbiBtaW5pbWFwLCB3b3VsZCBuZWVkIGN1c3RvbSBpbXBsZW1lbnRhdGlvblxuICAgIGNvbnNvbGUubG9nKCdNaW5pbWFwIHRvZ2dsZTonLCAhaXNNaW5pbWFwT3BlbilcbiAgfSwgW2lzTWluaW1hcE9wZW5dKVxuXG4gIC8vIExhbmd1YWdlIHRvZ2dsZSBoYW5kbGVyXG4gIGNvbnN0IGhhbmRsZVRvZ2dsZUxhbmd1YWdlID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIC8vIFdvdWxkIGltcGxlbWVudCBpMThuIGhlcmVcbiAgICBjb25zb2xlLmxvZygnTGFuZ3VhZ2UgdG9nZ2xlIC0gd291bGQgaW1wbGVtZW50IGkxOG4nKVxuICAgIGFsZXJ0KCdMYW5ndWFnZSBzd2l0Y2hpbmcgd291bGQgYmUgaW1wbGVtZW50ZWQgd2l0aCBpMThuIGxpYnJhcnknKVxuICB9LCBbXSlcblxuICAvLyBHcmlkIHRvZ2dsZSBoYW5kbGVyXG4gIGNvbnN0IGhhbmRsZVRvZ2dsZUdyaWQgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgc2V0U2hvd0dyaWQocHJldiA9PiB7XG4gICAgICBjb25zdCBuZXdWYWx1ZSA9ICFwcmV2XG4gICAgICAvLyBBcHBseSBvciByZW1vdmUgZ3JpZCBjbGFzcyB0byBjYW52YXMgY29udGFpbmVyXG4gICAgICBpZiAobW9kZWxlclJlZi5jdXJyZW50KSB7XG4gICAgICAgIGNvbnN0IGNhbnZhcyA9IG1vZGVsZXJSZWYuY3VycmVudC5nZXQoJ2NhbnZhcycpIGFzIGFueVxuICAgICAgICBjb25zdCBjb250YWluZXIgPSBjYW52YXMuX2NvbnRhaW5lciB8fCBjYW52YXMuZ2V0Q29udGFpbmVyKClcbiAgICAgICAgaWYgKGNvbnRhaW5lcikge1xuICAgICAgICAgIGlmIChuZXdWYWx1ZSkge1xuICAgICAgICAgICAgY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoJ3Nob3ctZ3JpZCcpXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnRhaW5lci5jbGFzc0xpc3QucmVtb3ZlKCdzaG93LWdyaWQnKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG5ld1ZhbHVlXG4gICAgfSlcbiAgfSwgW10pXG5cbiAgLy8gSGFuZGxlIHBhbGV0dGUgYWN0aW9uc1xuICBjb25zdCBoYW5kbGVQYWxldHRlQWN0aW9uID0gdXNlQ2FsbGJhY2soKGFjdGlvbjogc3RyaW5nLCBldmVudDogRXZlbnQgfCBEcmFnRXZlbnQpID0+IHtcbiAgICBpZiAoIW1vZGVsZXJSZWYuY3VycmVudCkgcmV0dXJuXG4gICAgXG4gICAgY29uc29sZS5sb2coJ1BhbGV0dGUgYWN0aW9uOicsIGFjdGlvbilcbiAgICBcbiAgICAvLyBIYW5kbGUgdG9vbCBhY3Rpb25zXG4gICAgaWYgKGFjdGlvbi5lbmRzV2l0aCgnLXRvb2wnKSkge1xuICAgICAgc2V0QWN0aXZlVG9vbChhY3Rpb24ucmVwbGFjZSgnLXRvb2wnLCAnJykpXG4gICAgICBcbiAgICAgIC8vIEFjdGl2YXRlIHRoZSB0b29sIGluIEJQTU4uanNcbiAgICAgIGNvbnN0IGhhbmRUb29sID0gbW9kZWxlclJlZi5jdXJyZW50LmdldCgnaGFuZFRvb2wnKSBhcyBhbnlcbiAgICAgIGNvbnN0IGxhc3NvVG9vbCA9IG1vZGVsZXJSZWYuY3VycmVudC5nZXQoJ2xhc3NvVG9vbCcpIGFzIGFueVxuICAgICAgY29uc3Qgc3BhY2VUb29sID0gbW9kZWxlclJlZi5jdXJyZW50LmdldCgnc3BhY2VUb29sJykgYXMgYW55XG4gICAgICBjb25zdCBnbG9iYWxDb25uZWN0ID0gbW9kZWxlclJlZi5jdXJyZW50LmdldCgnZ2xvYmFsQ29ubmVjdCcpIGFzIGFueVxuICAgICAgXG4gICAgICBzd2l0Y2ggKGFjdGlvbikge1xuICAgICAgICBjYXNlICdoYW5kLXRvb2wnOlxuICAgICAgICAgIGhhbmRUb29sPy5hY3RpdmF0ZUhhbmQoZXZlbnQpXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAnbGFzc28tdG9vbCc6XG4gICAgICAgICAgbGFzc29Ub29sPy5hY3RpdmF0ZVNlbGVjdGlvbihldmVudClcbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlICdzcGFjZS10b29sJzpcbiAgICAgICAgICBzcGFjZVRvb2w/LmFjdGl2YXRlU2VsZWN0aW9uKGV2ZW50KVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgJ2dsb2JhbC1jb25uZWN0LXRvb2wnOlxuICAgICAgICAgIGdsb2JhbENvbm5lY3Q/LnRvZ2dsZShldmVudClcbiAgICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIFxuICAgIC8vIEhhbmRsZSBlbGVtZW50IGNyZWF0aW9uXG4gICAgaWYgKGFjdGlvbi5zdGFydHNXaXRoKCdjcmVhdGUuJykpIHtcbiAgICAgIGNvbnN0IGVsZW1lbnRGYWN0b3J5ID0gbW9kZWxlclJlZi5jdXJyZW50LmdldCgnZWxlbWVudEZhY3RvcnknKSBhcyBhbnlcbiAgICAgIGNvbnN0IGNyZWF0ZSA9IG1vZGVsZXJSZWYuY3VycmVudC5nZXQoJ2NyZWF0ZScpIGFzIGFueVxuICAgICAgY29uc3QgY2FudmFzID0gbW9kZWxlclJlZi5jdXJyZW50LmdldCgnY2FudmFzJykgYXMgYW55XG4gICAgICBjb25zdCBtb2RlbGluZyA9IG1vZGVsZXJSZWYuY3VycmVudC5nZXQoJ21vZGVsaW5nJykgYXMgYW55XG4gICAgICBcbiAgICAgIC8vIFBhcnNlIHRoZSBlbGVtZW50IHR5cGUgZnJvbSBhY3Rpb24gKGtlZXAgb3JpZ2luYWwgZm9ybWF0KVxuICAgICAgY29uc3QgZWxlbWVudFR5cGUgPSBhY3Rpb24ucmVwbGFjZSgnY3JlYXRlLicsICcnKVxuICAgICAgY29uc29sZS5sb2coJ0NyZWF0aW5nIGVsZW1lbnQgdHlwZTonLCBlbGVtZW50VHlwZSlcbiAgICAgIFxuICAgICAgbGV0IHR5cGUgPSAnYnBtbjpUYXNrJyAvLyBkZWZhdWx0XG4gICAgICBsZXQgZXZlbnREZWZpbml0aW9uVHlwZSA9IHVuZGVmaW5lZFxuICAgICAgXG4gICAgICAvLyBNYXAgYWxsIHBvc3NpYmxlIGFjdGlvbnMgdG8gQlBNTiB0eXBlcyAobWF0Y2hpbmcgcmVnaXN0cnkgYWN0aW9ucylcbiAgICAgIGNvbnN0IHR5cGVNYXA6IFJlY29yZDxzdHJpbmcsIHsgdHlwZTogc3RyaW5nOyBldmVudERlZmluaXRpb25UeXBlPzogc3RyaW5nOyBpc0V4cGFuZGVkPzogYm9vbGVhbjsgdHJpZ2dlcmVkQnlFdmVudD86IGJvb2xlYW4gfT4gPSB7XG4gICAgICAgIC8vIFN0YXJ0IEV2ZW50c1xuICAgICAgICAnc3RhcnQtZXZlbnQnOiB7IHR5cGU6ICdicG1uOlN0YXJ0RXZlbnQnIH0sXG4gICAgICAgICdzdGFydC1ldmVudC1tZXNzYWdlJzogeyB0eXBlOiAnYnBtbjpTdGFydEV2ZW50JywgZXZlbnREZWZpbml0aW9uVHlwZTogJ2JwbW46TWVzc2FnZUV2ZW50RGVmaW5pdGlvbicgfSxcbiAgICAgICAgJ3N0YXJ0LWV2ZW50LXRpbWVyJzogeyB0eXBlOiAnYnBtbjpTdGFydEV2ZW50JywgZXZlbnREZWZpbml0aW9uVHlwZTogJ2JwbW46VGltZXJFdmVudERlZmluaXRpb24nIH0sXG4gICAgICAgICdzdGFydC1ldmVudC1jb25kaXRpb25hbCc6IHsgdHlwZTogJ2JwbW46U3RhcnRFdmVudCcsIGV2ZW50RGVmaW5pdGlvblR5cGU6ICdicG1uOkNvbmRpdGlvbmFsRXZlbnREZWZpbml0aW9uJyB9LFxuICAgICAgICAnc3RhcnQtZXZlbnQtc2lnbmFsJzogeyB0eXBlOiAnYnBtbjpTdGFydEV2ZW50JywgZXZlbnREZWZpbml0aW9uVHlwZTogJ2JwbW46U2lnbmFsRXZlbnREZWZpbml0aW9uJyB9LFxuICAgICAgICBcbiAgICAgICAgLy8gRW5kIEV2ZW50c1xuICAgICAgICAnZW5kLWV2ZW50JzogeyB0eXBlOiAnYnBtbjpFbmRFdmVudCcgfSxcbiAgICAgICAgJ2VuZC1ldmVudC1tZXNzYWdlJzogeyB0eXBlOiAnYnBtbjpFbmRFdmVudCcsIGV2ZW50RGVmaW5pdGlvblR5cGU6ICdicG1uOk1lc3NhZ2VFdmVudERlZmluaXRpb24nIH0sXG4gICAgICAgICdlbmQtZXZlbnQtZXNjYWxhdGlvbic6IHsgdHlwZTogJ2JwbW46RW5kRXZlbnQnLCBldmVudERlZmluaXRpb25UeXBlOiAnYnBtbjpFc2NhbGF0aW9uRXZlbnREZWZpbml0aW9uJyB9LFxuICAgICAgICAnZW5kLWV2ZW50LWVycm9yJzogeyB0eXBlOiAnYnBtbjpFbmRFdmVudCcsIGV2ZW50RGVmaW5pdGlvblR5cGU6ICdicG1uOkVycm9yRXZlbnREZWZpbml0aW9uJyB9LFxuICAgICAgICAnZW5kLWV2ZW50LWNhbmNlbCc6IHsgdHlwZTogJ2JwbW46RW5kRXZlbnQnLCBldmVudERlZmluaXRpb25UeXBlOiAnYnBtbjpDYW5jZWxFdmVudERlZmluaXRpb24nIH0sXG4gICAgICAgICdlbmQtZXZlbnQtY29tcGVuc2F0aW9uJzogeyB0eXBlOiAnYnBtbjpFbmRFdmVudCcsIGV2ZW50RGVmaW5pdGlvblR5cGU6ICdicG1uOkNvbXBlbnNhdGVFdmVudERlZmluaXRpb24nIH0sXG4gICAgICAgICdlbmQtZXZlbnQtc2lnbmFsJzogeyB0eXBlOiAnYnBtbjpFbmRFdmVudCcsIGV2ZW50RGVmaW5pdGlvblR5cGU6ICdicG1uOlNpZ25hbEV2ZW50RGVmaW5pdGlvbicgfSxcbiAgICAgICAgJ2VuZC1ldmVudC10ZXJtaW5hdGUnOiB7IHR5cGU6ICdicG1uOkVuZEV2ZW50JywgZXZlbnREZWZpbml0aW9uVHlwZTogJ2JwbW46VGVybWluYXRlRXZlbnREZWZpbml0aW9uJyB9LFxuICAgICAgICBcbiAgICAgICAgLy8gSW50ZXJtZWRpYXRlIEV2ZW50c1xuICAgICAgICAnaW50ZXJtZWRpYXRlLWV2ZW50JzogeyB0eXBlOiAnYnBtbjpJbnRlcm1lZGlhdGVUaHJvd0V2ZW50JyB9LFxuICAgICAgICAnaW50ZXJtZWRpYXRlLWV2ZW50LW1lc3NhZ2UnOiB7IHR5cGU6ICdicG1uOkludGVybWVkaWF0ZVRocm93RXZlbnQnLCBldmVudERlZmluaXRpb25UeXBlOiAnYnBtbjpNZXNzYWdlRXZlbnREZWZpbml0aW9uJyB9LFxuICAgICAgICAnaW50ZXJtZWRpYXRlLWV2ZW50LXRpbWVyJzogeyB0eXBlOiAnYnBtbjpJbnRlcm1lZGlhdGVDYXRjaEV2ZW50JywgZXZlbnREZWZpbml0aW9uVHlwZTogJ2JwbW46VGltZXJFdmVudERlZmluaXRpb24nIH0sXG4gICAgICAgICdpbnRlcm1lZGlhdGUtZXZlbnQtZXNjYWxhdGlvbic6IHsgdHlwZTogJ2JwbW46SW50ZXJtZWRpYXRlVGhyb3dFdmVudCcsIGV2ZW50RGVmaW5pdGlvblR5cGU6ICdicG1uOkVzY2FsYXRpb25FdmVudERlZmluaXRpb24nIH0sXG4gICAgICAgICdpbnRlcm1lZGlhdGUtZXZlbnQtY29uZGl0aW9uYWwnOiB7IHR5cGU6ICdicG1uOkludGVybWVkaWF0ZUNhdGNoRXZlbnQnLCBldmVudERlZmluaXRpb25UeXBlOiAnYnBtbjpDb25kaXRpb25hbEV2ZW50RGVmaW5pdGlvbicgfSxcbiAgICAgICAgJ2ludGVybWVkaWF0ZS1ldmVudC1saW5rJzogeyB0eXBlOiAnYnBtbjpJbnRlcm1lZGlhdGVUaHJvd0V2ZW50JywgZXZlbnREZWZpbml0aW9uVHlwZTogJ2JwbW46TGlua0V2ZW50RGVmaW5pdGlvbicgfSxcbiAgICAgICAgJ2ludGVybWVkaWF0ZS1ldmVudC1jb21wZW5zYXRpb24nOiB7IHR5cGU6ICdicG1uOkludGVybWVkaWF0ZVRocm93RXZlbnQnLCBldmVudERlZmluaXRpb25UeXBlOiAnYnBtbjpDb21wZW5zYXRlRXZlbnREZWZpbml0aW9uJyB9LFxuICAgICAgICAnaW50ZXJtZWRpYXRlLWV2ZW50LXNpZ25hbCc6IHsgdHlwZTogJ2JwbW46SW50ZXJtZWRpYXRlVGhyb3dFdmVudCcsIGV2ZW50RGVmaW5pdGlvblR5cGU6ICdicG1uOlNpZ25hbEV2ZW50RGVmaW5pdGlvbicgfSxcbiAgICAgICAgXG4gICAgICAgIC8vIFRhc2tzXG4gICAgICAgICd0YXNrJzogeyB0eXBlOiAnYnBtbjpUYXNrJyB9LFxuICAgICAgICAndXNlci10YXNrJzogeyB0eXBlOiAnYnBtbjpVc2VyVGFzaycgfSxcbiAgICAgICAgJ3NlcnZpY2UtdGFzayc6IHsgdHlwZTogJ2JwbW46U2VydmljZVRhc2snIH0sXG4gICAgICAgICdzY3JpcHQtdGFzayc6IHsgdHlwZTogJ2JwbW46U2NyaXB0VGFzaycgfSxcbiAgICAgICAgJ2J1c2luZXNzLXJ1bGUtdGFzayc6IHsgdHlwZTogJ2JwbW46QnVzaW5lc3NSdWxlVGFzaycgfSxcbiAgICAgICAgJ3NlbmQtdGFzayc6IHsgdHlwZTogJ2JwbW46U2VuZFRhc2snIH0sXG4gICAgICAgICdyZWNlaXZlLXRhc2snOiB7IHR5cGU6ICdicG1uOlJlY2VpdmVUYXNrJyB9LFxuICAgICAgICAnbWFudWFsLXRhc2snOiB7IHR5cGU6ICdicG1uOk1hbnVhbFRhc2snIH0sXG4gICAgICAgIFxuICAgICAgICAvLyBHYXRld2F5c1xuICAgICAgICAnZXhjbHVzaXZlLWdhdGV3YXknOiB7IHR5cGU6ICdicG1uOkV4Y2x1c2l2ZUdhdGV3YXknIH0sXG4gICAgICAgICdwYXJhbGxlbC1nYXRld2F5JzogeyB0eXBlOiAnYnBtbjpQYXJhbGxlbEdhdGV3YXknIH0sXG4gICAgICAgICdpbmNsdXNpdmUtZ2F0ZXdheSc6IHsgdHlwZTogJ2JwbW46SW5jbHVzaXZlR2F0ZXdheScgfSxcbiAgICAgICAgJ2V2ZW50LWJhc2VkLWdhdGV3YXknOiB7IHR5cGU6ICdicG1uOkV2ZW50QmFzZWRHYXRld2F5JyB9LFxuICAgICAgICAnY29tcGxleC1nYXRld2F5JzogeyB0eXBlOiAnYnBtbjpDb21wbGV4R2F0ZXdheScgfSxcbiAgICAgICAgXG4gICAgICAgIC8vIFN1YiBQcm9jZXNzXG4gICAgICAgICdzdWJwcm9jZXNzLWV4cGFuZGVkJzogeyB0eXBlOiAnYnBtbjpTdWJQcm9jZXNzJywgaXNFeHBhbmRlZDogdHJ1ZSB9LFxuICAgICAgICAnc3VicHJvY2Vzcy1jb2xsYXBzZWQnOiB7IHR5cGU6ICdicG1uOlN1YlByb2Nlc3MnLCBpc0V4cGFuZGVkOiBmYWxzZSB9LFxuICAgICAgICAnZXZlbnQtc3VicHJvY2Vzcyc6IHsgdHlwZTogJ2JwbW46U3ViUHJvY2VzcycsIHRyaWdnZXJlZEJ5RXZlbnQ6IHRydWUgfSxcbiAgICAgICAgJ3RyYW5zYWN0aW9uJzogeyB0eXBlOiAnYnBtbjpUcmFuc2FjdGlvbicgfSxcbiAgICAgICAgJ2NhbGwtYWN0aXZpdHknOiB7IHR5cGU6ICdicG1uOkNhbGxBY3Rpdml0eScgfSxcbiAgICAgICAgXG4gICAgICAgIC8vIERhdGFcbiAgICAgICAgJ2RhdGEtb2JqZWN0JzogeyB0eXBlOiAnYnBtbjpEYXRhT2JqZWN0UmVmZXJlbmNlJyB9LFxuICAgICAgICAnZGF0YS1zdG9yZSc6IHsgdHlwZTogJ2JwbW46RGF0YVN0b3JlUmVmZXJlbmNlJyB9LFxuICAgICAgICAnZGF0YS1pbnB1dCc6IHsgdHlwZTogJ2JwbW46RGF0YUlucHV0JyB9LFxuICAgICAgICAnZGF0YS1vdXRwdXQnOiB7IHR5cGU6ICdicG1uOkRhdGFPdXRwdXQnIH0sXG4gICAgICAgIFxuICAgICAgICAvLyBQYXJ0aWNpcGFudHNcbiAgICAgICAgJ3BhcnRpY2lwYW50LWV4cGFuZGVkJzogeyB0eXBlOiAnYnBtbjpQYXJ0aWNpcGFudCcgfSxcbiAgICAgICAgJ3BhcnRpY2lwYW50JzogeyB0eXBlOiAnYnBtbjpQYXJ0aWNpcGFudCcgfSxcbiAgICAgICAgJ2xhbmUnOiB7IHR5cGU6ICdicG1uOkxhbmUnIH0sXG4gICAgICAgIFxuICAgICAgICAvLyBBcnRpZmFjdHNcbiAgICAgICAgJ2dyb3VwJzogeyB0eXBlOiAnYnBtbjpHcm91cCcgfSxcbiAgICAgICAgJ3RleHQtYW5ub3RhdGlvbic6IHsgdHlwZTogJ2JwbW46VGV4dEFubm90YXRpb24nIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc3QgZWxlbWVudENvbmZpZyA9IHR5cGVNYXBbZWxlbWVudFR5cGVdIHx8IHsgdHlwZTogJ2JwbW46VGFzaycgfVxuICAgICAgXG4gICAgICAvLyBDcmVhdGUgdGhlIHNoYXBlIHdpdGggcHJvcGVyIGNvbmZpZ3VyYXRpb25cbiAgICAgIGNvbnN0IHNoYXBlQ29uZmlnOiBhbnkgPSB7IHR5cGU6IGVsZW1lbnRDb25maWcudHlwZSB9XG4gICAgICBcbiAgICAgIC8vIEFkZCBldmVudCBkZWZpbml0aW9uIGlmIG5lZWRlZFxuICAgICAgaWYgKGVsZW1lbnRDb25maWcuZXZlbnREZWZpbml0aW9uVHlwZSkge1xuICAgICAgICBjb25zdCBicG1uRmFjdG9yeSA9IG1vZGVsZXJSZWYuY3VycmVudC5nZXQoJ2JwbW5GYWN0b3J5JykgYXMgYW55XG4gICAgICAgIGNvbnN0IGV2ZW50RGVmaW5pdGlvbiA9IGJwbW5GYWN0b3J5LmNyZWF0ZShlbGVtZW50Q29uZmlnLmV2ZW50RGVmaW5pdGlvblR5cGUpXG4gICAgICAgIHNoYXBlQ29uZmlnLmV2ZW50RGVmaW5pdGlvblR5cGUgPSBlbGVtZW50Q29uZmlnLmV2ZW50RGVmaW5pdGlvblR5cGVcbiAgICAgICAgc2hhcGVDb25maWcuYnVzaW5lc3NPYmplY3QgPSBicG1uRmFjdG9yeS5jcmVhdGUoZWxlbWVudENvbmZpZy50eXBlLCB7XG4gICAgICAgICAgZXZlbnREZWZpbml0aW9uczogW2V2ZW50RGVmaW5pdGlvbl1cbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gSGFuZGxlIGV4cGFuZGVkL2NvbGxhcHNlZCBzdGF0ZVxuICAgICAgaWYgKCdpc0V4cGFuZGVkJyBpbiBlbGVtZW50Q29uZmlnKSB7XG4gICAgICAgIHNoYXBlQ29uZmlnLmlzRXhwYW5kZWQgPSBlbGVtZW50Q29uZmlnLmlzRXhwYW5kZWRcbiAgICAgIH1cbiAgICAgIFxuICAgICAgaWYgKCd0cmlnZ2VyZWRCeUV2ZW50JyBpbiBlbGVtZW50Q29uZmlnKSB7XG4gICAgICAgIHNoYXBlQ29uZmlnLnRyaWdnZXJlZEJ5RXZlbnQgPSBlbGVtZW50Q29uZmlnLnRyaWdnZXJlZEJ5RXZlbnRcbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc3Qgc2hhcGUgPSBlbGVtZW50RmFjdG9yeS5jcmVhdGVTaGFwZShzaGFwZUNvbmZpZylcbiAgICAgIFxuICAgICAgLy8gSWYgaXQncyBhIGRyYWcgZXZlbnQsIHVzZSBkcmFnIGNvb3JkaW5hdGVzXG4gICAgICBpZiAoZXZlbnQgaW5zdGFuY2VvZiBEcmFnRXZlbnQpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ1N0YXJ0aW5nIGRyYWcgY3JlYXRlIGZvcjonLCBlbGVtZW50VHlwZSlcbiAgICAgICAgLy8gRm9yIGRyYWcgZXZlbnRzLCB3ZSBuZWVkIHRvIGxldCBCUE1OLmpzIGhhbmRsZSB0aGUgZHJvcFxuICAgICAgICAvLyBUaGUgY3JlYXRlIG1vZHVsZSBleHBlY3RzIHRoZSBkcmFnIGV2ZW50IHRvIGNvbnRpbnVlXG4gICAgICAgIGNyZWF0ZS5zdGFydChldmVudCwgc2hhcGUpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBGb3IgY2xpY2sgZXZlbnRzLCBkaXJlY3RseSBjcmVhdGUgdGhlIHNoYXBlIGF0IGEgcG9zaXRpb25cbiAgICAgICAgY29uc29sZS5sb2coJ0NyZWF0aW5nIGVsZW1lbnQgdmlhIGNsaWNrOicsIGVsZW1lbnRUeXBlKVxuICAgICAgICBjb25zdCByb290RWxlbWVudCA9IGNhbnZhcy5nZXRSb290RWxlbWVudCgpXG4gICAgICAgIGNvbnN0IHZpZXdwb3J0ID0gY2FudmFzLnZpZXdib3goKVxuICAgICAgICBcbiAgICAgICAgLy8gQ2FsY3VsYXRlIGNlbnRlciBwb3NpdGlvbiBhY2NvdW50aW5nIGZvciBjdXJyZW50IHpvb21cbiAgICAgICAgY29uc3QgY2VudGVyWCA9IHZpZXdwb3J0LnggKyAodmlld3BvcnQud2lkdGggLyAyKVxuICAgICAgICBjb25zdCBjZW50ZXJZID0gdmlld3BvcnQueSArICh2aWV3cG9ydC5oZWlnaHQgLyAyKVxuICAgICAgICBcbiAgICAgICAgLy8gRGlyZWN0bHkgY3JlYXRlIHRoZSBzaGFwZSB1c2luZyBtb2RlbGluZ1xuICAgICAgICBtb2RlbGluZy5jcmVhdGVTaGFwZShzaGFwZSwgeyB4OiBjZW50ZXJYLCB5OiBjZW50ZXJZIH0sIHJvb3RFbGVtZW50KVxuICAgICAgfVxuICAgIH1cbiAgfSwgW10pXG5cbiAgaWYgKGVycm9yKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwiaC1zY3JlZW4gZmxleCBpdGVtcy1jZW50ZXIganVzdGlmeS1jZW50ZXIgYmctZ3JheS01MFwiPlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInRleHQtY2VudGVyXCI+XG4gICAgICAgICAgPGgyIGNsYXNzTmFtZT1cInRleHQteGwgZm9udC1zZW1pYm9sZCB0ZXh0LXJlZC02MDAgbWItMlwiPkVycm9yIExvYWRpbmcgU3R1ZGlvPC9oMj5cbiAgICAgICAgICA8cCBjbGFzc05hbWU9XCJ0ZXh0LWdyYXktNjAwXCI+e2Vycm9yfTwvcD5cbiAgICAgICAgICA8YnV0dG9uIFxuICAgICAgICAgICAgb25DbGljaz17KCkgPT4gd2luZG93LmxvY2F0aW9uLnJlbG9hZCgpfVxuICAgICAgICAgICAgY2xhc3NOYW1lPVwibXQtNCBweC00IHB5LTIgYmctYmx1ZS02MDAgdGV4dC13aGl0ZSByb3VuZGVkIGhvdmVyOmJnLWJsdWUtNzAwXCJcbiAgICAgICAgICA+XG4gICAgICAgICAgICBSZWxvYWQgUGFnZVxuICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgIClcbiAgfVxuXG4gIHJldHVybiAoXG4gICAgPGRpdiBjbGFzc05hbWU9XCJoLXNjcmVlbiBmbGV4IGZsZXgtY29sIGJnLWJhY2tncm91bmRcIj5cbiAgICAgIHsvKiBVc2UgdGhlIHByb3BlciBCcG1uVG9vbGJhciBjb21wb25lbnQgd2l0aCBhbGwgaGFuZGxlcnMgKi99XG4gICAgICA8QnBtblRvb2xiYXJcbiAgICAgICAgb25TYXZlPXtoYW5kbGVTYXZlfVxuICAgICAgICBvbkV4cG9ydD17aGFuZGxlRXhwb3J0fVxuICAgICAgICBvbkltcG9ydD17KCkgPT4gZmlsZUlucHV0UmVmLmN1cnJlbnQ/LmNsaWNrKCl9XG4gICAgICAgIG9uVW5kbz17aGFuZGxlVW5kb31cbiAgICAgICAgb25SZWRvPXtoYW5kbGVSZWRvfVxuICAgICAgICBvblpvb21Jbj17aGFuZGxlWm9vbUlufVxuICAgICAgICBvblpvb21PdXQ9e2hhbmRsZVpvb21PdXR9XG4gICAgICAgIG9uRml0VG9WaWV3cG9ydD17aGFuZGxlWm9vbVJlc2V0fVxuICAgICAgICBvbkNsZWFyPXtoYW5kbGVDbGVhcn1cbiAgICAgICAgb25Ub2dnbGVUaGVtZT17aGFuZGxlVGhlbWVUb2dnbGV9XG4gICAgICAgIG9uQWxpZ25MZWZ0PXtoYW5kbGVBbGlnbkxlZnR9XG4gICAgICAgIG9uQWxpZ25DZW50ZXI9e2hhbmRsZUFsaWduQ2VudGVyfVxuICAgICAgICBvbkFsaWduUmlnaHQ9e2hhbmRsZUFsaWduUmlnaHR9XG4gICAgICAgIG9uQWxpZ25Ub3A9e2hhbmRsZUFsaWduVG9wfVxuICAgICAgICBvbkFsaWduTWlkZGxlPXtoYW5kbGVBbGlnbk1pZGRsZX1cbiAgICAgICAgb25BbGlnbkJvdHRvbT17aGFuZGxlQWxpZ25Cb3R0b219XG4gICAgICAgIG9uUHJldmlldz17aGFuZGxlUHJldmlld31cbiAgICAgICAgb25SdW49e2hhbmRsZVJ1blByb2Nlc3N9XG4gICAgICAgIG9uTWVldGluZ01vZGU9e2hhbmRsZU1lZXRpbmdNb2RlfVxuICAgICAgICBvblRvZ2dsZU1pbmltYXA9e2hhbmRsZVRvZ2dsZU1pbmltYXB9XG4gICAgICAgIG9uVG9nZ2xlTGFuZ3VhZ2U9e2hhbmRsZVRvZ2dsZUxhbmd1YWdlfVxuICAgICAgICBvblRvZ2dsZUdyaWQ9e2hhbmRsZVRvZ2dsZUdyaWR9XG4gICAgICAgIHRoZW1lPXt0aGVtZX1cbiAgICAgICAgem9vbUxldmVsPXt6b29tTGV2ZWx9XG4gICAgICAgIGNhblVuZG89e2NhblVuZG99XG4gICAgICAgIGNhblJlZG89e2NhblJlZG99XG4gICAgICAgIGRpc2FibGVkPXtzYXZpbmd9XG4gICAgICAgIGlzTWVldGluZ01vZGU9e2lzTWVldGluZ01vZGV9XG4gICAgICAgIGlzTWluaW1hcE9wZW49e2lzTWluaW1hcE9wZW59XG4gICAgICAgIHNob3dHcmlkPXtzaG93R3JpZH1cbiAgICAgIC8+XG5cbiAgICAgIHsvKiBNYWluIENvbnRlbnQgQXJlYSB3aXRoIEN1c3RvbSBDb2xsYXBzaWJsZSBQYWxldHRlICovfVxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4LTEgZmxleCBvdmVyZmxvdy1oaWRkZW5cIj5cbiAgICAgICAgey8qIEN1c3RvbSBDb2xsYXBzaWJsZSBCUE1OIEVsZW1lbnRzIFBhbGV0dGUgLSBoaWRlIGluIG1lZXRpbmcgbW9kZSAqL31cbiAgICAgICAgeyFpc01lZXRpbmdNb2RlICYmIChcbiAgICAgICAgICA8QnBtbkVsZW1lbnRzUGFsZXR0ZSBcbiAgICAgICAgICAgIG9uQWN0aW9uPXtoYW5kbGVQYWxldHRlQWN0aW9ufVxuICAgICAgICAgICAgYWN0aXZlVG9vbD17YWN0aXZlVG9vbH1cbiAgICAgICAgICAvPlxuICAgICAgICApfVxuXG4gICAgICAgIHsvKiBDYW52YXMgQ29udGFpbmVyICovfVxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZsZXgtMSByZWxhdGl2ZSBiZy1ncmF5LTUwIGRhcms6YmctZ3JheS05MDBcIj5cbiAgICAgICAgICA8ZGl2IFxuICAgICAgICAgICAgcmVmPXtjb250YWluZXJSZWZ9XG4gICAgICAgICAgICBjbGFzc05hbWU9XCJ3LWZ1bGwgaC1mdWxsXCJcbiAgICAgICAgICAgIHN0eWxlPXt7IFxuICAgICAgICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgICAgICAgICAgdG9wOiAwLFxuICAgICAgICAgICAgICBsZWZ0OiAwLFxuICAgICAgICAgICAgICByaWdodDogMCxcbiAgICAgICAgICAgICAgYm90dG9tOiAwXG4gICAgICAgICAgICB9fVxuICAgICAgICAgIC8+XG4gICAgICAgICAgeyFpc1JlYWR5ICYmIChcbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiYWJzb2x1dGUgaW5zZXQtMCBmbGV4IGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWNlbnRlciBiZy1ncmF5LTUwLzkwIGRhcms6YmctZ3JheS05MDAvOTAgcG9pbnRlci1ldmVudHMtbm9uZVwiPlxuICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInRleHQtY2VudGVyXCI+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJhbmltYXRlLXNwaW4gcm91bmRlZC1mdWxsIGgtMTIgdy0xMiBib3JkZXItYi0yIGJvcmRlci1ibHVlLTYwMCBteC1hdXRvXCI+PC9kaXY+XG4gICAgICAgICAgICAgICAgPHAgY2xhc3NOYW1lPVwibXQtNCB0ZXh0LWdyYXktNjAwIGRhcms6dGV4dC1ncmF5LTQwMFwiPkluaXRpYWxpemluZyBCUE1OIFN0dWRpby4uLjwvcD5cbiAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICApfVxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuXG4gICAgICB7LyogSGlkZGVuIGZpbGUgaW5wdXQgKi99XG4gICAgICA8aW5wdXRcbiAgICAgICAgcmVmPXtmaWxlSW5wdXRSZWZ9XG4gICAgICAgIHR5cGU9XCJmaWxlXCJcbiAgICAgICAgYWNjZXB0PVwiLmJwbW4sLnhtbFwiXG4gICAgICAgIG9uQ2hhbmdlPXtoYW5kbGVJbXBvcnR9XG4gICAgICAgIGNsYXNzTmFtZT1cImhpZGRlblwiXG4gICAgICAvPlxuXG4gICAgICB7LyogWE1MIFZpZXdlciBNb2RhbCAqL31cbiAgICAgIDxYbWxWaWV3ZXJNb2RhbFxuICAgICAgICBpc09wZW49e3Nob3dYbWxWaWV3ZXJ9XG4gICAgICAgIG9uQ2xvc2U9eygpID0+IHNldFNob3dYbWxWaWV3ZXIoZmFsc2UpfVxuICAgICAgICB4bWw9e2N1cnJlbnRYbWx9XG4gICAgICAgIG9uU2F2ZT17aGFuZGxlWG1sU2F2ZX1cbiAgICAgICAgcmVhZE9ubHk9e2ZhbHNlfVxuICAgICAgLz5cbiAgICA8L2Rpdj5cbiAgKVxufSJdLCJuYW1lcyI6WyJ1c2VFZmZlY3QiLCJ1c2VSZWYiLCJ1c2VTdGF0ZSIsInVzZUNhbGxiYWNrIiwiQnBtbk1vZGVsZXIiLCJCcG1uVG9vbGJhciIsIkJwbW5FbGVtZW50c1BhbGV0dGUiLCJYbWxWaWV3ZXJNb2RhbCIsInVzZVRoZW1lIiwiREVGQVVMVF9CUE1OIiwiQnBtblN0dWRpb0ZpeGVkIiwiY29udGFpbmVyUmVmIiwibW9kZWxlclJlZiIsImZpbGVJbnB1dFJlZiIsImlzUmVhZHkiLCJzZXRJc1JlYWR5IiwiZXJyb3IiLCJzZXRFcnJvciIsImNhblVuZG8iLCJzZXRDYW5VbmRvIiwiY2FuUmVkbyIsInNldENhblJlZG8iLCJ0aGVtZSIsInNldFRoZW1lIiwic3R5bGVFbGVtZW50UmVmIiwiem9vbUxldmVsIiwic2V0Wm9vbUxldmVsIiwic2F2aW5nIiwic2V0U2F2aW5nIiwiYWN0aXZlVG9vbCIsInNldEFjdGl2ZVRvb2wiLCJ1bmRlZmluZWQiLCJpc01lZXRpbmdNb2RlIiwic2V0SXNNZWV0aW5nTW9kZSIsImlzTWluaW1hcE9wZW4iLCJzZXRJc01pbmltYXBPcGVuIiwic2hvd0dyaWQiLCJzZXRTaG93R3JpZCIsInNob3dQcmV2aWV3Iiwic2V0U2hvd1ByZXZpZXciLCJzaG93WG1sVmlld2VyIiwic2V0U2hvd1htbFZpZXdlciIsImN1cnJlbnRYbWwiLCJzZXRDdXJyZW50WG1sIiwic2VsZWN0ZWRFbGVtZW50cyIsInNldFNlbGVjdGVkRWxlbWVudHMiLCJhcHBseUJwbW5TdHlsZXMiLCJtb2RlbGVyIiwiY3VycmVudFRoZW1lIiwiY2FudmFzIiwiZ2V0IiwiY29udGFpbmVyIiwiX2NvbnRhaW5lciIsImdldENvbnRhaW5lciIsInN2ZyIsInF1ZXJ5U2VsZWN0b3IiLCJfc3ZnIiwiY3JlYXRlU1ZHTWF0cml4IiwiY29uc29sZSIsIndhcm4iLCJzZXRUaW1lb3V0Iiwic3R5bGUiLCJjdXJyZW50IiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50IiwiaWQiLCJpc0RhcmsiLCJsb2ciLCJ0ZXh0Q29udGVudCIsInBhcmVudE5vZGUiLCJoZWFkIiwiYXBwZW5kQ2hpbGQiLCJjbGFzc0xpc3QiLCJhZGQiLCJyZW1vdmUiLCJiYWNrZ3JvdW5kQ29sb3IiLCJzdmdFbGVtZW50IiwiZXZlbnRCdXMiLCJmaXJlIiwiZm9yY2VDb2xvclVwZGF0ZSIsInN2Z0VsZW1lbnRzIiwicXVlcnlTZWxlY3RvckFsbCIsImZvckVhY2giLCJlbCIsInRhZ05hbWUiLCJ0b0xvd2VyQ2FzZSIsImhhc0F0dHJpYnV0ZSIsInN0cm9rZSIsImN1cnJlbnRTdHJva2UiLCJnZXRBdHRyaWJ1dGUiLCJuZWVkc0ZpeCIsIm5ld1N0cm9rZSIsInNldEF0dHJpYnV0ZSIsInN0cm9rZU9wYWNpdHkiLCJjdXJyZW50RmlsbCIsImZpbGwiLCJjbG9zZXN0IiwibmV3RmlsbCIsIm5ld0NvbG9yIiwiZXJyIiwibW91bnRlZCIsIm9ic2VydmVyIiwiaW5pdEJwbW4iLCJvZmZzZXRXaWR0aCIsIm9mZnNldEhlaWdodCIsImtleWJvYXJkIiwiYmluZFRvIiwid2luZG93IiwiYWRkaXRpb25hbE1vZHVsZXMiLCJtb2RkbGVFeHRlbnNpb25zIiwiaW1wb3J0WE1MIiwiUHJvbWlzZSIsInJlc29sdmUiLCJjb21tYW5kU3RhY2siLCJ1cGRhdGVVbmRvUmVkbyIsIm9uIiwic2VsZWN0aW9uIiwiZSIsImVsZW1lbnRzIiwibmV3U2VsZWN0aW9uIiwibGVuZ3RoIiwic2VsZWN0aW9uQm94ZXMiLCJib3giLCJmaWxsT3BhY2l0eSIsImZyYW1lcyIsImZyYW1lIiwicmVjdCIsImVkaXRvckFjdGlvbnMiLCJyZWdpc3RlciIsImVsZW1lbnRSZWdpc3RyeSIsImFsbEVsZW1lbnRzIiwiZmlsdGVyIiwiZWxlbWVudCIsInR5cGUiLCJsYWJlbFRhcmdldCIsInNlbGVjdCIsInBvcHVwTWVudSIsInJlcGxhY2VNZW51UHJvdmlkZXIiLCJlbGVtZW50U2hhcGUiLCJwb3NpdGlvbiIsIngiLCJ3aWR0aCIsInkiLCJlbnRyaWVzIiwiZ2V0UG9wdXBNZW51RW50cmllcyIsIk9iamVjdCIsImtleXMiLCJvcGVuIiwicmVwbGFjZVByZXZpZXciLCJ0b2dnbGUiLCJhZGRMaXN0ZW5lciIsImNvbnRleHQiLCJrZXkiLCJrZXlFdmVudCIsImN0cmwiLCJjdHJsS2V5IiwibWV0YUtleSIsInRyaWdnZXIiLCJwcmV2ZW50RGVmYXVsdCIsInNoaWZ0S2V5IiwiYWx0S2V5IiwiYWN0aXZlRWxlbWVudCIsImhhbmRsZUdsb2JhbEtleWRvd24iLCJjYW52YXNFbGVtZW50IiwiY29udGFpbnMiLCJib2R5Iiwic3RvcFByb3BhZ2F0aW9uIiwiYWRkRXZlbnRMaXN0ZW5lciIsIl9zcGFjZWJhckhhbmRsZXIiLCJjYW52YXNDb250YWluZXIiLCJNdXRhdGlvbk9ic2VydmVyIiwibXV0YXRpb25zIiwiZG9jdW1lbnRFbGVtZW50IiwiaXNEYXJrTW9kZSIsIm11dGF0aW9uIiwiYWRkZWROb2RlcyIsIm5vZGUiLCJub2RlVHlwZSIsInJlY3RzIiwiZWxUYWciLCJ0YXJnZXQiLCJhdHRyaWJ1dGVOYW1lIiwib2JzZXJ2ZSIsImNoaWxkTGlzdCIsInN1YnRyZWUiLCJhdHRyaWJ1dGVzIiwiYXR0cmlidXRlRmlsdGVyIiwiRXJyb3IiLCJtZXNzYWdlIiwiZGlzY29ubmVjdCIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJkZXN0cm95IiwiZml4VGFza0NvbG9ycyIsInRhc2tzIiwidGFzayIsImludGVydmFscyIsImRlbGF5IiwiaGFuZGxlU2F2ZSIsInhtbCIsInNhdmVYTUwiLCJmb3JtYXQiLCJsb2NhbFN0b3JhZ2UiLCJzZXRJdGVtIiwiaGFuZGxlRXhwb3J0IiwicHJvbXB0IiwiY29udGVudCIsImZpbGVuYW1lIiwibWltZVR5cGUiLCJ4bWxEb2MiLCJwYXJzZXIiLCJET01QYXJzZXIiLCJwYXJzZUZyb21TdHJpbmciLCJqc29uRGF0YSIsInByb2Nlc3MiLCJBcnJheSIsImZyb20iLCJtYXAiLCJuYW1lIiwiSlNPTiIsInN0cmluZ2lmeSIsInlhbWxDb250ZW50IiwiYmxvYiIsIkJsb2IiLCJ1cmwiLCJVUkwiLCJjcmVhdGVPYmplY3RVUkwiLCJhIiwiaHJlZiIsImRvd25sb2FkIiwiY2xpY2siLCJyZXZva2VPYmplY3RVUkwiLCJoYW5kbGVJbXBvcnQiLCJmaWxlIiwiZmlsZXMiLCJyZWFkZXIiLCJGaWxlUmVhZGVyIiwib25sb2FkIiwiZXZlbnQiLCJyZXN1bHQiLCJleHQiLCJzcGxpdCIsInBvcCIsInBhcnNlIiwiYWxlcnQiLCJyZWFkQXNUZXh0IiwiaGFuZGxlVW5kbyIsInVuZG8iLCJoYW5kbGVSZWRvIiwicmVkbyIsImhhbmRsZVpvb21JbiIsImN1cnJlbnRab29tIiwiem9vbSIsIm5ld1pvb20iLCJNYXRoIiwibWluIiwicm91bmQiLCJoYW5kbGVab29tT3V0IiwibWF4IiwiaGFuZGxlWm9vbVJlc2V0IiwiaGFuZGxlQ2xlYXIiLCJjb25maXJtIiwiaGFuZGxlVGhlbWVUb2dnbGUiLCJuZXdUaGVtZSIsInZpZXdib3giLCJiZ0NvbG9yIiwidmlld3BvcnQiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJoYW5kbGVBbGlnbkxlZnQiLCJtb2RlbGluZyIsImxlZnRNb3N0IiwicmVkdWNlIiwibW92ZUVsZW1lbnRzIiwiaGFuZGxlQWxpZ25DZW50ZXIiLCJjZW50ZXJYIiwic3VtIiwidGFyZ2V0WCIsImhhbmRsZUFsaWduUmlnaHQiLCJyaWdodE1vc3QiLCJyaWdodEVkZ2UiLCJoYW5kbGVBbGlnblRvcCIsInRvcE1vc3QiLCJoYW5kbGVBbGlnbk1pZGRsZSIsIm1pZGRsZVkiLCJoZWlnaHQiLCJ0YXJnZXRZIiwiaGFuZGxlQWxpZ25Cb3R0b20iLCJib3R0b21Nb3N0IiwiYm90dG9tRWRnZSIsImhhbmRsZVByZXZpZXciLCJoYW5kbGVYbWxTYXZlIiwibmV3WG1sIiwiaGFuZGxlUnVuUHJvY2VzcyIsImhhbmRsZU1lZXRpbmdNb2RlIiwicmVxdWVzdEZ1bGxzY3JlZW4iLCJmdWxsc2NyZWVuRWxlbWVudCIsImV4aXRGdWxsc2NyZWVuIiwiaGFuZGxlVG9nZ2xlTWluaW1hcCIsImhhbmRsZVRvZ2dsZUxhbmd1YWdlIiwiaGFuZGxlVG9nZ2xlR3JpZCIsInByZXYiLCJuZXdWYWx1ZSIsImhhbmRsZVBhbGV0dGVBY3Rpb24iLCJhY3Rpb24iLCJlbmRzV2l0aCIsInJlcGxhY2UiLCJoYW5kVG9vbCIsImxhc3NvVG9vbCIsInNwYWNlVG9vbCIsImdsb2JhbENvbm5lY3QiLCJhY3RpdmF0ZUhhbmQiLCJhY3RpdmF0ZVNlbGVjdGlvbiIsInN0YXJ0c1dpdGgiLCJlbGVtZW50RmFjdG9yeSIsImNyZWF0ZSIsImVsZW1lbnRUeXBlIiwiZXZlbnREZWZpbml0aW9uVHlwZSIsInR5cGVNYXAiLCJpc0V4cGFuZGVkIiwidHJpZ2dlcmVkQnlFdmVudCIsImVsZW1lbnRDb25maWciLCJzaGFwZUNvbmZpZyIsImJwbW5GYWN0b3J5IiwiZXZlbnREZWZpbml0aW9uIiwiYnVzaW5lc3NPYmplY3QiLCJldmVudERlZmluaXRpb25zIiwic2hhcGUiLCJjcmVhdGVTaGFwZSIsIkRyYWdFdmVudCIsInN0YXJ0Iiwicm9vdEVsZW1lbnQiLCJnZXRSb290RWxlbWVudCIsImNlbnRlclkiLCJkaXYiLCJjbGFzc05hbWUiLCJoMiIsInAiLCJidXR0b24iLCJvbkNsaWNrIiwibG9jYXRpb24iLCJyZWxvYWQiLCJvblNhdmUiLCJvbkV4cG9ydCIsIm9uSW1wb3J0Iiwib25VbmRvIiwib25SZWRvIiwib25ab29tSW4iLCJvblpvb21PdXQiLCJvbkZpdFRvVmlld3BvcnQiLCJvbkNsZWFyIiwib25Ub2dnbGVUaGVtZSIsIm9uQWxpZ25MZWZ0Iiwib25BbGlnbkNlbnRlciIsIm9uQWxpZ25SaWdodCIsIm9uQWxpZ25Ub3AiLCJvbkFsaWduTWlkZGxlIiwib25BbGlnbkJvdHRvbSIsIm9uUHJldmlldyIsIm9uUnVuIiwib25NZWV0aW5nTW9kZSIsIm9uVG9nZ2xlTWluaW1hcCIsIm9uVG9nZ2xlTGFuZ3VhZ2UiLCJvblRvZ2dsZUdyaWQiLCJkaXNhYmxlZCIsIm9uQWN0aW9uIiwicmVmIiwidG9wIiwibGVmdCIsInJpZ2h0IiwiYm90dG9tIiwiaW5wdXQiLCJhY2NlcHQiLCJvbkNoYW5nZSIsImlzT3BlbiIsIm9uQ2xvc2UiLCJyZWFkT25seSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./components/bpmn/BpmnStudioFixed.tsx\n"));

/***/ })

});