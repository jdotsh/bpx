"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/didi";
exports.ids = ["vendor-chunks/didi"];
exports.modules = {

/***/ "(ssr)/./node_modules/didi/dist/index.js":
/*!*****************************************!*\
  !*** ./node_modules/didi/dist/index.js ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Injector: () => (/* binding */ Injector),\n/* harmony export */   annotate: () => (/* binding */ annotate),\n/* harmony export */   parseAnnotations: () => (/* binding */ parseAnnotations)\n/* harmony export */ });\nconst CLASS_PATTERN = /^class[ {]/;\n\n\n/**\n * @param {function} fn\n *\n * @return {boolean}\n */\nfunction isClass(fn) {\n  return CLASS_PATTERN.test(fn.toString());\n}\n\n/**\n * @param {any} obj\n *\n * @return {boolean}\n */\nfunction isArray(obj) {\n  return Array.isArray(obj);\n}\n\n/**\n * @param {any} obj\n * @param {string} prop\n *\n * @return {boolean}\n */\nfunction hasOwnProp(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\n/**\n * @typedef {import('./index.js').InjectAnnotated } InjectAnnotated\n */\n\n/**\n * @template T\n *\n * @params {[...string[], T] | ...string[], T} args\n *\n * @return {T & InjectAnnotated}\n */\nfunction annotate(...args) {\n\n  if (args.length === 1 && isArray(args[0])) {\n    args = args[0];\n  }\n\n  args = [ ...args ];\n\n  const fn = args.pop();\n\n  fn.$inject = args;\n\n  return fn;\n}\n\n\n// Current limitations:\n// - can't put into \"function arg\" comments\n// function /* (no parenthesis like this) */ (){}\n// function abc( /* xx (no parenthesis like this) */ a, b) {}\n//\n// Just put the comment before function or inside:\n// /* (((this is fine))) */ function(a, b) {}\n// function abc(a) { /* (((this is fine))) */}\n//\n// - can't reliably auto-annotate constructor; we'll match the\n// first constructor(...) pattern found which may be the one\n// of a nested class, too.\n\nconst CONSTRUCTOR_ARGS = /constructor\\s*[^(]*\\(\\s*([^)]*)\\)/m;\nconst FN_ARGS = /^(?:async\\s+)?(?:function\\s*[^(]*)?(?:\\(\\s*([^)]*)\\)|(\\w+))/m;\nconst FN_ARG = /\\/\\*([^*]*)\\*\\//m;\n\n/**\n * @param {unknown} fn\n *\n * @return {string[]}\n */\nfunction parseAnnotations(fn) {\n\n  if (typeof fn !== 'function') {\n    throw new Error(`Cannot annotate \"${fn}\". Expected a function!`);\n  }\n\n  const match = fn.toString().match(isClass(fn) ? CONSTRUCTOR_ARGS : FN_ARGS);\n\n  // may parse class without constructor\n  if (!match) {\n    return [];\n  }\n\n  const args = match[1] || match[2];\n\n  return args && args.split(',').map(arg => {\n    const argMatch = arg.match(FN_ARG);\n    return (argMatch && argMatch[1] || arg).trim();\n  }) || [];\n}\n\n/**\n * @typedef { import('./index.js').ModuleDeclaration } ModuleDeclaration\n * @typedef { import('./index.js').ModuleDefinition } ModuleDefinition\n * @typedef { import('./index.js').InjectorContext } InjectorContext\n *\n * @typedef { import('./index.js').TypedDeclaration<any, any> } TypedDeclaration\n */\n\n/**\n * Create a new injector with the given modules.\n *\n * @param {ModuleDefinition[]} modules\n * @param {InjectorContext} [_parent]\n */\nfunction Injector(modules, _parent) {\n\n  const parent = _parent || /** @type InjectorContext */ ({\n    get: function(name, strict) {\n      currentlyResolving.push(name);\n\n      if (strict === false) {\n        return null;\n      } else {\n        throw error(`No provider for \"${ name }\"!`);\n      }\n    }\n  });\n\n  const currentlyResolving = [];\n  const providers = this._providers = Object.create(parent._providers || null);\n  const instances = this._instances = Object.create(null);\n\n  const self = instances.injector = this;\n\n  const error = function(msg) {\n    const stack = currentlyResolving.join(' -> ');\n    currentlyResolving.length = 0;\n    return new Error(stack ? `${ msg } (Resolving: ${ stack })` : msg);\n  };\n\n  /**\n   * Return a named service.\n   *\n   * @param {string} name\n   * @param {boolean} [strict=true] if false, resolve missing services to null\n   *\n   * @return {any}\n   */\n  function get(name, strict) {\n    if (!providers[name] && name.includes('.')) {\n\n      const parts = name.split('.');\n      let pivot = get(/** @type { string } */ (parts.shift()));\n\n      while (parts.length) {\n        pivot = pivot[/** @type { string } */ (parts.shift())];\n      }\n\n      return pivot;\n    }\n\n    if (hasOwnProp(instances, name)) {\n      return instances[name];\n    }\n\n    if (hasOwnProp(providers, name)) {\n      if (currentlyResolving.indexOf(name) !== -1) {\n        currentlyResolving.push(name);\n        throw error('Cannot resolve circular dependency!');\n      }\n\n      currentlyResolving.push(name);\n      instances[name] = providers[name][0](providers[name][1]);\n      currentlyResolving.pop();\n\n      return instances[name];\n    }\n\n    return parent.get(name, strict);\n  }\n\n  function fnDef(fn, locals) {\n\n    if (typeof locals === 'undefined') {\n      locals = {};\n    }\n\n    if (typeof fn !== 'function') {\n      if (isArray(fn)) {\n        fn = annotate(fn.slice());\n      } else {\n        throw error(`Cannot invoke \"${ fn }\". Expected a function!`);\n      }\n    }\n\n    /**\n     * @type {string[]}\n     */\n    const inject = fn.$inject || parseAnnotations(fn);\n    const dependencies = inject.map(dep => {\n      if (hasOwnProp(locals, dep)) {\n        return locals[dep];\n      } else {\n        return get(dep);\n      }\n    });\n\n    return {\n      fn: fn,\n      dependencies\n    };\n  }\n\n  /**\n   * Instantiate the given type, injecting dependencies.\n   *\n   * @template T\n   *\n   * @param { Function | [...string[], Function ]} type\n   *\n   * @return T\n   */\n  function instantiate(type) {\n    const {\n      fn,\n      dependencies\n    } = fnDef(type);\n\n    // instantiate var args constructor\n    const Constructor = Function.prototype.bind.call(fn, null, ...dependencies);\n\n    return new Constructor();\n  }\n\n  /**\n   * Invoke the given function, injecting dependencies. Return the result.\n   *\n   * @template T\n   *\n   * @param { Function | [...string[], Function ]} func\n   * @param { Object } [context]\n   * @param { Object } [locals]\n   *\n   * @return {T} invocation result\n   */\n  function invoke(func, context, locals) {\n    const {\n      fn,\n      dependencies\n    } = fnDef(func, locals);\n\n    return fn.apply(context, dependencies);\n  }\n\n  /**\n   * @param {Injector} childInjector\n   *\n   * @return {Function}\n   */\n  function createPrivateInjectorFactory(childInjector) {\n    return annotate(key => childInjector.get(key));\n  }\n\n  /**\n   * @param {ModuleDefinition[]} modules\n   * @param {string[]} [forceNewInstances]\n   *\n   * @return {Injector}\n   */\n  function createChild(modules, forceNewInstances) {\n    if (forceNewInstances && forceNewInstances.length) {\n      const fromParentModule = Object.create(null);\n      const matchedScopes = Object.create(null);\n\n      const privateInjectorsCache = [];\n      const privateChildInjectors = [];\n      const privateChildFactories = [];\n\n      let provider;\n      let cacheIdx;\n      let privateChildInjector;\n      let privateChildInjectorFactory;\n\n      for (let name in providers) {\n        provider = providers[name];\n\n        if (forceNewInstances.indexOf(name) !== -1) {\n          if (provider[2] === 'private') {\n            cacheIdx = privateInjectorsCache.indexOf(provider[3]);\n            if (cacheIdx === -1) {\n              privateChildInjector = provider[3].createChild([], forceNewInstances);\n              privateChildInjectorFactory = createPrivateInjectorFactory(privateChildInjector);\n              privateInjectorsCache.push(provider[3]);\n              privateChildInjectors.push(privateChildInjector);\n              privateChildFactories.push(privateChildInjectorFactory);\n              fromParentModule[name] = [ privateChildInjectorFactory, name, 'private', privateChildInjector ];\n            } else {\n              fromParentModule[name] = [ privateChildFactories[cacheIdx], name, 'private', privateChildInjectors[cacheIdx] ];\n            }\n          } else {\n            fromParentModule[name] = [ provider[2], provider[1] ];\n          }\n          matchedScopes[name] = true;\n        }\n\n        if ((provider[2] === 'factory' || provider[2] === 'type') && provider[1].$scope) {\n          /* jshint -W083 */\n          forceNewInstances.forEach(scope => {\n            if (provider[1].$scope.indexOf(scope) !== -1) {\n              fromParentModule[name] = [ provider[2], provider[1] ];\n              matchedScopes[scope] = true;\n            }\n          });\n        }\n      }\n\n      forceNewInstances.forEach(scope => {\n        if (!matchedScopes[scope]) {\n          throw new Error('No provider for \"' + scope + '\". Cannot use provider from the parent!');\n        }\n      });\n\n      modules.unshift(fromParentModule);\n    }\n\n    return new Injector(modules, self);\n  }\n\n  const factoryMap = {\n    factory: invoke,\n    type: instantiate,\n    value: function(value) {\n      return value;\n    }\n  };\n\n  /**\n   * @param {ModuleDefinition} moduleDefinition\n   * @param {Injector} injector\n   */\n  function createInitializer(moduleDefinition, injector) {\n\n    const initializers = moduleDefinition.__init__ || [];\n\n    return function() {\n      initializers.forEach(initializer => {\n\n        // eagerly resolve component (fn or string)\n        if (typeof initializer === 'string') {\n          injector.get(initializer);\n        } else {\n          injector.invoke(initializer);\n        }\n      });\n    };\n  }\n\n  /**\n   * @param {ModuleDefinition} moduleDefinition\n   */\n  function loadModule(moduleDefinition) {\n\n    const moduleExports = moduleDefinition.__exports__;\n\n    // private module\n    if (moduleExports) {\n      const nestedModules = moduleDefinition.__modules__;\n\n      const clonedModule = Object.keys(moduleDefinition).reduce((clonedModule, key) => {\n\n        if (key !== '__exports__' && key !== '__modules__' && key !== '__init__' && key !== '__depends__') {\n          clonedModule[key] = moduleDefinition[key];\n        }\n\n        return clonedModule;\n      }, Object.create(null));\n\n      const childModules = (nestedModules || []).concat(clonedModule);\n\n      const privateInjector = createChild(childModules);\n      const getFromPrivateInjector = annotate(function(key) {\n        return privateInjector.get(key);\n      });\n\n      moduleExports.forEach(function(key) {\n        providers[key] = [ getFromPrivateInjector, key, 'private', privateInjector ];\n      });\n\n      // ensure child injector initializes\n      const initializers = (moduleDefinition.__init__ || []).slice();\n\n      initializers.unshift(function() {\n        privateInjector.init();\n      });\n\n      moduleDefinition = Object.assign({}, moduleDefinition, {\n        __init__: initializers\n      });\n\n      return createInitializer(moduleDefinition, privateInjector);\n    }\n\n    // normal module\n    Object.keys(moduleDefinition).forEach(function(key) {\n\n      if (key === '__init__' || key === '__depends__') {\n        return;\n      }\n\n      const typeDeclaration = /** @type { TypedDeclaration } */ (\n        moduleDefinition[key]\n      );\n\n      if (typeDeclaration[2] === 'private') {\n        providers[key] = typeDeclaration;\n        return;\n      }\n\n      const type = typeDeclaration[0];\n      const value = typeDeclaration[1];\n\n      providers[key] = [ factoryMap[type], arrayUnwrap(type, value), type ];\n    });\n\n    return createInitializer(moduleDefinition, self);\n  }\n\n  /**\n   * @param {ModuleDefinition[]} moduleDefinitions\n   * @param {ModuleDefinition} moduleDefinition\n   *\n   * @return {ModuleDefinition[]}\n   */\n  function resolveDependencies(moduleDefinitions, moduleDefinition) {\n\n    if (moduleDefinitions.indexOf(moduleDefinition) !== -1) {\n      return moduleDefinitions;\n    }\n\n    moduleDefinitions = (moduleDefinition.__depends__ || []).reduce(resolveDependencies, moduleDefinitions);\n\n    if (moduleDefinitions.indexOf(moduleDefinition) !== -1) {\n      return moduleDefinitions;\n    }\n\n    return moduleDefinitions.concat(moduleDefinition);\n  }\n\n  /**\n   * @param {ModuleDefinition[]} moduleDefinitions\n   *\n   * @return { () => void } initializerFn\n   */\n  function bootstrap(moduleDefinitions) {\n\n    const initializers = moduleDefinitions\n      .reduce(resolveDependencies, [])\n      .map(loadModule);\n\n    let initialized = false;\n\n    return function() {\n\n      if (initialized) {\n        return;\n      }\n\n      initialized = true;\n\n      initializers.forEach(initializer => initializer());\n    };\n  }\n\n  // public API\n  this.get = get;\n  this.invoke = invoke;\n  this.instantiate = instantiate;\n  this.createChild = createChild;\n\n  // setup\n  this.init = bootstrap(modules);\n}\n\n\n// helpers ///////////////\n\nfunction arrayUnwrap(type, value) {\n  if (type !== 'value' && isArray(value)) {\n    value = annotate(value.slice());\n  }\n\n  return value;\n}\n\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZGlkaS9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLGdDQUFnQzs7O0FBR2hDO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsUUFBUTtBQUNuQjtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsdUNBQXVDO0FBQ3BEOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksbUNBQW1DO0FBQy9DO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQSx3Q0FBd0MsR0FBRztBQUMzQzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQSxjQUFjLHlDQUF5QztBQUN2RCxjQUFjLHdDQUF3QztBQUN0RCxjQUFjLHVDQUF1QztBQUNyRDtBQUNBLGNBQWMsa0RBQWtEO0FBQ2hFOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsb0JBQW9CO0FBQy9CLFdBQVcsaUJBQWlCO0FBQzVCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IseUNBQXlDLE1BQU07QUFDL0M7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBOztBQUVB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QUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFZ0Q7QUFDaEQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9icG1uLXN0dWRpby13ZWIvLi9ub2RlX21vZHVsZXMvZGlkaS9kaXN0L2luZGV4LmpzP2NkZTUiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgQ0xBU1NfUEFUVEVSTiA9IC9eY2xhc3NbIHtdLztcblxuXG4vKipcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGZuXG4gKlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNDbGFzcyhmbikge1xuICByZXR1cm4gQ0xBU1NfUEFUVEVSTi50ZXN0KGZuLnRvU3RyaW5nKCkpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7YW55fSBvYmpcbiAqXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc0FycmF5KG9iaikge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShvYmopO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7YW55fSBvYmpcbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wXG4gKlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaGFzT3duUHJvcChvYmosIHByb3ApIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApO1xufVxuXG4vKipcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJy4vaW5kZXguanMnKS5JbmplY3RBbm5vdGF0ZWQgfSBJbmplY3RBbm5vdGF0ZWRcbiAqL1xuXG4vKipcbiAqIEB0ZW1wbGF0ZSBUXG4gKlxuICogQHBhcmFtcyB7Wy4uLnN0cmluZ1tdLCBUXSB8IC4uLnN0cmluZ1tdLCBUfSBhcmdzXG4gKlxuICogQHJldHVybiB7VCAmIEluamVjdEFubm90YXRlZH1cbiAqL1xuZnVuY3Rpb24gYW5ub3RhdGUoLi4uYXJncykge1xuXG4gIGlmIChhcmdzLmxlbmd0aCA9PT0gMSAmJiBpc0FycmF5KGFyZ3NbMF0pKSB7XG4gICAgYXJncyA9IGFyZ3NbMF07XG4gIH1cblxuICBhcmdzID0gWyAuLi5hcmdzIF07XG5cbiAgY29uc3QgZm4gPSBhcmdzLnBvcCgpO1xuXG4gIGZuLiRpbmplY3QgPSBhcmdzO1xuXG4gIHJldHVybiBmbjtcbn1cblxuXG4vLyBDdXJyZW50IGxpbWl0YXRpb25zOlxuLy8gLSBjYW4ndCBwdXQgaW50byBcImZ1bmN0aW9uIGFyZ1wiIGNvbW1lbnRzXG4vLyBmdW5jdGlvbiAvKiAobm8gcGFyZW50aGVzaXMgbGlrZSB0aGlzKSAqLyAoKXt9XG4vLyBmdW5jdGlvbiBhYmMoIC8qIHh4IChubyBwYXJlbnRoZXNpcyBsaWtlIHRoaXMpICovIGEsIGIpIHt9XG4vL1xuLy8gSnVzdCBwdXQgdGhlIGNvbW1lbnQgYmVmb3JlIGZ1bmN0aW9uIG9yIGluc2lkZTpcbi8vIC8qICgoKHRoaXMgaXMgZmluZSkpKSAqLyBmdW5jdGlvbihhLCBiKSB7fVxuLy8gZnVuY3Rpb24gYWJjKGEpIHsgLyogKCgodGhpcyBpcyBmaW5lKSkpICovfVxuLy9cbi8vIC0gY2FuJ3QgcmVsaWFibHkgYXV0by1hbm5vdGF0ZSBjb25zdHJ1Y3Rvcjsgd2UnbGwgbWF0Y2ggdGhlXG4vLyBmaXJzdCBjb25zdHJ1Y3RvciguLi4pIHBhdHRlcm4gZm91bmQgd2hpY2ggbWF5IGJlIHRoZSBvbmVcbi8vIG9mIGEgbmVzdGVkIGNsYXNzLCB0b28uXG5cbmNvbnN0IENPTlNUUlVDVE9SX0FSR1MgPSAvY29uc3RydWN0b3JcXHMqW14oXSpcXChcXHMqKFteKV0qKVxcKS9tO1xuY29uc3QgRk5fQVJHUyA9IC9eKD86YXN5bmNcXHMrKT8oPzpmdW5jdGlvblxccypbXihdKik/KD86XFwoXFxzKihbXildKilcXCl8KFxcdyspKS9tO1xuY29uc3QgRk5fQVJHID0gL1xcL1xcKihbXipdKilcXCpcXC8vbTtcblxuLyoqXG4gKiBAcGFyYW0ge3Vua25vd259IGZuXG4gKlxuICogQHJldHVybiB7c3RyaW5nW119XG4gKi9cbmZ1bmN0aW9uIHBhcnNlQW5ub3RhdGlvbnMoZm4pIHtcblxuICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgYW5ub3RhdGUgXCIke2ZufVwiLiBFeHBlY3RlZCBhIGZ1bmN0aW9uIWApO1xuICB9XG5cbiAgY29uc3QgbWF0Y2ggPSBmbi50b1N0cmluZygpLm1hdGNoKGlzQ2xhc3MoZm4pID8gQ09OU1RSVUNUT1JfQVJHUyA6IEZOX0FSR1MpO1xuXG4gIC8vIG1heSBwYXJzZSBjbGFzcyB3aXRob3V0IGNvbnN0cnVjdG9yXG4gIGlmICghbWF0Y2gpIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICBjb25zdCBhcmdzID0gbWF0Y2hbMV0gfHwgbWF0Y2hbMl07XG5cbiAgcmV0dXJuIGFyZ3MgJiYgYXJncy5zcGxpdCgnLCcpLm1hcChhcmcgPT4ge1xuICAgIGNvbnN0IGFyZ01hdGNoID0gYXJnLm1hdGNoKEZOX0FSRyk7XG4gICAgcmV0dXJuIChhcmdNYXRjaCAmJiBhcmdNYXRjaFsxXSB8fCBhcmcpLnRyaW0oKTtcbiAgfSkgfHwgW107XG59XG5cbi8qKlxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4vaW5kZXguanMnKS5Nb2R1bGVEZWNsYXJhdGlvbiB9IE1vZHVsZURlY2xhcmF0aW9uXG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi9pbmRleC5qcycpLk1vZHVsZURlZmluaXRpb24gfSBNb2R1bGVEZWZpbml0aW9uXG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi9pbmRleC5qcycpLkluamVjdG9yQ29udGV4dCB9IEluamVjdG9yQ29udGV4dFxuICpcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuL2luZGV4LmpzJykuVHlwZWREZWNsYXJhdGlvbjxhbnksIGFueT4gfSBUeXBlZERlY2xhcmF0aW9uXG4gKi9cblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgaW5qZWN0b3Igd2l0aCB0aGUgZ2l2ZW4gbW9kdWxlcy5cbiAqXG4gKiBAcGFyYW0ge01vZHVsZURlZmluaXRpb25bXX0gbW9kdWxlc1xuICogQHBhcmFtIHtJbmplY3RvckNvbnRleHR9IFtfcGFyZW50XVxuICovXG5mdW5jdGlvbiBJbmplY3Rvcihtb2R1bGVzLCBfcGFyZW50KSB7XG5cbiAgY29uc3QgcGFyZW50ID0gX3BhcmVudCB8fCAvKiogQHR5cGUgSW5qZWN0b3JDb250ZXh0ICovICh7XG4gICAgZ2V0OiBmdW5jdGlvbihuYW1lLCBzdHJpY3QpIHtcbiAgICAgIGN1cnJlbnRseVJlc29sdmluZy5wdXNoKG5hbWUpO1xuXG4gICAgICBpZiAoc3RyaWN0ID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IGVycm9yKGBObyBwcm92aWRlciBmb3IgXCIkeyBuYW1lIH1cIiFgKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIGNvbnN0IGN1cnJlbnRseVJlc29sdmluZyA9IFtdO1xuICBjb25zdCBwcm92aWRlcnMgPSB0aGlzLl9wcm92aWRlcnMgPSBPYmplY3QuY3JlYXRlKHBhcmVudC5fcHJvdmlkZXJzIHx8IG51bGwpO1xuICBjb25zdCBpbnN0YW5jZXMgPSB0aGlzLl9pbnN0YW5jZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gIGNvbnN0IHNlbGYgPSBpbnN0YW5jZXMuaW5qZWN0b3IgPSB0aGlzO1xuXG4gIGNvbnN0IGVycm9yID0gZnVuY3Rpb24obXNnKSB7XG4gICAgY29uc3Qgc3RhY2sgPSBjdXJyZW50bHlSZXNvbHZpbmcuam9pbignIC0+ICcpO1xuICAgIGN1cnJlbnRseVJlc29sdmluZy5sZW5ndGggPSAwO1xuICAgIHJldHVybiBuZXcgRXJyb3Ioc3RhY2sgPyBgJHsgbXNnIH0gKFJlc29sdmluZzogJHsgc3RhY2sgfSlgIDogbXNnKTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJuIGEgbmFtZWQgc2VydmljZS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICogQHBhcmFtIHtib29sZWFufSBbc3RyaWN0PXRydWVdIGlmIGZhbHNlLCByZXNvbHZlIG1pc3Npbmcgc2VydmljZXMgdG8gbnVsbFxuICAgKlxuICAgKiBAcmV0dXJuIHthbnl9XG4gICAqL1xuICBmdW5jdGlvbiBnZXQobmFtZSwgc3RyaWN0KSB7XG4gICAgaWYgKCFwcm92aWRlcnNbbmFtZV0gJiYgbmFtZS5pbmNsdWRlcygnLicpKSB7XG5cbiAgICAgIGNvbnN0IHBhcnRzID0gbmFtZS5zcGxpdCgnLicpO1xuICAgICAgbGV0IHBpdm90ID0gZ2V0KC8qKiBAdHlwZSB7IHN0cmluZyB9ICovIChwYXJ0cy5zaGlmdCgpKSk7XG5cbiAgICAgIHdoaWxlIChwYXJ0cy5sZW5ndGgpIHtcbiAgICAgICAgcGl2b3QgPSBwaXZvdFsvKiogQHR5cGUgeyBzdHJpbmcgfSAqLyAocGFydHMuc2hpZnQoKSldO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcGl2b3Q7XG4gICAgfVxuXG4gICAgaWYgKGhhc093blByb3AoaW5zdGFuY2VzLCBuYW1lKSkge1xuICAgICAgcmV0dXJuIGluc3RhbmNlc1tuYW1lXTtcbiAgICB9XG5cbiAgICBpZiAoaGFzT3duUHJvcChwcm92aWRlcnMsIG5hbWUpKSB7XG4gICAgICBpZiAoY3VycmVudGx5UmVzb2x2aW5nLmluZGV4T2YobmFtZSkgIT09IC0xKSB7XG4gICAgICAgIGN1cnJlbnRseVJlc29sdmluZy5wdXNoKG5hbWUpO1xuICAgICAgICB0aHJvdyBlcnJvcignQ2Fubm90IHJlc29sdmUgY2lyY3VsYXIgZGVwZW5kZW5jeSEnKTtcbiAgICAgIH1cblxuICAgICAgY3VycmVudGx5UmVzb2x2aW5nLnB1c2gobmFtZSk7XG4gICAgICBpbnN0YW5jZXNbbmFtZV0gPSBwcm92aWRlcnNbbmFtZV1bMF0ocHJvdmlkZXJzW25hbWVdWzFdKTtcbiAgICAgIGN1cnJlbnRseVJlc29sdmluZy5wb3AoKTtcblxuICAgICAgcmV0dXJuIGluc3RhbmNlc1tuYW1lXTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGFyZW50LmdldChuYW1lLCBzdHJpY3QpO1xuICB9XG5cbiAgZnVuY3Rpb24gZm5EZWYoZm4sIGxvY2Fscykge1xuXG4gICAgaWYgKHR5cGVvZiBsb2NhbHMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBsb2NhbHMgPSB7fTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpZiAoaXNBcnJheShmbikpIHtcbiAgICAgICAgZm4gPSBhbm5vdGF0ZShmbi5zbGljZSgpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IGVycm9yKGBDYW5ub3QgaW52b2tlIFwiJHsgZm4gfVwiLiBFeHBlY3RlZCBhIGZ1bmN0aW9uIWApO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtzdHJpbmdbXX1cbiAgICAgKi9cbiAgICBjb25zdCBpbmplY3QgPSBmbi4kaW5qZWN0IHx8IHBhcnNlQW5ub3RhdGlvbnMoZm4pO1xuICAgIGNvbnN0IGRlcGVuZGVuY2llcyA9IGluamVjdC5tYXAoZGVwID0+IHtcbiAgICAgIGlmIChoYXNPd25Qcm9wKGxvY2FscywgZGVwKSkge1xuICAgICAgICByZXR1cm4gbG9jYWxzW2RlcF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZ2V0KGRlcCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgZm46IGZuLFxuICAgICAgZGVwZW5kZW5jaWVzXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnN0YW50aWF0ZSB0aGUgZ2l2ZW4gdHlwZSwgaW5qZWN0aW5nIGRlcGVuZGVuY2llcy5cbiAgICpcbiAgICogQHRlbXBsYXRlIFRcbiAgICpcbiAgICogQHBhcmFtIHsgRnVuY3Rpb24gfCBbLi4uc3RyaW5nW10sIEZ1bmN0aW9uIF19IHR5cGVcbiAgICpcbiAgICogQHJldHVybiBUXG4gICAqL1xuICBmdW5jdGlvbiBpbnN0YW50aWF0ZSh0eXBlKSB7XG4gICAgY29uc3Qge1xuICAgICAgZm4sXG4gICAgICBkZXBlbmRlbmNpZXNcbiAgICB9ID0gZm5EZWYodHlwZSk7XG5cbiAgICAvLyBpbnN0YW50aWF0ZSB2YXIgYXJncyBjb25zdHJ1Y3RvclxuICAgIGNvbnN0IENvbnN0cnVjdG9yID0gRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQuY2FsbChmbiwgbnVsbCwgLi4uZGVwZW5kZW5jaWVzKTtcblxuICAgIHJldHVybiBuZXcgQ29uc3RydWN0b3IoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnZva2UgdGhlIGdpdmVuIGZ1bmN0aW9uLCBpbmplY3RpbmcgZGVwZW5kZW5jaWVzLiBSZXR1cm4gdGhlIHJlc3VsdC5cbiAgICpcbiAgICogQHRlbXBsYXRlIFRcbiAgICpcbiAgICogQHBhcmFtIHsgRnVuY3Rpb24gfCBbLi4uc3RyaW5nW10sIEZ1bmN0aW9uIF19IGZ1bmNcbiAgICogQHBhcmFtIHsgT2JqZWN0IH0gW2NvbnRleHRdXG4gICAqIEBwYXJhbSB7IE9iamVjdCB9IFtsb2NhbHNdXG4gICAqXG4gICAqIEByZXR1cm4ge1R9IGludm9jYXRpb24gcmVzdWx0XG4gICAqL1xuICBmdW5jdGlvbiBpbnZva2UoZnVuYywgY29udGV4dCwgbG9jYWxzKSB7XG4gICAgY29uc3Qge1xuICAgICAgZm4sXG4gICAgICBkZXBlbmRlbmNpZXNcbiAgICB9ID0gZm5EZWYoZnVuYywgbG9jYWxzKTtcblxuICAgIHJldHVybiBmbi5hcHBseShjb250ZXh0LCBkZXBlbmRlbmNpZXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7SW5qZWN0b3J9IGNoaWxkSW5qZWN0b3JcbiAgICpcbiAgICogQHJldHVybiB7RnVuY3Rpb259XG4gICAqL1xuICBmdW5jdGlvbiBjcmVhdGVQcml2YXRlSW5qZWN0b3JGYWN0b3J5KGNoaWxkSW5qZWN0b3IpIHtcbiAgICByZXR1cm4gYW5ub3RhdGUoa2V5ID0+IGNoaWxkSW5qZWN0b3IuZ2V0KGtleSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7TW9kdWxlRGVmaW5pdGlvbltdfSBtb2R1bGVzXG4gICAqIEBwYXJhbSB7c3RyaW5nW119IFtmb3JjZU5ld0luc3RhbmNlc11cbiAgICpcbiAgICogQHJldHVybiB7SW5qZWN0b3J9XG4gICAqL1xuICBmdW5jdGlvbiBjcmVhdGVDaGlsZChtb2R1bGVzLCBmb3JjZU5ld0luc3RhbmNlcykge1xuICAgIGlmIChmb3JjZU5ld0luc3RhbmNlcyAmJiBmb3JjZU5ld0luc3RhbmNlcy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IGZyb21QYXJlbnRNb2R1bGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgY29uc3QgbWF0Y2hlZFNjb3BlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgICAgIGNvbnN0IHByaXZhdGVJbmplY3RvcnNDYWNoZSA9IFtdO1xuICAgICAgY29uc3QgcHJpdmF0ZUNoaWxkSW5qZWN0b3JzID0gW107XG4gICAgICBjb25zdCBwcml2YXRlQ2hpbGRGYWN0b3JpZXMgPSBbXTtcblxuICAgICAgbGV0IHByb3ZpZGVyO1xuICAgICAgbGV0IGNhY2hlSWR4O1xuICAgICAgbGV0IHByaXZhdGVDaGlsZEluamVjdG9yO1xuICAgICAgbGV0IHByaXZhdGVDaGlsZEluamVjdG9yRmFjdG9yeTtcblxuICAgICAgZm9yIChsZXQgbmFtZSBpbiBwcm92aWRlcnMpIHtcbiAgICAgICAgcHJvdmlkZXIgPSBwcm92aWRlcnNbbmFtZV07XG5cbiAgICAgICAgaWYgKGZvcmNlTmV3SW5zdGFuY2VzLmluZGV4T2YobmFtZSkgIT09IC0xKSB7XG4gICAgICAgICAgaWYgKHByb3ZpZGVyWzJdID09PSAncHJpdmF0ZScpIHtcbiAgICAgICAgICAgIGNhY2hlSWR4ID0gcHJpdmF0ZUluamVjdG9yc0NhY2hlLmluZGV4T2YocHJvdmlkZXJbM10pO1xuICAgICAgICAgICAgaWYgKGNhY2hlSWR4ID09PSAtMSkge1xuICAgICAgICAgICAgICBwcml2YXRlQ2hpbGRJbmplY3RvciA9IHByb3ZpZGVyWzNdLmNyZWF0ZUNoaWxkKFtdLCBmb3JjZU5ld0luc3RhbmNlcyk7XG4gICAgICAgICAgICAgIHByaXZhdGVDaGlsZEluamVjdG9yRmFjdG9yeSA9IGNyZWF0ZVByaXZhdGVJbmplY3RvckZhY3RvcnkocHJpdmF0ZUNoaWxkSW5qZWN0b3IpO1xuICAgICAgICAgICAgICBwcml2YXRlSW5qZWN0b3JzQ2FjaGUucHVzaChwcm92aWRlclszXSk7XG4gICAgICAgICAgICAgIHByaXZhdGVDaGlsZEluamVjdG9ycy5wdXNoKHByaXZhdGVDaGlsZEluamVjdG9yKTtcbiAgICAgICAgICAgICAgcHJpdmF0ZUNoaWxkRmFjdG9yaWVzLnB1c2gocHJpdmF0ZUNoaWxkSW5qZWN0b3JGYWN0b3J5KTtcbiAgICAgICAgICAgICAgZnJvbVBhcmVudE1vZHVsZVtuYW1lXSA9IFsgcHJpdmF0ZUNoaWxkSW5qZWN0b3JGYWN0b3J5LCBuYW1lLCAncHJpdmF0ZScsIHByaXZhdGVDaGlsZEluamVjdG9yIF07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBmcm9tUGFyZW50TW9kdWxlW25hbWVdID0gWyBwcml2YXRlQ2hpbGRGYWN0b3JpZXNbY2FjaGVJZHhdLCBuYW1lLCAncHJpdmF0ZScsIHByaXZhdGVDaGlsZEluamVjdG9yc1tjYWNoZUlkeF0gXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZnJvbVBhcmVudE1vZHVsZVtuYW1lXSA9IFsgcHJvdmlkZXJbMl0sIHByb3ZpZGVyWzFdIF07XG4gICAgICAgICAgfVxuICAgICAgICAgIG1hdGNoZWRTY29wZXNbbmFtZV0gPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKChwcm92aWRlclsyXSA9PT0gJ2ZhY3RvcnknIHx8IHByb3ZpZGVyWzJdID09PSAndHlwZScpICYmIHByb3ZpZGVyWzFdLiRzY29wZSkge1xuICAgICAgICAgIC8qIGpzaGludCAtVzA4MyAqL1xuICAgICAgICAgIGZvcmNlTmV3SW5zdGFuY2VzLmZvckVhY2goc2NvcGUgPT4ge1xuICAgICAgICAgICAgaWYgKHByb3ZpZGVyWzFdLiRzY29wZS5pbmRleE9mKHNjb3BlKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgZnJvbVBhcmVudE1vZHVsZVtuYW1lXSA9IFsgcHJvdmlkZXJbMl0sIHByb3ZpZGVyWzFdIF07XG4gICAgICAgICAgICAgIG1hdGNoZWRTY29wZXNbc2NvcGVdID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmb3JjZU5ld0luc3RhbmNlcy5mb3JFYWNoKHNjb3BlID0+IHtcbiAgICAgICAgaWYgKCFtYXRjaGVkU2NvcGVzW3Njb3BlXSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gcHJvdmlkZXIgZm9yIFwiJyArIHNjb3BlICsgJ1wiLiBDYW5ub3QgdXNlIHByb3ZpZGVyIGZyb20gdGhlIHBhcmVudCEnKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIG1vZHVsZXMudW5zaGlmdChmcm9tUGFyZW50TW9kdWxlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IEluamVjdG9yKG1vZHVsZXMsIHNlbGYpO1xuICB9XG5cbiAgY29uc3QgZmFjdG9yeU1hcCA9IHtcbiAgICBmYWN0b3J5OiBpbnZva2UsXG4gICAgdHlwZTogaW5zdGFudGlhdGUsXG4gICAgdmFsdWU6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge01vZHVsZURlZmluaXRpb259IG1vZHVsZURlZmluaXRpb25cbiAgICogQHBhcmFtIHtJbmplY3Rvcn0gaW5qZWN0b3JcbiAgICovXG4gIGZ1bmN0aW9uIGNyZWF0ZUluaXRpYWxpemVyKG1vZHVsZURlZmluaXRpb24sIGluamVjdG9yKSB7XG5cbiAgICBjb25zdCBpbml0aWFsaXplcnMgPSBtb2R1bGVEZWZpbml0aW9uLl9faW5pdF9fIHx8IFtdO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgaW5pdGlhbGl6ZXJzLmZvckVhY2goaW5pdGlhbGl6ZXIgPT4ge1xuXG4gICAgICAgIC8vIGVhZ2VybHkgcmVzb2x2ZSBjb21wb25lbnQgKGZuIG9yIHN0cmluZylcbiAgICAgICAgaWYgKHR5cGVvZiBpbml0aWFsaXplciA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICBpbmplY3Rvci5nZXQoaW5pdGlhbGl6ZXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGluamVjdG9yLmludm9rZShpbml0aWFsaXplcik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtNb2R1bGVEZWZpbml0aW9ufSBtb2R1bGVEZWZpbml0aW9uXG4gICAqL1xuICBmdW5jdGlvbiBsb2FkTW9kdWxlKG1vZHVsZURlZmluaXRpb24pIHtcblxuICAgIGNvbnN0IG1vZHVsZUV4cG9ydHMgPSBtb2R1bGVEZWZpbml0aW9uLl9fZXhwb3J0c19fO1xuXG4gICAgLy8gcHJpdmF0ZSBtb2R1bGVcbiAgICBpZiAobW9kdWxlRXhwb3J0cykge1xuICAgICAgY29uc3QgbmVzdGVkTW9kdWxlcyA9IG1vZHVsZURlZmluaXRpb24uX19tb2R1bGVzX187XG5cbiAgICAgIGNvbnN0IGNsb25lZE1vZHVsZSA9IE9iamVjdC5rZXlzKG1vZHVsZURlZmluaXRpb24pLnJlZHVjZSgoY2xvbmVkTW9kdWxlLCBrZXkpID0+IHtcblxuICAgICAgICBpZiAoa2V5ICE9PSAnX19leHBvcnRzX18nICYmIGtleSAhPT0gJ19fbW9kdWxlc19fJyAmJiBrZXkgIT09ICdfX2luaXRfXycgJiYga2V5ICE9PSAnX19kZXBlbmRzX18nKSB7XG4gICAgICAgICAgY2xvbmVkTW9kdWxlW2tleV0gPSBtb2R1bGVEZWZpbml0aW9uW2tleV07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY2xvbmVkTW9kdWxlO1xuICAgICAgfSwgT2JqZWN0LmNyZWF0ZShudWxsKSk7XG5cbiAgICAgIGNvbnN0IGNoaWxkTW9kdWxlcyA9IChuZXN0ZWRNb2R1bGVzIHx8IFtdKS5jb25jYXQoY2xvbmVkTW9kdWxlKTtcblxuICAgICAgY29uc3QgcHJpdmF0ZUluamVjdG9yID0gY3JlYXRlQ2hpbGQoY2hpbGRNb2R1bGVzKTtcbiAgICAgIGNvbnN0IGdldEZyb21Qcml2YXRlSW5qZWN0b3IgPSBhbm5vdGF0ZShmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgcmV0dXJuIHByaXZhdGVJbmplY3Rvci5nZXQoa2V5KTtcbiAgICAgIH0pO1xuXG4gICAgICBtb2R1bGVFeHBvcnRzLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIHByb3ZpZGVyc1trZXldID0gWyBnZXRGcm9tUHJpdmF0ZUluamVjdG9yLCBrZXksICdwcml2YXRlJywgcHJpdmF0ZUluamVjdG9yIF07XG4gICAgICB9KTtcblxuICAgICAgLy8gZW5zdXJlIGNoaWxkIGluamVjdG9yIGluaXRpYWxpemVzXG4gICAgICBjb25zdCBpbml0aWFsaXplcnMgPSAobW9kdWxlRGVmaW5pdGlvbi5fX2luaXRfXyB8fCBbXSkuc2xpY2UoKTtcblxuICAgICAgaW5pdGlhbGl6ZXJzLnVuc2hpZnQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHByaXZhdGVJbmplY3Rvci5pbml0KCk7XG4gICAgICB9KTtcblxuICAgICAgbW9kdWxlRGVmaW5pdGlvbiA9IE9iamVjdC5hc3NpZ24oe30sIG1vZHVsZURlZmluaXRpb24sIHtcbiAgICAgICAgX19pbml0X186IGluaXRpYWxpemVyc1xuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBjcmVhdGVJbml0aWFsaXplcihtb2R1bGVEZWZpbml0aW9uLCBwcml2YXRlSW5qZWN0b3IpO1xuICAgIH1cblxuICAgIC8vIG5vcm1hbCBtb2R1bGVcbiAgICBPYmplY3Qua2V5cyhtb2R1bGVEZWZpbml0aW9uKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuXG4gICAgICBpZiAoa2V5ID09PSAnX19pbml0X18nIHx8IGtleSA9PT0gJ19fZGVwZW5kc19fJykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHR5cGVEZWNsYXJhdGlvbiA9IC8qKiBAdHlwZSB7IFR5cGVkRGVjbGFyYXRpb24gfSAqLyAoXG4gICAgICAgIG1vZHVsZURlZmluaXRpb25ba2V5XVxuICAgICAgKTtcblxuICAgICAgaWYgKHR5cGVEZWNsYXJhdGlvblsyXSA9PT0gJ3ByaXZhdGUnKSB7XG4gICAgICAgIHByb3ZpZGVyc1trZXldID0gdHlwZURlY2xhcmF0aW9uO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHR5cGUgPSB0eXBlRGVjbGFyYXRpb25bMF07XG4gICAgICBjb25zdCB2YWx1ZSA9IHR5cGVEZWNsYXJhdGlvblsxXTtcblxuICAgICAgcHJvdmlkZXJzW2tleV0gPSBbIGZhY3RvcnlNYXBbdHlwZV0sIGFycmF5VW53cmFwKHR5cGUsIHZhbHVlKSwgdHlwZSBdO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIGNyZWF0ZUluaXRpYWxpemVyKG1vZHVsZURlZmluaXRpb24sIHNlbGYpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7TW9kdWxlRGVmaW5pdGlvbltdfSBtb2R1bGVEZWZpbml0aW9uc1xuICAgKiBAcGFyYW0ge01vZHVsZURlZmluaXRpb259IG1vZHVsZURlZmluaXRpb25cbiAgICpcbiAgICogQHJldHVybiB7TW9kdWxlRGVmaW5pdGlvbltdfVxuICAgKi9cbiAgZnVuY3Rpb24gcmVzb2x2ZURlcGVuZGVuY2llcyhtb2R1bGVEZWZpbml0aW9ucywgbW9kdWxlRGVmaW5pdGlvbikge1xuXG4gICAgaWYgKG1vZHVsZURlZmluaXRpb25zLmluZGV4T2YobW9kdWxlRGVmaW5pdGlvbikgIT09IC0xKSB7XG4gICAgICByZXR1cm4gbW9kdWxlRGVmaW5pdGlvbnM7XG4gICAgfVxuXG4gICAgbW9kdWxlRGVmaW5pdGlvbnMgPSAobW9kdWxlRGVmaW5pdGlvbi5fX2RlcGVuZHNfXyB8fCBbXSkucmVkdWNlKHJlc29sdmVEZXBlbmRlbmNpZXMsIG1vZHVsZURlZmluaXRpb25zKTtcblxuICAgIGlmIChtb2R1bGVEZWZpbml0aW9ucy5pbmRleE9mKG1vZHVsZURlZmluaXRpb24pICE9PSAtMSkge1xuICAgICAgcmV0dXJuIG1vZHVsZURlZmluaXRpb25zO1xuICAgIH1cblxuICAgIHJldHVybiBtb2R1bGVEZWZpbml0aW9ucy5jb25jYXQobW9kdWxlRGVmaW5pdGlvbik7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtNb2R1bGVEZWZpbml0aW9uW119IG1vZHVsZURlZmluaXRpb25zXG4gICAqXG4gICAqIEByZXR1cm4geyAoKSA9PiB2b2lkIH0gaW5pdGlhbGl6ZXJGblxuICAgKi9cbiAgZnVuY3Rpb24gYm9vdHN0cmFwKG1vZHVsZURlZmluaXRpb25zKSB7XG5cbiAgICBjb25zdCBpbml0aWFsaXplcnMgPSBtb2R1bGVEZWZpbml0aW9uc1xuICAgICAgLnJlZHVjZShyZXNvbHZlRGVwZW5kZW5jaWVzLCBbXSlcbiAgICAgIC5tYXAobG9hZE1vZHVsZSk7XG5cbiAgICBsZXQgaW5pdGlhbGl6ZWQgPSBmYWxzZTtcblxuICAgIHJldHVybiBmdW5jdGlvbigpIHtcblxuICAgICAgaWYgKGluaXRpYWxpemVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaW5pdGlhbGl6ZWQgPSB0cnVlO1xuXG4gICAgICBpbml0aWFsaXplcnMuZm9yRWFjaChpbml0aWFsaXplciA9PiBpbml0aWFsaXplcigpKTtcbiAgICB9O1xuICB9XG5cbiAgLy8gcHVibGljIEFQSVxuICB0aGlzLmdldCA9IGdldDtcbiAgdGhpcy5pbnZva2UgPSBpbnZva2U7XG4gIHRoaXMuaW5zdGFudGlhdGUgPSBpbnN0YW50aWF0ZTtcbiAgdGhpcy5jcmVhdGVDaGlsZCA9IGNyZWF0ZUNoaWxkO1xuXG4gIC8vIHNldHVwXG4gIHRoaXMuaW5pdCA9IGJvb3RzdHJhcChtb2R1bGVzKTtcbn1cblxuXG4vLyBoZWxwZXJzIC8vLy8vLy8vLy8vLy8vL1xuXG5mdW5jdGlvbiBhcnJheVVud3JhcCh0eXBlLCB2YWx1ZSkge1xuICBpZiAodHlwZSAhPT0gJ3ZhbHVlJyAmJiBpc0FycmF5KHZhbHVlKSkge1xuICAgIHZhbHVlID0gYW5ub3RhdGUodmFsdWUuc2xpY2UoKSk7XG4gIH1cblxuICByZXR1cm4gdmFsdWU7XG59XG5cbmV4cG9ydCB7IEluamVjdG9yLCBhbm5vdGF0ZSwgcGFyc2VBbm5vdGF0aW9ucyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/didi/dist/index.js\n");

/***/ })

};
;