"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/object-refs";
exports.ids = ["vendor-chunks/object-refs"];
exports.modules = {

/***/ "(ssr)/./node_modules/object-refs/dist/index.js":
/*!************************************************!*\
  !*** ./node_modules/object-refs/dist/index.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Collection: () => (/* binding */ collection),\n/* harmony export */   Refs: () => (/* binding */ Refs)\n/* harmony export */ });\n/**\n * Extends a collection with {@link Refs} aware methods\n *\n * @param {Array<Object>} collection\n * @param {Refs} refs instance\n * @param {Object} property represented by the collection\n * @param {Object} target object the collection is attached to\n *\n * @return {RefsCollection<Object>} the extended array\n */\nfunction extend(collection, refs, property, target) {\n  var inverseProperty = property.inverse;\n\n  /**\n   * Removes the given element from the array and returns it.\n   *\n   * @method RefsCollection#remove\n   *\n   * @param {Object} element the element to remove\n   */\n  Object.defineProperty(collection, 'remove', {\n    value: function (element) {\n      var idx = this.indexOf(element);\n      if (idx !== -1) {\n        this.splice(idx, 1);\n\n        // unset inverse\n        refs.unset(element, inverseProperty, target);\n      }\n      return element;\n    }\n  });\n\n  /**\n   * Returns true if the collection contains the given element\n   *\n   * @method RefsCollection#contains\n   *\n   * @param {Object} element the element to check for\n   */\n  Object.defineProperty(collection, 'contains', {\n    value: function (element) {\n      return this.indexOf(element) !== -1;\n    }\n  });\n\n  /**\n   * Adds an element to the array, unless it exists already (set semantics).\n   *\n   * @method RefsCollection#add\n   *\n   * @param {Object} element the element to add\n   * @param {Number} optional index to add element to\n   *                 (possibly moving other elements around)\n   */\n  Object.defineProperty(collection, 'add', {\n    value: function (element, idx) {\n      var currentIdx = this.indexOf(element);\n      if (typeof idx === 'undefined') {\n        if (currentIdx !== -1) {\n          // element already in collection (!)\n          return;\n        }\n\n        // add to end of array, as no idx is specified\n        idx = this.length;\n      }\n\n      // handle already in collection\n      if (currentIdx !== -1) {\n        // remove element from currentIdx\n        this.splice(currentIdx, 1);\n      }\n\n      // add element at idx\n      this.splice(idx, 0, element);\n      if (currentIdx === -1) {\n        // set inverse, unless element was\n        // in collection already\n        refs.set(element, inverseProperty, target);\n      }\n    }\n  });\n\n  // a simple marker, identifying this element\n  // as being a refs collection\n  Object.defineProperty(collection, '__refs_collection', {\n    value: true\n  });\n  return collection;\n}\n\n/**\n * Checks if a given collection is extended\n *\n * @param {Array<Object>} collection\n *\n * @return {boolean}\n */\nfunction isExtended(collection) {\n  return collection.__refs_collection === true;\n}\n\nvar collection = {\n  __proto__: null,\n  extend: extend,\n  isExtended: isExtended\n};\n\nfunction hasOwnProperty(e, property) {\n  return Object.prototype.hasOwnProperty.call(e, property.name || property);\n}\nfunction defineCollectionProperty(ref, property, target) {\n  var collection = extend(target[property.name] || [], ref, property, target);\n  Object.defineProperty(target, property.name, {\n    enumerable: property.enumerable,\n    value: collection\n  });\n  if (collection.length) {\n    collection.forEach(function (o) {\n      ref.set(o, property.inverse, target);\n    });\n  }\n}\nfunction defineProperty(ref, property, target) {\n  var inverseProperty = property.inverse;\n  var _value = target[property.name];\n  Object.defineProperty(target, property.name, {\n    configurable: property.configurable,\n    enumerable: property.enumerable,\n    get: function () {\n      return _value;\n    },\n    set: function (value) {\n      // return if we already performed all changes\n      if (value === _value) {\n        return;\n      }\n      var old = _value;\n\n      // temporary set null\n      _value = null;\n      if (old) {\n        ref.unset(old, inverseProperty, target);\n      }\n\n      // set new value\n      _value = value;\n\n      // set inverse value\n      ref.set(_value, inverseProperty, target);\n    }\n  });\n}\n\n/**\n * Creates a new references object defining two inversly related\n * attribute descriptors a and b.\n *\n * <p>\n *   When bound to an object using {@link Refs#bind} the references\n *   get activated and ensure that add and remove operations are applied\n *   reversely, too.\n * </p>\n *\n * <p>\n *   For attributes represented as collections {@link Refs} provides the\n *   {@link RefsCollection#add}, {@link RefsCollection#remove} and {@link RefsCollection#contains} extensions\n *   that must be used to properly hook into the inverse change mechanism.\n * </p>\n *\n * @class Refs\n *\n * @classdesc A bi-directional reference between two attributes.\n *\n * @param {Refs.AttributeDescriptor} a property descriptor\n * @param {Refs.AttributeDescriptor} b property descriptor\n *\n * @example\n *\n * var refs = Refs({ name: 'wheels', collection: true, enumerable: true }, { name: 'car' });\n *\n * var car = { name: 'toyota' };\n * var wheels = [{ pos: 'front-left' }, { pos: 'front-right' }];\n *\n * refs.bind(car, 'wheels');\n *\n * car.wheels // []\n * car.wheels.add(wheels[0]);\n * car.wheels.add(wheels[1]);\n *\n * car.wheels // [{ pos: 'front-left' }, { pos: 'front-right' }]\n *\n * wheels[0].car // { name: 'toyota' };\n * car.wheels.remove(wheels[0]);\n *\n * wheels[0].car // undefined\n */\nfunction Refs(a, b) {\n  if (!(this instanceof Refs)) {\n    return new Refs(a, b);\n  }\n\n  // link\n  a.inverse = b;\n  b.inverse = a;\n  this.props = {};\n  this.props[a.name] = a;\n  this.props[b.name] = b;\n}\n\n/**\n * Binds one side of a bi-directional reference to a\n * target object.\n *\n * @memberOf Refs\n *\n * @param  {Object} target\n * @param  {String} property\n */\nRefs.prototype.bind = function (target, property) {\n  if (typeof property === 'string') {\n    if (!this.props[property]) {\n      throw new Error('no property <' + property + '> in ref');\n    }\n    property = this.props[property];\n  }\n  if (property.collection) {\n    defineCollectionProperty(this, property, target);\n  } else {\n    defineProperty(this, property, target);\n  }\n};\nRefs.prototype.ensureRefsCollection = function (target, property) {\n  var collection = target[property.name];\n  if (!isExtended(collection)) {\n    defineCollectionProperty(this, property, target);\n  }\n  return collection;\n};\nRefs.prototype.ensureBound = function (target, property) {\n  if (!hasOwnProperty(target, property)) {\n    this.bind(target, property);\n  }\n};\nRefs.prototype.unset = function (target, property, value) {\n  if (target) {\n    this.ensureBound(target, property);\n    if (property.collection) {\n      this.ensureRefsCollection(target, property).remove(value);\n    } else {\n      target[property.name] = undefined;\n    }\n  }\n};\nRefs.prototype.set = function (target, property, value) {\n  if (target) {\n    this.ensureBound(target, property);\n    if (property.collection) {\n      this.ensureRefsCollection(target, property).add(value);\n    } else {\n      target[property.name] = value;\n    }\n  }\n};\n\n/**\n * An attribute descriptor to be used specify an attribute in a {@link Refs} instance\n *\n * @typedef {Object} Refs.AttributeDescriptor\n * @property {String} name\n * @property {boolean} [collection=false]\n * @property {boolean} [enumerable=false]\n */\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb2JqZWN0LXJlZnMvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0EsOEJBQThCLFlBQVk7QUFDMUM7QUFDQSxXQUFXLGVBQWU7QUFDMUIsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQSxZQUFZLHdCQUF3QjtBQUNwQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZUFBZTtBQUMxQjtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsaUJBQWlCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsWUFBWTtBQUM1RCxNQUFNLHlCQUF5QixHQUFHLDZCQUE2QixLQUFLLCtCQUErQjtBQUNuRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsMEJBQTBCO0FBQ3JDLFdBQVcsMEJBQTBCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixvREFBb0QsSUFBSSxhQUFhO0FBQzFGO0FBQ0EsZUFBZTtBQUNmLG1CQUFtQixtQkFBbUIsSUFBSSxvQkFBb0I7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsbUJBQW1CLElBQUksb0JBQW9CO0FBQy9EO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlFQUFpRSxZQUFZO0FBQzdFO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFNBQVM7QUFDdkIsY0FBYyxTQUFTO0FBQ3ZCOztBQUUwQyIsInNvdXJjZXMiOlsid2VicGFjazovL2JwbW4tc3R1ZGlvLXdlYi8uL25vZGVfbW9kdWxlcy9vYmplY3QtcmVmcy9kaXN0L2luZGV4LmpzPzczMjkiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBFeHRlbmRzIGEgY29sbGVjdGlvbiB3aXRoIHtAbGluayBSZWZzfSBhd2FyZSBtZXRob2RzXG4gKlxuICogQHBhcmFtIHtBcnJheTxPYmplY3Q+fSBjb2xsZWN0aW9uXG4gKiBAcGFyYW0ge1JlZnN9IHJlZnMgaW5zdGFuY2VcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wZXJ0eSByZXByZXNlbnRlZCBieSB0aGUgY29sbGVjdGlvblxuICogQHBhcmFtIHtPYmplY3R9IHRhcmdldCBvYmplY3QgdGhlIGNvbGxlY3Rpb24gaXMgYXR0YWNoZWQgdG9cbiAqXG4gKiBAcmV0dXJuIHtSZWZzQ29sbGVjdGlvbjxPYmplY3Q+fSB0aGUgZXh0ZW5kZWQgYXJyYXlcbiAqL1xuZnVuY3Rpb24gZXh0ZW5kKGNvbGxlY3Rpb24sIHJlZnMsIHByb3BlcnR5LCB0YXJnZXQpIHtcbiAgdmFyIGludmVyc2VQcm9wZXJ0eSA9IHByb3BlcnR5LmludmVyc2U7XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgdGhlIGdpdmVuIGVsZW1lbnQgZnJvbSB0aGUgYXJyYXkgYW5kIHJldHVybnMgaXQuXG4gICAqXG4gICAqIEBtZXRob2QgUmVmc0NvbGxlY3Rpb24jcmVtb3ZlXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBlbGVtZW50IHRoZSBlbGVtZW50IHRvIHJlbW92ZVxuICAgKi9cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNvbGxlY3Rpb24sICdyZW1vdmUnLCB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICB2YXIgaWR4ID0gdGhpcy5pbmRleE9mKGVsZW1lbnQpO1xuICAgICAgaWYgKGlkeCAhPT0gLTEpIHtcbiAgICAgICAgdGhpcy5zcGxpY2UoaWR4LCAxKTtcblxuICAgICAgICAvLyB1bnNldCBpbnZlcnNlXG4gICAgICAgIHJlZnMudW5zZXQoZWxlbWVudCwgaW52ZXJzZVByb3BlcnR5LCB0YXJnZXQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgfVxuICB9KTtcblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBjb2xsZWN0aW9uIGNvbnRhaW5zIHRoZSBnaXZlbiBlbGVtZW50XG4gICAqXG4gICAqIEBtZXRob2QgUmVmc0NvbGxlY3Rpb24jY29udGFpbnNcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGVsZW1lbnQgdGhlIGVsZW1lbnQgdG8gY2hlY2sgZm9yXG4gICAqL1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29sbGVjdGlvbiwgJ2NvbnRhaW5zJywge1xuICAgIHZhbHVlOiBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgcmV0dXJuIHRoaXMuaW5kZXhPZihlbGVtZW50KSAhPT0gLTE7XG4gICAgfVxuICB9KTtcblxuICAvKipcbiAgICogQWRkcyBhbiBlbGVtZW50IHRvIHRoZSBhcnJheSwgdW5sZXNzIGl0IGV4aXN0cyBhbHJlYWR5IChzZXQgc2VtYW50aWNzKS5cbiAgICpcbiAgICogQG1ldGhvZCBSZWZzQ29sbGVjdGlvbiNhZGRcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGVsZW1lbnQgdGhlIGVsZW1lbnQgdG8gYWRkXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25hbCBpbmRleCB0byBhZGQgZWxlbWVudCB0b1xuICAgKiAgICAgICAgICAgICAgICAgKHBvc3NpYmx5IG1vdmluZyBvdGhlciBlbGVtZW50cyBhcm91bmQpXG4gICAqL1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29sbGVjdGlvbiwgJ2FkZCcsIHtcbiAgICB2YWx1ZTogZnVuY3Rpb24gKGVsZW1lbnQsIGlkeCkge1xuICAgICAgdmFyIGN1cnJlbnRJZHggPSB0aGlzLmluZGV4T2YoZWxlbWVudCk7XG4gICAgICBpZiAodHlwZW9mIGlkeCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgaWYgKGN1cnJlbnRJZHggIT09IC0xKSB7XG4gICAgICAgICAgLy8gZWxlbWVudCBhbHJlYWR5IGluIGNvbGxlY3Rpb24gKCEpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYWRkIHRvIGVuZCBvZiBhcnJheSwgYXMgbm8gaWR4IGlzIHNwZWNpZmllZFxuICAgICAgICBpZHggPSB0aGlzLmxlbmd0aDtcbiAgICAgIH1cblxuICAgICAgLy8gaGFuZGxlIGFscmVhZHkgaW4gY29sbGVjdGlvblxuICAgICAgaWYgKGN1cnJlbnRJZHggIT09IC0xKSB7XG4gICAgICAgIC8vIHJlbW92ZSBlbGVtZW50IGZyb20gY3VycmVudElkeFxuICAgICAgICB0aGlzLnNwbGljZShjdXJyZW50SWR4LCAxKTtcbiAgICAgIH1cblxuICAgICAgLy8gYWRkIGVsZW1lbnQgYXQgaWR4XG4gICAgICB0aGlzLnNwbGljZShpZHgsIDAsIGVsZW1lbnQpO1xuICAgICAgaWYgKGN1cnJlbnRJZHggPT09IC0xKSB7XG4gICAgICAgIC8vIHNldCBpbnZlcnNlLCB1bmxlc3MgZWxlbWVudCB3YXNcbiAgICAgICAgLy8gaW4gY29sbGVjdGlvbiBhbHJlYWR5XG4gICAgICAgIHJlZnMuc2V0KGVsZW1lbnQsIGludmVyc2VQcm9wZXJ0eSwgdGFyZ2V0KTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIC8vIGEgc2ltcGxlIG1hcmtlciwgaWRlbnRpZnlpbmcgdGhpcyBlbGVtZW50XG4gIC8vIGFzIGJlaW5nIGEgcmVmcyBjb2xsZWN0aW9uXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb2xsZWN0aW9uLCAnX19yZWZzX2NvbGxlY3Rpb24nLCB7XG4gICAgdmFsdWU6IHRydWVcbiAgfSk7XG4gIHJldHVybiBjb2xsZWN0aW9uO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBhIGdpdmVuIGNvbGxlY3Rpb24gaXMgZXh0ZW5kZWRcbiAqXG4gKiBAcGFyYW0ge0FycmF5PE9iamVjdD59IGNvbGxlY3Rpb25cbiAqXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc0V4dGVuZGVkKGNvbGxlY3Rpb24pIHtcbiAgcmV0dXJuIGNvbGxlY3Rpb24uX19yZWZzX2NvbGxlY3Rpb24gPT09IHRydWU7XG59XG5cbnZhciBjb2xsZWN0aW9uID0ge1xuICBfX3Byb3RvX186IG51bGwsXG4gIGV4dGVuZDogZXh0ZW5kLFxuICBpc0V4dGVuZGVkOiBpc0V4dGVuZGVkXG59O1xuXG5mdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eShlLCBwcm9wZXJ0eSkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsIHByb3BlcnR5Lm5hbWUgfHwgcHJvcGVydHkpO1xufVxuZnVuY3Rpb24gZGVmaW5lQ29sbGVjdGlvblByb3BlcnR5KHJlZiwgcHJvcGVydHksIHRhcmdldCkge1xuICB2YXIgY29sbGVjdGlvbiA9IGV4dGVuZCh0YXJnZXRbcHJvcGVydHkubmFtZV0gfHwgW10sIHJlZiwgcHJvcGVydHksIHRhcmdldCk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIHByb3BlcnR5Lm5hbWUsIHtcbiAgICBlbnVtZXJhYmxlOiBwcm9wZXJ0eS5lbnVtZXJhYmxlLFxuICAgIHZhbHVlOiBjb2xsZWN0aW9uXG4gIH0pO1xuICBpZiAoY29sbGVjdGlvbi5sZW5ndGgpIHtcbiAgICBjb2xsZWN0aW9uLmZvckVhY2goZnVuY3Rpb24gKG8pIHtcbiAgICAgIHJlZi5zZXQobywgcHJvcGVydHkuaW52ZXJzZSwgdGFyZ2V0KTtcbiAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkocmVmLCBwcm9wZXJ0eSwgdGFyZ2V0KSB7XG4gIHZhciBpbnZlcnNlUHJvcGVydHkgPSBwcm9wZXJ0eS5pbnZlcnNlO1xuICB2YXIgX3ZhbHVlID0gdGFyZ2V0W3Byb3BlcnR5Lm5hbWVdO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBwcm9wZXJ0eS5uYW1lLCB7XG4gICAgY29uZmlndXJhYmxlOiBwcm9wZXJ0eS5jb25maWd1cmFibGUsXG4gICAgZW51bWVyYWJsZTogcHJvcGVydHkuZW51bWVyYWJsZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfdmFsdWU7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgLy8gcmV0dXJuIGlmIHdlIGFscmVhZHkgcGVyZm9ybWVkIGFsbCBjaGFuZ2VzXG4gICAgICBpZiAodmFsdWUgPT09IF92YWx1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgb2xkID0gX3ZhbHVlO1xuXG4gICAgICAvLyB0ZW1wb3Jhcnkgc2V0IG51bGxcbiAgICAgIF92YWx1ZSA9IG51bGw7XG4gICAgICBpZiAob2xkKSB7XG4gICAgICAgIHJlZi51bnNldChvbGQsIGludmVyc2VQcm9wZXJ0eSwgdGFyZ2V0KTtcbiAgICAgIH1cblxuICAgICAgLy8gc2V0IG5ldyB2YWx1ZVxuICAgICAgX3ZhbHVlID0gdmFsdWU7XG5cbiAgICAgIC8vIHNldCBpbnZlcnNlIHZhbHVlXG4gICAgICByZWYuc2V0KF92YWx1ZSwgaW52ZXJzZVByb3BlcnR5LCB0YXJnZXQpO1xuICAgIH1cbiAgfSk7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyByZWZlcmVuY2VzIG9iamVjdCBkZWZpbmluZyB0d28gaW52ZXJzbHkgcmVsYXRlZFxuICogYXR0cmlidXRlIGRlc2NyaXB0b3JzIGEgYW5kIGIuXG4gKlxuICogPHA+XG4gKiAgIFdoZW4gYm91bmQgdG8gYW4gb2JqZWN0IHVzaW5nIHtAbGluayBSZWZzI2JpbmR9IHRoZSByZWZlcmVuY2VzXG4gKiAgIGdldCBhY3RpdmF0ZWQgYW5kIGVuc3VyZSB0aGF0IGFkZCBhbmQgcmVtb3ZlIG9wZXJhdGlvbnMgYXJlIGFwcGxpZWRcbiAqICAgcmV2ZXJzZWx5LCB0b28uXG4gKiA8L3A+XG4gKlxuICogPHA+XG4gKiAgIEZvciBhdHRyaWJ1dGVzIHJlcHJlc2VudGVkIGFzIGNvbGxlY3Rpb25zIHtAbGluayBSZWZzfSBwcm92aWRlcyB0aGVcbiAqICAge0BsaW5rIFJlZnNDb2xsZWN0aW9uI2FkZH0sIHtAbGluayBSZWZzQ29sbGVjdGlvbiNyZW1vdmV9IGFuZCB7QGxpbmsgUmVmc0NvbGxlY3Rpb24jY29udGFpbnN9IGV4dGVuc2lvbnNcbiAqICAgdGhhdCBtdXN0IGJlIHVzZWQgdG8gcHJvcGVybHkgaG9vayBpbnRvIHRoZSBpbnZlcnNlIGNoYW5nZSBtZWNoYW5pc20uXG4gKiA8L3A+XG4gKlxuICogQGNsYXNzIFJlZnNcbiAqXG4gKiBAY2xhc3NkZXNjIEEgYmktZGlyZWN0aW9uYWwgcmVmZXJlbmNlIGJldHdlZW4gdHdvIGF0dHJpYnV0ZXMuXG4gKlxuICogQHBhcmFtIHtSZWZzLkF0dHJpYnV0ZURlc2NyaXB0b3J9IGEgcHJvcGVydHkgZGVzY3JpcHRvclxuICogQHBhcmFtIHtSZWZzLkF0dHJpYnV0ZURlc2NyaXB0b3J9IGIgcHJvcGVydHkgZGVzY3JpcHRvclxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIHJlZnMgPSBSZWZzKHsgbmFtZTogJ3doZWVscycsIGNvbGxlY3Rpb246IHRydWUsIGVudW1lcmFibGU6IHRydWUgfSwgeyBuYW1lOiAnY2FyJyB9KTtcbiAqXG4gKiB2YXIgY2FyID0geyBuYW1lOiAndG95b3RhJyB9O1xuICogdmFyIHdoZWVscyA9IFt7IHBvczogJ2Zyb250LWxlZnQnIH0sIHsgcG9zOiAnZnJvbnQtcmlnaHQnIH1dO1xuICpcbiAqIHJlZnMuYmluZChjYXIsICd3aGVlbHMnKTtcbiAqXG4gKiBjYXIud2hlZWxzIC8vIFtdXG4gKiBjYXIud2hlZWxzLmFkZCh3aGVlbHNbMF0pO1xuICogY2FyLndoZWVscy5hZGQod2hlZWxzWzFdKTtcbiAqXG4gKiBjYXIud2hlZWxzIC8vIFt7IHBvczogJ2Zyb250LWxlZnQnIH0sIHsgcG9zOiAnZnJvbnQtcmlnaHQnIH1dXG4gKlxuICogd2hlZWxzWzBdLmNhciAvLyB7IG5hbWU6ICd0b3lvdGEnIH07XG4gKiBjYXIud2hlZWxzLnJlbW92ZSh3aGVlbHNbMF0pO1xuICpcbiAqIHdoZWVsc1swXS5jYXIgLy8gdW5kZWZpbmVkXG4gKi9cbmZ1bmN0aW9uIFJlZnMoYSwgYikge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUmVmcykpIHtcbiAgICByZXR1cm4gbmV3IFJlZnMoYSwgYik7XG4gIH1cblxuICAvLyBsaW5rXG4gIGEuaW52ZXJzZSA9IGI7XG4gIGIuaW52ZXJzZSA9IGE7XG4gIHRoaXMucHJvcHMgPSB7fTtcbiAgdGhpcy5wcm9wc1thLm5hbWVdID0gYTtcbiAgdGhpcy5wcm9wc1tiLm5hbWVdID0gYjtcbn1cblxuLyoqXG4gKiBCaW5kcyBvbmUgc2lkZSBvZiBhIGJpLWRpcmVjdGlvbmFsIHJlZmVyZW5jZSB0byBhXG4gKiB0YXJnZXQgb2JqZWN0LlxuICpcbiAqIEBtZW1iZXJPZiBSZWZzXG4gKlxuICogQHBhcmFtICB7T2JqZWN0fSB0YXJnZXRcbiAqIEBwYXJhbSAge1N0cmluZ30gcHJvcGVydHlcbiAqL1xuUmVmcy5wcm90b3R5cGUuYmluZCA9IGZ1bmN0aW9uICh0YXJnZXQsIHByb3BlcnR5KSB7XG4gIGlmICh0eXBlb2YgcHJvcGVydHkgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKCF0aGlzLnByb3BzW3Byb3BlcnR5XSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdubyBwcm9wZXJ0eSA8JyArIHByb3BlcnR5ICsgJz4gaW4gcmVmJyk7XG4gICAgfVxuICAgIHByb3BlcnR5ID0gdGhpcy5wcm9wc1twcm9wZXJ0eV07XG4gIH1cbiAgaWYgKHByb3BlcnR5LmNvbGxlY3Rpb24pIHtcbiAgICBkZWZpbmVDb2xsZWN0aW9uUHJvcGVydHkodGhpcywgcHJvcGVydHksIHRhcmdldCk7XG4gIH0gZWxzZSB7XG4gICAgZGVmaW5lUHJvcGVydHkodGhpcywgcHJvcGVydHksIHRhcmdldCk7XG4gIH1cbn07XG5SZWZzLnByb3RvdHlwZS5lbnN1cmVSZWZzQ29sbGVjdGlvbiA9IGZ1bmN0aW9uICh0YXJnZXQsIHByb3BlcnR5KSB7XG4gIHZhciBjb2xsZWN0aW9uID0gdGFyZ2V0W3Byb3BlcnR5Lm5hbWVdO1xuICBpZiAoIWlzRXh0ZW5kZWQoY29sbGVjdGlvbikpIHtcbiAgICBkZWZpbmVDb2xsZWN0aW9uUHJvcGVydHkodGhpcywgcHJvcGVydHksIHRhcmdldCk7XG4gIH1cbiAgcmV0dXJuIGNvbGxlY3Rpb247XG59O1xuUmVmcy5wcm90b3R5cGUuZW5zdXJlQm91bmQgPSBmdW5jdGlvbiAodGFyZ2V0LCBwcm9wZXJ0eSkge1xuICBpZiAoIWhhc093blByb3BlcnR5KHRhcmdldCwgcHJvcGVydHkpKSB7XG4gICAgdGhpcy5iaW5kKHRhcmdldCwgcHJvcGVydHkpO1xuICB9XG59O1xuUmVmcy5wcm90b3R5cGUudW5zZXQgPSBmdW5jdGlvbiAodGFyZ2V0LCBwcm9wZXJ0eSwgdmFsdWUpIHtcbiAgaWYgKHRhcmdldCkge1xuICAgIHRoaXMuZW5zdXJlQm91bmQodGFyZ2V0LCBwcm9wZXJ0eSk7XG4gICAgaWYgKHByb3BlcnR5LmNvbGxlY3Rpb24pIHtcbiAgICAgIHRoaXMuZW5zdXJlUmVmc0NvbGxlY3Rpb24odGFyZ2V0LCBwcm9wZXJ0eSkucmVtb3ZlKHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGFyZ2V0W3Byb3BlcnR5Lm5hbWVdID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfVxufTtcblJlZnMucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uICh0YXJnZXQsIHByb3BlcnR5LCB2YWx1ZSkge1xuICBpZiAodGFyZ2V0KSB7XG4gICAgdGhpcy5lbnN1cmVCb3VuZCh0YXJnZXQsIHByb3BlcnR5KTtcbiAgICBpZiAocHJvcGVydHkuY29sbGVjdGlvbikge1xuICAgICAgdGhpcy5lbnN1cmVSZWZzQ29sbGVjdGlvbih0YXJnZXQsIHByb3BlcnR5KS5hZGQodmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0YXJnZXRbcHJvcGVydHkubmFtZV0gPSB2YWx1ZTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogQW4gYXR0cmlidXRlIGRlc2NyaXB0b3IgdG8gYmUgdXNlZCBzcGVjaWZ5IGFuIGF0dHJpYnV0ZSBpbiBhIHtAbGluayBSZWZzfSBpbnN0YW5jZVxuICpcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFJlZnMuQXR0cmlidXRlRGVzY3JpcHRvclxuICogQHByb3BlcnR5IHtTdHJpbmd9IG5hbWVcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2NvbGxlY3Rpb249ZmFsc2VdXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtlbnVtZXJhYmxlPWZhbHNlXVxuICovXG5cbmV4cG9ydCB7IGNvbGxlY3Rpb24gYXMgQ29sbGVjdGlvbiwgUmVmcyB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/object-refs/dist/index.js\n");

/***/ })

};
;