"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/moddle-xml";
exports.ids = ["vendor-chunks/moddle-xml"];
exports.modules = {

/***/ "(ssr)/./node_modules/moddle-xml/dist/index.js":
/*!***********************************************!*\
  !*** ./node_modules/moddle-xml/dist/index.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Reader: () => (/* binding */ Reader),\n/* harmony export */   Writer: () => (/* binding */ Writer)\n/* harmony export */ });\n/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! min-dash */ \"(ssr)/./node_modules/min-dash/dist/index.esm.js\");\n/* harmony import */ var saxen__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! saxen */ \"(ssr)/./node_modules/saxen/dist/index.js\");\n/* harmony import */ var moddle__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! moddle */ \"(ssr)/./node_modules/moddle/dist/index.js\");\n\n\n\n\nfunction hasLowerCaseAlias(pkg) {\n  return pkg.xml && pkg.xml.tagAlias === 'lowerCase';\n}\n\nvar DEFAULT_NS_MAP = {\n  'xsi': 'http://www.w3.org/2001/XMLSchema-instance',\n  'xml': 'http://www.w3.org/XML/1998/namespace'\n};\n\nvar SERIALIZE_PROPERTY = 'property';\n\nfunction getSerialization(element) {\n  return element.xml && element.xml.serialize;\n}\n\nfunction getSerializationType(element) {\n  const type = getSerialization(element);\n\n  return type !== SERIALIZE_PROPERTY && (type || null);\n}\n\nfunction capitalize(str) {\n  return str.charAt(0).toUpperCase() + str.slice(1);\n}\n\nfunction aliasToName(aliasNs, pkg) {\n\n  if (!hasLowerCaseAlias(pkg)) {\n    return aliasNs.name;\n  }\n\n  return aliasNs.prefix + ':' + capitalize(aliasNs.localName);\n}\n\n/**\n * Un-prefix a potentially prefixed type name.\n *\n * @param {NsName} nameNs\n * @param {Object} [pkg]\n *\n * @return {string}\n */\nfunction prefixedToName(nameNs, pkg) {\n\n  var name = nameNs.name,\n      localName = nameNs.localName;\n\n  var typePrefix = pkg && pkg.xml && pkg.xml.typePrefix;\n\n  if (typePrefix && localName.indexOf(typePrefix) === 0) {\n    return nameNs.prefix + ':' + localName.slice(typePrefix.length);\n  } else {\n    return name;\n  }\n}\n\nfunction normalizeTypeName(name, nsMap, model) {\n\n  // normalize against actual NS\n  const nameNs = (0,moddle__WEBPACK_IMPORTED_MODULE_1__.parseNameNS)(name, nsMap.xmlns);\n\n  const normalizedName = `${ nsMap[nameNs.prefix] || nameNs.prefix }:${ nameNs.localName }`;\n\n  const normalizedNameNs = (0,moddle__WEBPACK_IMPORTED_MODULE_1__.parseNameNS)(normalizedName);\n\n  // determine actual type name, based on package-defined prefix\n  var pkg = model.getPackage(normalizedNameNs.prefix);\n\n  return prefixedToName(normalizedNameNs, pkg);\n}\n\nfunction error(message) {\n  return new Error(message);\n}\n\n/**\n * Get the moddle descriptor for a given instance or type.\n *\n * @param  {ModdleElement|Function} element\n *\n * @return {Object} the moddle descriptor\n */\nfunction getModdleDescriptor(element) {\n  return element.$descriptor;\n}\n\n\n/**\n * A parse context.\n *\n * @class\n *\n * @param {Object} options\n * @param {ElementHandler} options.rootHandler the root handler for parsing a document\n * @param {boolean} [options.lax=false] whether or not to ignore invalid elements\n */\nfunction Context(options) {\n\n  /**\n   * @property {ElementHandler} rootHandler\n   */\n\n  /**\n   * @property {Boolean} lax\n   */\n\n  (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.assign)(this, options);\n\n  this.elementsById = {};\n  this.references = [];\n  this.warnings = [];\n\n  /**\n   * Add an unresolved reference.\n   *\n   * @param {Object} reference\n   */\n  this.addReference = function(reference) {\n    this.references.push(reference);\n  };\n\n  /**\n   * Add a processed element.\n   *\n   * @param {ModdleElement} element\n   */\n  this.addElement = function(element) {\n\n    if (!element) {\n      throw error('expected element');\n    }\n\n    var elementsById = this.elementsById;\n\n    var descriptor = getModdleDescriptor(element);\n\n    var idProperty = descriptor.idProperty,\n        id;\n\n    if (idProperty) {\n      id = element.get(idProperty.name);\n\n      if (id) {\n\n        // for QName validation as per http://www.w3.org/TR/REC-xml/#NT-NameChar\n        if (!/^([a-z][\\w-.]*:)?[a-z_][\\w-.]*$/i.test(id)) {\n          throw new Error('illegal ID <' + id + '>');\n        }\n\n        if (elementsById[id]) {\n          throw error('duplicate ID <' + id + '>');\n        }\n\n        elementsById[id] = element;\n      }\n    }\n  };\n\n  /**\n   * Add an import warning.\n   *\n   * @param {Object} warning\n   * @param {String} warning.message\n   * @param {Error} [warning.error]\n   */\n  this.addWarning = function(warning) {\n    this.warnings.push(warning);\n  };\n}\n\nfunction BaseHandler() {}\n\nBaseHandler.prototype.handleEnd = function() {};\nBaseHandler.prototype.handleText = function() {};\nBaseHandler.prototype.handleNode = function() {};\n\n\n/**\n * A simple pass through handler that does nothing except for\n * ignoring all input it receives.\n *\n * This is used to ignore unknown elements and\n * attributes.\n */\nfunction NoopHandler() { }\n\nNoopHandler.prototype = Object.create(BaseHandler.prototype);\n\nNoopHandler.prototype.handleNode = function() {\n  return this;\n};\n\nfunction BodyHandler() {}\n\nBodyHandler.prototype = Object.create(BaseHandler.prototype);\n\nBodyHandler.prototype.handleText = function(text) {\n  this.body = (this.body || '') + text;\n};\n\nfunction ReferenceHandler(property, context) {\n  this.property = property;\n  this.context = context;\n}\n\nReferenceHandler.prototype = Object.create(BodyHandler.prototype);\n\nReferenceHandler.prototype.handleNode = function(node) {\n\n  if (this.element) {\n    throw error('expected no sub nodes');\n  } else {\n    this.element = this.createReference(node);\n  }\n\n  return this;\n};\n\nReferenceHandler.prototype.handleEnd = function() {\n  this.element.id = this.body;\n};\n\nReferenceHandler.prototype.createReference = function(node) {\n  return {\n    property: this.property.ns.name,\n    id: ''\n  };\n};\n\nfunction ValueHandler(propertyDesc, element) {\n  this.element = element;\n  this.propertyDesc = propertyDesc;\n}\n\nValueHandler.prototype = Object.create(BodyHandler.prototype);\n\nValueHandler.prototype.handleEnd = function() {\n\n  var value = this.body || '',\n      element = this.element,\n      propertyDesc = this.propertyDesc;\n\n  value = (0,moddle__WEBPACK_IMPORTED_MODULE_1__.coerceType)(propertyDesc.type, value);\n\n  if (propertyDesc.isMany) {\n    element.get(propertyDesc.name).push(value);\n  } else {\n    element.set(propertyDesc.name, value);\n  }\n};\n\n\nfunction BaseElementHandler() {}\n\nBaseElementHandler.prototype = Object.create(BodyHandler.prototype);\n\nBaseElementHandler.prototype.handleNode = function(node) {\n  var parser = this,\n      element = this.element;\n\n  if (!element) {\n    element = this.element = this.createElement(node);\n\n    this.context.addElement(element);\n  } else {\n    parser = this.handleChild(node);\n  }\n\n  return parser;\n};\n\n/**\n * @class Reader.ElementHandler\n *\n */\nfunction ElementHandler(model, typeName, context) {\n  this.model = model;\n  this.type = model.getType(typeName);\n  this.context = context;\n}\n\nElementHandler.prototype = Object.create(BaseElementHandler.prototype);\n\nElementHandler.prototype.addReference = function(reference) {\n  this.context.addReference(reference);\n};\n\nElementHandler.prototype.handleText = function(text) {\n\n  var element = this.element,\n      descriptor = getModdleDescriptor(element),\n      bodyProperty = descriptor.bodyProperty;\n\n  if (!bodyProperty) {\n    throw error('unexpected body text <' + text + '>');\n  }\n\n  BodyHandler.prototype.handleText.call(this, text);\n};\n\nElementHandler.prototype.handleEnd = function() {\n\n  var value = this.body,\n      element = this.element,\n      descriptor = getModdleDescriptor(element),\n      bodyProperty = descriptor.bodyProperty;\n\n  if (bodyProperty && value !== undefined) {\n    value = (0,moddle__WEBPACK_IMPORTED_MODULE_1__.coerceType)(bodyProperty.type, value);\n    element.set(bodyProperty.name, value);\n  }\n};\n\n/**\n * Create an instance of the model from the given node.\n *\n * @param  {Element} node the xml node\n */\nElementHandler.prototype.createElement = function(node) {\n  var attributes = node.attributes,\n      Type = this.type,\n      descriptor = getModdleDescriptor(Type),\n      context = this.context,\n      instance = new Type({}),\n      model = this.model,\n      propNameNs;\n\n  (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.forEach)(attributes, function(value, name) {\n\n    var prop = descriptor.propertiesByName[name],\n        values;\n\n    if (prop && prop.isReference) {\n\n      if (!prop.isMany) {\n        context.addReference({\n          element: instance,\n          property: prop.ns.name,\n          id: value\n        });\n      } else {\n\n        // IDREFS: parse references as whitespace-separated list\n        values = value.split(' ');\n\n        (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.forEach)(values, function(v) {\n          context.addReference({\n            element: instance,\n            property: prop.ns.name,\n            id: v\n          });\n        });\n      }\n\n    } else {\n      if (prop) {\n        value = (0,moddle__WEBPACK_IMPORTED_MODULE_1__.coerceType)(prop.type, value);\n      } else if (name === 'xmlns') {\n        name = ':' + name;\n      } else {\n        propNameNs = (0,moddle__WEBPACK_IMPORTED_MODULE_1__.parseNameNS)(name, descriptor.ns.prefix);\n\n        // check whether attribute is defined in a well-known namespace\n        // if that is the case we emit a warning to indicate potential misuse\n        if (model.getPackage(propNameNs.prefix)) {\n\n          context.addWarning({\n            message: 'unknown attribute <' + name + '>',\n            element: instance,\n            property: name,\n            value: value\n          });\n        }\n      }\n\n      instance.set(name, value);\n    }\n  });\n\n  return instance;\n};\n\nElementHandler.prototype.getPropertyForNode = function(node) {\n\n  var name = node.name;\n  var nameNs = (0,moddle__WEBPACK_IMPORTED_MODULE_1__.parseNameNS)(name);\n\n  var type = this.type,\n      model = this.model,\n      descriptor = getModdleDescriptor(type);\n\n  var propertyName = nameNs.name,\n      property = descriptor.propertiesByName[propertyName];\n\n  // search for properties by name first\n\n  if (property && !property.isAttr) {\n\n    const serializationType = getSerializationType(property);\n\n    if (serializationType) {\n      const elementTypeName = node.attributes[serializationType];\n\n      // type is optional, if it does not exists the\n      // default type is assumed\n      if (elementTypeName) {\n\n        // convert the prefix used to the mapped form, but also\n        // take possible type prefixes from XML\n        // into account, i.e.: xsi:type=\"t{ActualType}\",\n        const normalizedTypeName = normalizeTypeName(elementTypeName, node.ns, model);\n\n        const elementType = model.getType(normalizedTypeName);\n\n        return (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.assign)({}, property, {\n          effectiveType: getModdleDescriptor(elementType).name\n        });\n      }\n    }\n\n    // search for properties by name first\n    return property;\n  }\n\n  var pkg = model.getPackage(nameNs.prefix);\n\n  if (pkg) {\n    const elementTypeName = aliasToName(nameNs, pkg);\n    const elementType = model.getType(elementTypeName);\n\n    // search for collection members later\n    property = (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.find)(descriptor.properties, function(p) {\n      return !p.isVirtual && !p.isReference && !p.isAttribute && elementType.hasType(p.type);\n    });\n\n    if (property) {\n      return (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.assign)({}, property, {\n        effectiveType: getModdleDescriptor(elementType).name\n      });\n    }\n  } else {\n\n    // parse unknown element (maybe extension)\n    property = (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.find)(descriptor.properties, function(p) {\n      return !p.isReference && !p.isAttribute && p.type === 'Element';\n    });\n\n    if (property) {\n      return property;\n    }\n  }\n\n  throw error('unrecognized element <' + nameNs.name + '>');\n};\n\nElementHandler.prototype.toString = function() {\n  return 'ElementDescriptor[' + getModdleDescriptor(this.type).name + ']';\n};\n\nElementHandler.prototype.valueHandler = function(propertyDesc, element) {\n  return new ValueHandler(propertyDesc, element);\n};\n\nElementHandler.prototype.referenceHandler = function(propertyDesc) {\n  return new ReferenceHandler(propertyDesc, this.context);\n};\n\nElementHandler.prototype.handler = function(type) {\n  if (type === 'Element') {\n    return new GenericElementHandler(this.model, type, this.context);\n  } else {\n    return new ElementHandler(this.model, type, this.context);\n  }\n};\n\n/**\n * Handle the child element parsing\n *\n * @param  {Element} node the xml node\n */\nElementHandler.prototype.handleChild = function(node) {\n  var propertyDesc, type, element, childHandler;\n\n  propertyDesc = this.getPropertyForNode(node);\n  element = this.element;\n\n  type = propertyDesc.effectiveType || propertyDesc.type;\n\n  if ((0,moddle__WEBPACK_IMPORTED_MODULE_1__.isSimpleType)(type)) {\n    return this.valueHandler(propertyDesc, element);\n  }\n\n  if (propertyDesc.isReference) {\n    childHandler = this.referenceHandler(propertyDesc).handleNode(node);\n  } else {\n    childHandler = this.handler(type).handleNode(node);\n  }\n\n  var newElement = childHandler.element;\n\n  // child handles may decide to skip elements\n  // by not returning anything\n  if (newElement !== undefined) {\n\n    if (propertyDesc.isMany) {\n      element.get(propertyDesc.name).push(newElement);\n    } else {\n      element.set(propertyDesc.name, newElement);\n    }\n\n    if (propertyDesc.isReference) {\n      (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.assign)(newElement, {\n        element: element\n      });\n\n      this.context.addReference(newElement);\n    } else {\n\n      // establish child -> parent relationship\n      newElement.$parent = element;\n    }\n  }\n\n  return childHandler;\n};\n\n/**\n * An element handler that performs special validation\n * to ensure the node it gets initialized with matches\n * the handlers type (namespace wise).\n *\n * @param {Moddle} model\n * @param {String} typeName\n * @param {Context} context\n */\nfunction RootElementHandler(model, typeName, context) {\n  ElementHandler.call(this, model, typeName, context);\n}\n\nRootElementHandler.prototype = Object.create(ElementHandler.prototype);\n\nRootElementHandler.prototype.createElement = function(node) {\n\n  var name = node.name,\n      nameNs = (0,moddle__WEBPACK_IMPORTED_MODULE_1__.parseNameNS)(name),\n      model = this.model,\n      type = this.type,\n      pkg = model.getPackage(nameNs.prefix),\n      typeName = pkg && aliasToName(nameNs, pkg) || name;\n\n  // verify the correct namespace if we parse\n  // the first element in the handler tree\n  //\n  // this ensures we don't mistakenly import wrong namespace elements\n  if (!type.hasType(typeName)) {\n    throw error('unexpected element <' + node.originalName + '>');\n  }\n\n  return ElementHandler.prototype.createElement.call(this, node);\n};\n\n\nfunction GenericElementHandler(model, typeName, context) {\n  this.model = model;\n  this.context = context;\n}\n\nGenericElementHandler.prototype = Object.create(BaseElementHandler.prototype);\n\nGenericElementHandler.prototype.createElement = function(node) {\n\n  var name = node.name,\n      ns = (0,moddle__WEBPACK_IMPORTED_MODULE_1__.parseNameNS)(name),\n      prefix = ns.prefix,\n      uri = node.ns[prefix + '$uri'],\n      attributes = node.attributes;\n\n  return this.model.createAny(name, uri, attributes);\n};\n\nGenericElementHandler.prototype.handleChild = function(node) {\n\n  var handler = new GenericElementHandler(this.model, 'Element', this.context).handleNode(node),\n      element = this.element;\n\n  var newElement = handler.element,\n      children;\n\n  if (newElement !== undefined) {\n    children = element.$children = element.$children || [];\n    children.push(newElement);\n\n    // establish child -> parent relationship\n    newElement.$parent = element;\n  }\n\n  return handler;\n};\n\nGenericElementHandler.prototype.handleEnd = function() {\n  if (this.body) {\n    this.element.$body = this.body;\n  }\n};\n\n/**\n * A reader for a meta-model\n *\n * @param {Object} options\n * @param {Model} options.model used to read xml files\n * @param {Boolean} options.lax whether to make parse errors warnings\n */\nfunction Reader(options) {\n\n  if (options instanceof moddle__WEBPACK_IMPORTED_MODULE_1__.Moddle) {\n    options = {\n      model: options\n    };\n  }\n\n  (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.assign)(this, { lax: false }, options);\n}\n\n/**\n * The fromXML result.\n *\n * @typedef {Object} ParseResult\n *\n * @property {ModdleElement} rootElement\n * @property {Array<Object>} references\n * @property {Array<Error>} warnings\n * @property {Object} elementsById - a mapping containing each ID -> ModdleElement\n */\n\n/**\n * The fromXML result.\n *\n * @typedef {Error} ParseError\n *\n * @property {Array<Error>} warnings\n */\n\n/**\n * Parse the given XML into a moddle document tree.\n *\n * @param {String} xml\n * @param {ElementHandler|Object} options or rootHandler\n *\n * @returns {Promise<ParseResult, ParseError>}\n */\nReader.prototype.fromXML = function(xml, options, done) {\n\n  var rootHandler = options.rootHandler;\n\n  if (options instanceof ElementHandler) {\n\n    // root handler passed via (xml, { rootHandler: ElementHandler }, ...)\n    rootHandler = options;\n    options = {};\n  } else {\n    if (typeof options === 'string') {\n\n      // rootHandler passed via (xml, 'someString', ...)\n      rootHandler = this.handler(options);\n      options = {};\n    } else if (typeof rootHandler === 'string') {\n\n      // rootHandler passed via (xml, { rootHandler: 'someString' }, ...)\n      rootHandler = this.handler(rootHandler);\n    }\n  }\n\n  var model = this.model,\n      lax = this.lax;\n\n  var context = new Context((0,min_dash__WEBPACK_IMPORTED_MODULE_2__.assign)({}, options, { rootHandler: rootHandler })),\n      parser = new saxen__WEBPACK_IMPORTED_MODULE_0__.Parser({ proxy: true }),\n      stack = createStack();\n\n  rootHandler.context = context;\n\n  // push root handler\n  stack.push(rootHandler);\n\n\n  /**\n   * Handle error.\n   *\n   * @param  {Error} err\n   * @param  {Function} getContext\n   * @param  {boolean} lax\n   *\n   * @return {boolean} true if handled\n   */\n  function handleError(err, getContext, lax) {\n\n    var ctx = getContext();\n\n    var line = ctx.line,\n        column = ctx.column,\n        data = ctx.data;\n\n    // we receive the full context data here,\n    // for elements trim down the information\n    // to the tag name, only\n    if (data.charAt(0) === '<' && data.indexOf(' ') !== -1) {\n      data = data.slice(0, data.indexOf(' ')) + '>';\n    }\n\n    var message =\n      'unparsable content ' + (data ? data + ' ' : '') + 'detected\\n\\t' +\n        'line: ' + line + '\\n\\t' +\n        'column: ' + column + '\\n\\t' +\n        'nested error: ' + err.message;\n\n    if (lax) {\n      context.addWarning({\n        message: message,\n        error: err\n      });\n\n      return true;\n    } else {\n      throw error(message);\n    }\n  }\n\n  function handleWarning(err, getContext) {\n\n    // just like handling errors in <lax=true> mode\n    return handleError(err, getContext, true);\n  }\n\n  /**\n   * Resolve collected references on parse end.\n   */\n  function resolveReferences() {\n\n    var elementsById = context.elementsById;\n    var references = context.references;\n\n    var i, r;\n\n    for (i = 0; (r = references[i]); i++) {\n      var element = r.element;\n      var reference = elementsById[r.id];\n      var property = getModdleDescriptor(element).propertiesByName[r.property];\n\n      if (!reference) {\n        context.addWarning({\n          message: 'unresolved reference <' + r.id + '>',\n          element: r.element,\n          property: r.property,\n          value: r.id\n        });\n      }\n\n      if (property.isMany) {\n        var collection = element.get(property.name),\n            idx = collection.indexOf(r);\n\n        // we replace an existing place holder (idx != -1) or\n        // append to the collection instead\n        if (idx === -1) {\n          idx = collection.length;\n        }\n\n        if (!reference) {\n\n          // remove unresolvable reference\n          collection.splice(idx, 1);\n        } else {\n\n          // add or update reference in collection\n          collection[idx] = reference;\n        }\n      } else {\n        element.set(property.name, reference);\n      }\n    }\n  }\n\n  function handleClose() {\n    stack.pop().handleEnd();\n  }\n\n  var PREAMBLE_START_PATTERN = /^<\\?xml /i;\n\n  var ENCODING_PATTERN = / encoding=\"([^\"]+)\"/i;\n\n  var UTF_8_PATTERN = /^utf-8$/i;\n\n  function handleQuestion(question) {\n\n    if (!PREAMBLE_START_PATTERN.test(question)) {\n      return;\n    }\n\n    var match = ENCODING_PATTERN.exec(question);\n    var encoding = match && match[1];\n\n    if (!encoding || UTF_8_PATTERN.test(encoding)) {\n      return;\n    }\n\n    context.addWarning({\n      message:\n        'unsupported document encoding <' + encoding + '>, ' +\n        'falling back to UTF-8'\n    });\n  }\n\n  function handleOpen(node, getContext) {\n    var handler = stack.peek();\n\n    try {\n      stack.push(handler.handleNode(node));\n    } catch (err) {\n\n      if (handleError(err, getContext, lax)) {\n        stack.push(new NoopHandler());\n      }\n    }\n  }\n\n  function handleCData(text, getContext) {\n\n    try {\n      stack.peek().handleText(text);\n    } catch (err) {\n      handleWarning(err, getContext);\n    }\n  }\n\n  function handleText(text, getContext) {\n\n    // strip whitespace only nodes, i.e. before\n    // <!CDATA[ ... ]> sections and in between tags\n\n    if (!text.trim()) {\n      return;\n    }\n\n    handleCData(text, getContext);\n  }\n\n  var uriMap = model.getPackages().reduce(function(uriMap, p) {\n    uriMap[p.uri] = p.prefix;\n\n    return uriMap;\n  }, Object.entries(DEFAULT_NS_MAP).reduce(function(map, [ prefix, url ]) {\n    map[url] = prefix;\n\n    return map;\n  }, model.config && model.config.nsMap || {}));\n\n  parser\n    .ns(uriMap)\n    .on('openTag', function(obj, decodeStr, selfClosing, getContext) {\n\n      // gracefully handle unparsable attributes (attrs=false)\n      var attrs = obj.attrs || {};\n\n      var decodedAttrs = Object.keys(attrs).reduce(function(d, key) {\n        var value = decodeStr(attrs[key]);\n\n        d[key] = value;\n\n        return d;\n      }, {});\n\n      var node = {\n        name: obj.name,\n        originalName: obj.originalName,\n        attributes: decodedAttrs,\n        ns: obj.ns\n      };\n\n      handleOpen(node, getContext);\n    })\n    .on('question', handleQuestion)\n    .on('closeTag', handleClose)\n    .on('cdata', handleCData)\n    .on('text', function(text, decodeEntities, getContext) {\n      handleText(decodeEntities(text), getContext);\n    })\n    .on('error', handleError)\n    .on('warn', handleWarning);\n\n  // async XML parsing to make sure the execution environment\n  // (node or brower) is kept responsive and that certain optimization\n  // strategies can kick in.\n  return new Promise(function(resolve, reject) {\n\n    var err;\n\n    try {\n      parser.parse(xml);\n\n      resolveReferences();\n    } catch (e) {\n      err = e;\n    }\n\n    var rootElement = rootHandler.element;\n\n    if (!err && !rootElement) {\n      err = error('failed to parse document as <' + rootHandler.type.$descriptor.name + '>');\n    }\n\n    var warnings = context.warnings;\n    var references = context.references;\n    var elementsById = context.elementsById;\n\n    if (err) {\n      err.warnings = warnings;\n\n      return reject(err);\n    } else {\n      return resolve({\n        rootElement: rootElement,\n        elementsById: elementsById,\n        references: references,\n        warnings: warnings\n      });\n    }\n  });\n};\n\nReader.prototype.handler = function(name) {\n  return new RootElementHandler(this.model, name);\n};\n\n\n// helpers //////////////////////////\n\nfunction createStack() {\n  var stack = [];\n\n  Object.defineProperty(stack, 'peek', {\n    value: function() {\n      return this[this.length - 1];\n    }\n  });\n\n  return stack;\n}\n\nvar XML_PREAMBLE = '<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n';\n\nvar ESCAPE_ATTR_CHARS = /<|>|'|\"|&|\\n\\r|\\n/g;\nvar ESCAPE_CHARS = /<|>|&/g;\n\n\nfunction Namespaces(parent) {\n\n  this.prefixMap = {};\n  this.uriMap = {};\n  this.used = {};\n\n  this.wellknown = [];\n  this.custom = [];\n  this.parent = parent;\n\n  this.defaultPrefixMap = parent && parent.defaultPrefixMap || {};\n}\n\nNamespaces.prototype.mapDefaultPrefixes = function(defaultPrefixMap) {\n  this.defaultPrefixMap = defaultPrefixMap;\n};\n\nNamespaces.prototype.defaultUriByPrefix = function(prefix) {\n  return this.defaultPrefixMap[prefix];\n};\n\nNamespaces.prototype.byUri = function(uri) {\n  return this.uriMap[uri] || (\n    this.parent && this.parent.byUri(uri)\n  );\n};\n\nNamespaces.prototype.add = function(ns, isWellknown) {\n\n  this.uriMap[ns.uri] = ns;\n\n  if (isWellknown) {\n    this.wellknown.push(ns);\n  } else {\n    this.custom.push(ns);\n  }\n\n  this.mapPrefix(ns.prefix, ns.uri);\n};\n\nNamespaces.prototype.uriByPrefix = function(prefix) {\n  return this.prefixMap[prefix || 'xmlns'] || (\n    this.parent && this.parent.uriByPrefix(prefix)\n  );\n};\n\nNamespaces.prototype.mapPrefix = function(prefix, uri) {\n  this.prefixMap[prefix || 'xmlns'] = uri;\n};\n\nNamespaces.prototype.getNSKey = function(ns) {\n  return (ns.prefix !== undefined) ? (ns.uri + '|' + ns.prefix) : ns.uri;\n};\n\nNamespaces.prototype.logUsed = function(ns) {\n\n  var uri = ns.uri;\n  var nsKey = this.getNSKey(ns);\n\n  this.used[nsKey] = this.byUri(uri);\n\n  // Inform parent recursively about the usage of this NS\n  if (this.parent) {\n    this.parent.logUsed(ns);\n  }\n};\n\nNamespaces.prototype.getUsed = function(ns) {\n\n  var allNs = [].concat(this.wellknown, this.custom);\n\n  return allNs.filter(ns => {\n    var nsKey = this.getNSKey(ns);\n\n    return this.used[nsKey];\n  });\n};\n\n\nfunction lower(string) {\n  return string.charAt(0).toLowerCase() + string.slice(1);\n}\n\nfunction nameToAlias(name, pkg) {\n  if (hasLowerCaseAlias(pkg)) {\n    return lower(name);\n  } else {\n    return name;\n  }\n}\n\nfunction inherits(ctor, superCtor) {\n  ctor.super_ = superCtor;\n  ctor.prototype = Object.create(superCtor.prototype, {\n    constructor: {\n      value: ctor,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n}\n\nfunction nsName(ns) {\n  if ((0,min_dash__WEBPACK_IMPORTED_MODULE_2__.isString)(ns)) {\n    return ns;\n  } else {\n    return (ns.prefix ? ns.prefix + ':' : '') + ns.localName;\n  }\n}\n\nfunction getNsAttrs(namespaces) {\n\n  return namespaces.getUsed().filter(function(ns) {\n\n    // do not serialize built in <xml> namespace\n    return ns.prefix !== 'xml';\n  }).map(function(ns) {\n    var name = 'xmlns' + (ns.prefix ? ':' + ns.prefix : '');\n    return { name: name, value: ns.uri };\n  });\n\n}\n\nfunction getElementNs(ns, descriptor) {\n  if (descriptor.isGeneric) {\n    return (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.assign)({ localName: descriptor.ns.localName }, ns);\n  } else {\n    return (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.assign)({ localName: nameToAlias(descriptor.ns.localName, descriptor.$pkg) }, ns);\n  }\n}\n\nfunction getPropertyNs(ns, descriptor) {\n  return (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.assign)({ localName: descriptor.ns.localName }, ns);\n}\n\nfunction getSerializableProperties(element) {\n  var descriptor = element.$descriptor;\n\n  return (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.filter)(descriptor.properties, function(p) {\n    var name = p.name;\n\n    if (p.isVirtual) {\n      return false;\n    }\n\n    // do not serialize defaults\n    if (!(0,min_dash__WEBPACK_IMPORTED_MODULE_2__.has)(element, name)) {\n      return false;\n    }\n\n    var value = element[name];\n\n    // do not serialize default equals\n    if (value === p.default) {\n      return false;\n    }\n\n    // do not serialize null properties\n    if (value === null) {\n      return false;\n    }\n\n    return p.isMany ? value.length : true;\n  });\n}\n\nvar ESCAPE_ATTR_MAP = {\n  '\\n': '#10',\n  '\\n\\r': '#10',\n  '\"': '#34',\n  '\\'': '#39',\n  '<': '#60',\n  '>': '#62',\n  '&': '#38'\n};\n\nvar ESCAPE_MAP = {\n  '<': 'lt',\n  '>': 'gt',\n  '&': 'amp'\n};\n\nfunction escape(str, charPattern, replaceMap) {\n\n  // ensure we are handling strings here\n  str = (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.isString)(str) ? str : '' + str;\n\n  return str.replace(charPattern, function(s) {\n    return '&' + replaceMap[s] + ';';\n  });\n}\n\n/**\n * Escape a string attribute to not contain any bad values (line breaks, '\"', ...)\n *\n * @param {String} str the string to escape\n * @return {String} the escaped string\n */\nfunction escapeAttr(str) {\n  return escape(str, ESCAPE_ATTR_CHARS, ESCAPE_ATTR_MAP);\n}\n\nfunction escapeBody(str) {\n  return escape(str, ESCAPE_CHARS, ESCAPE_MAP);\n}\n\nfunction filterAttributes(props) {\n  return (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.filter)(props, function(p) { return p.isAttr; });\n}\n\nfunction filterContained(props) {\n  return (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.filter)(props, function(p) { return !p.isAttr; });\n}\n\n\nfunction ReferenceSerializer(tagName) {\n  this.tagName = tagName;\n}\n\nReferenceSerializer.prototype.build = function(element) {\n  this.element = element;\n  return this;\n};\n\nReferenceSerializer.prototype.serializeTo = function(writer) {\n  writer\n    .appendIndent()\n    .append('<' + this.tagName + '>' + this.element.id + '</' + this.tagName + '>')\n    .appendNewLine();\n};\n\nfunction BodySerializer() {}\n\nBodySerializer.prototype.serializeValue =\nBodySerializer.prototype.serializeTo = function(writer) {\n  writer.append(\n    this.escape\n      ? escapeBody(this.value)\n      : this.value\n  );\n};\n\nBodySerializer.prototype.build = function(prop, value) {\n  this.value = value;\n\n  if (prop.type === 'String' && value.search(ESCAPE_CHARS) !== -1) {\n    this.escape = true;\n  }\n\n  return this;\n};\n\nfunction ValueSerializer(tagName) {\n  this.tagName = tagName;\n}\n\ninherits(ValueSerializer, BodySerializer);\n\nValueSerializer.prototype.serializeTo = function(writer) {\n\n  writer\n    .appendIndent()\n    .append('<' + this.tagName + '>');\n\n  this.serializeValue(writer);\n\n  writer\n    .append('</' + this.tagName + '>')\n    .appendNewLine();\n};\n\nfunction ElementSerializer(parent, propertyDescriptor) {\n  this.body = [];\n  this.attrs = [];\n\n  this.parent = parent;\n  this.propertyDescriptor = propertyDescriptor;\n}\n\nElementSerializer.prototype.build = function(element) {\n  this.element = element;\n\n  var elementDescriptor = element.$descriptor,\n      propertyDescriptor = this.propertyDescriptor;\n\n  var otherAttrs,\n      properties;\n\n  var isGeneric = elementDescriptor.isGeneric;\n\n  if (isGeneric) {\n    otherAttrs = this.parseGenericNsAttributes(element);\n  } else {\n    otherAttrs = this.parseNsAttributes(element);\n  }\n\n  if (propertyDescriptor) {\n    this.ns = this.nsPropertyTagName(propertyDescriptor);\n  } else {\n    this.ns = this.nsTagName(elementDescriptor);\n  }\n\n  // compute tag name\n  this.tagName = this.addTagName(this.ns);\n\n  if (isGeneric) {\n    this.parseGenericContainments(element);\n  } else {\n    properties = getSerializableProperties(element);\n\n    this.parseAttributes(filterAttributes(properties));\n    this.parseContainments(filterContained(properties));\n  }\n\n  this.parseGenericAttributes(element, otherAttrs);\n\n  return this;\n};\n\nElementSerializer.prototype.nsTagName = function(descriptor) {\n  var effectiveNs = this.logNamespaceUsed(descriptor.ns);\n  return getElementNs(effectiveNs, descriptor);\n};\n\nElementSerializer.prototype.nsPropertyTagName = function(descriptor) {\n  var effectiveNs = this.logNamespaceUsed(descriptor.ns);\n  return getPropertyNs(effectiveNs, descriptor);\n};\n\nElementSerializer.prototype.isLocalNs = function(ns) {\n  return ns.uri === this.ns.uri;\n};\n\n/**\n * Get the actual ns attribute name for the given element.\n *\n * @param {Object} element\n * @param {Boolean} [element.inherited=false]\n *\n * @return {Object} nsName\n */\nElementSerializer.prototype.nsAttributeName = function(element) {\n\n  var ns;\n\n  if ((0,min_dash__WEBPACK_IMPORTED_MODULE_2__.isString)(element)) {\n    ns = (0,moddle__WEBPACK_IMPORTED_MODULE_1__.parseNameNS)(element);\n  } else {\n    ns = element.ns;\n  }\n\n  // return just local name for inherited attributes\n  if (element.inherited) {\n    return { localName: ns.localName };\n  }\n\n  // parse + log effective ns\n  var effectiveNs = this.logNamespaceUsed(ns);\n\n  // LOG ACTUAL namespace use\n  this.getNamespaces().logUsed(effectiveNs);\n\n  // strip prefix if same namespace like parent\n  if (this.isLocalNs(effectiveNs)) {\n    return { localName: ns.localName };\n  } else {\n    return (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.assign)({ localName: ns.localName }, effectiveNs);\n  }\n};\n\nElementSerializer.prototype.parseGenericNsAttributes = function(element) {\n\n  return Object.entries(element).filter(\n    ([ key, value ]) => !key.startsWith('$') && this.parseNsAttribute(element, key, value)\n  ).map(\n    ([ key, value ]) => ({ name: key, value: value })\n  );\n};\n\nElementSerializer.prototype.parseGenericContainments = function(element) {\n  var body = element.$body;\n\n  if (body) {\n    this.body.push(new BodySerializer().build({ type: 'String' }, body));\n  }\n\n  var children = element.$children;\n\n  if (children) {\n    (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.forEach)(children, child => {\n      this.body.push(new ElementSerializer(this).build(child));\n    });\n  }\n};\n\nElementSerializer.prototype.parseNsAttribute = function(element, name, value) {\n  var model = element.$model;\n\n  var nameNs = (0,moddle__WEBPACK_IMPORTED_MODULE_1__.parseNameNS)(name);\n\n  var ns;\n\n  // parse xmlns:foo=\"http://foo.bar\"\n  if (nameNs.prefix === 'xmlns') {\n    ns = { prefix: nameNs.localName, uri: value };\n  }\n\n  // parse xmlns=\"http://foo.bar\"\n  if (!nameNs.prefix && nameNs.localName === 'xmlns') {\n    ns = { uri: value };\n  }\n\n  if (!ns) {\n    return {\n      name: name,\n      value: value\n    };\n  }\n\n  if (model && model.getPackage(value)) {\n\n    // register well known namespace\n    this.logNamespace(ns, true, true);\n  } else {\n\n    // log custom namespace directly as used\n    var actualNs = this.logNamespaceUsed(ns, true);\n\n    this.getNamespaces().logUsed(actualNs);\n  }\n};\n\n\n/**\n * Parse namespaces and return a list of left over generic attributes\n *\n * @param  {Object} element\n * @return {Array<Object>}\n */\nElementSerializer.prototype.parseNsAttributes = function(element) {\n  var self = this;\n\n  var genericAttrs = element.$attrs;\n\n  var attributes = [];\n\n  // parse namespace attributes first\n  // and log them. push non namespace attributes to a list\n  // and process them later\n  (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.forEach)(genericAttrs, function(value, name) {\n\n    var nonNsAttr = self.parseNsAttribute(element, name, value);\n\n    if (nonNsAttr) {\n      attributes.push(nonNsAttr);\n    }\n  });\n\n  return attributes;\n};\n\nElementSerializer.prototype.parseGenericAttributes = function(element, attributes) {\n\n  var self = this;\n\n  (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.forEach)(attributes, function(attr) {\n\n    try {\n      self.addAttribute(self.nsAttributeName(attr.name), attr.value);\n    } catch (e) {\n\n      // eslint-disable-next-line no-undef\n      typeof console !== 'undefined' && console.warn(\n        `missing namespace information for <${\n          attr.name\n        }=${ attr.value }> on`, element, e\n      );\n    }\n  });\n};\n\nElementSerializer.prototype.parseContainments = function(properties) {\n\n  var self = this,\n      body = this.body,\n      element = this.element;\n\n  (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.forEach)(properties, function(p) {\n    var value = element.get(p.name),\n        isReference = p.isReference,\n        isMany = p.isMany;\n\n    if (!isMany) {\n      value = [ value ];\n    }\n\n    if (p.isBody) {\n      body.push(new BodySerializer().build(p, value[0]));\n    } else if ((0,moddle__WEBPACK_IMPORTED_MODULE_1__.isSimpleType)(p.type)) {\n      (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.forEach)(value, function(v) {\n        body.push(new ValueSerializer(self.addTagName(self.nsPropertyTagName(p))).build(p, v));\n      });\n    } else if (isReference) {\n      (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.forEach)(value, function(v) {\n        body.push(new ReferenceSerializer(self.addTagName(self.nsPropertyTagName(p))).build(v));\n      });\n    } else {\n\n      // allow serialization via type\n      // rather than element name\n      var serialization = getSerialization(p);\n\n      (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.forEach)(value, function(v) {\n        var serializer;\n\n        if (serialization) {\n          if (serialization === SERIALIZE_PROPERTY) {\n            serializer = new ElementSerializer(self, p);\n          } else {\n            serializer = new TypeSerializer(self, p, serialization);\n          }\n        } else {\n          serializer = new ElementSerializer(self);\n        }\n\n        body.push(serializer.build(v));\n      });\n    }\n  });\n};\n\nElementSerializer.prototype.getNamespaces = function(local) {\n\n  var namespaces = this.namespaces,\n      parent = this.parent,\n      parentNamespaces;\n\n  if (!namespaces) {\n    parentNamespaces = parent && parent.getNamespaces();\n\n    if (local || !parentNamespaces) {\n      this.namespaces = namespaces = new Namespaces(parentNamespaces);\n    } else {\n      namespaces = parentNamespaces;\n    }\n  }\n\n  return namespaces;\n};\n\nElementSerializer.prototype.logNamespace = function(ns, wellknown, local) {\n  var namespaces = this.getNamespaces(local);\n\n  var nsUri = ns.uri,\n      nsPrefix = ns.prefix;\n\n  var existing = namespaces.byUri(nsUri);\n\n  if (!existing || local) {\n    namespaces.add(ns, wellknown);\n  }\n\n  namespaces.mapPrefix(nsPrefix, nsUri);\n\n  return ns;\n};\n\nElementSerializer.prototype.logNamespaceUsed = function(ns, local) {\n  var namespaces = this.getNamespaces(local);\n\n  // ns may be\n  //\n  //   * prefix only\n  //   * prefix:uri\n  //   * localName only\n\n  var prefix = ns.prefix,\n      uri = ns.uri,\n      newPrefix, idx,\n      wellknownUri;\n\n  // handle anonymous namespaces (elementForm=unqualified), cf. #23\n  if (!prefix && !uri) {\n    return { localName: ns.localName };\n  }\n\n  wellknownUri = namespaces.defaultUriByPrefix(prefix);\n\n  uri = uri || wellknownUri || namespaces.uriByPrefix(prefix);\n\n  if (!uri) {\n    throw new Error('no namespace uri given for prefix <' + prefix + '>');\n  }\n\n  ns = namespaces.byUri(uri);\n\n  // register new default prefix <xmlns> in local scope\n  if (!ns && !prefix) {\n    ns = this.logNamespace({ uri }, wellknownUri === uri, true);\n  }\n\n  if (!ns) {\n    newPrefix = prefix;\n    idx = 1;\n\n    // find a prefix that is not mapped yet\n    while (namespaces.uriByPrefix(newPrefix)) {\n      newPrefix = prefix + '_' + idx++;\n    }\n\n    ns = this.logNamespace({ prefix: newPrefix, uri: uri }, wellknownUri === uri);\n  }\n\n  if (prefix) {\n    namespaces.mapPrefix(prefix, uri);\n  }\n\n  return ns;\n};\n\nElementSerializer.prototype.parseAttributes = function(properties) {\n  var self = this,\n      element = this.element;\n\n  (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.forEach)(properties, function(p) {\n\n    var value = element.get(p.name);\n\n    if (p.isReference) {\n\n      if (!p.isMany) {\n        value = value.id;\n      } else {\n        var values = [];\n        (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.forEach)(value, function(v) {\n          values.push(v.id);\n        });\n\n        // IDREFS is a whitespace-separated list of references.\n        value = values.join(' ');\n      }\n\n    }\n\n    self.addAttribute(self.nsAttributeName(p), value);\n  });\n};\n\nElementSerializer.prototype.addTagName = function(nsTagName) {\n  var actualNs = this.logNamespaceUsed(nsTagName);\n\n  this.getNamespaces().logUsed(actualNs);\n\n  return nsName(nsTagName);\n};\n\nElementSerializer.prototype.addAttribute = function(name, value) {\n  var attrs = this.attrs;\n\n  if ((0,min_dash__WEBPACK_IMPORTED_MODULE_2__.isString)(value)) {\n    value = escapeAttr(value);\n  }\n\n  // de-duplicate attributes\n  // https://github.com/bpmn-io/moddle-xml/issues/66\n  var idx = (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.findIndex)(attrs, function(element) {\n    return (\n      element.name.localName === name.localName &&\n      element.name.uri === name.uri &&\n      element.name.prefix === name.prefix\n    );\n  });\n\n  var attr = { name: name, value: value };\n\n  if (idx !== -1) {\n    attrs.splice(idx, 1, attr);\n  } else {\n    attrs.push(attr);\n  }\n};\n\nElementSerializer.prototype.serializeAttributes = function(writer) {\n  var attrs = this.attrs,\n      namespaces = this.namespaces;\n\n  if (namespaces) {\n    attrs = getNsAttrs(namespaces).concat(attrs);\n  }\n\n  (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.forEach)(attrs, function(a) {\n    writer\n      .append(' ')\n      .append(nsName(a.name)).append('=\"').append(a.value).append('\"');\n  });\n};\n\nElementSerializer.prototype.serializeTo = function(writer) {\n  var firstBody = this.body[0],\n      indent = firstBody && firstBody.constructor !== BodySerializer;\n\n  writer\n    .appendIndent()\n    .append('<' + this.tagName);\n\n  this.serializeAttributes(writer);\n\n  writer.append(firstBody ? '>' : ' />');\n\n  if (firstBody) {\n\n    if (indent) {\n      writer\n        .appendNewLine()\n        .indent();\n    }\n\n    (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.forEach)(this.body, function(b) {\n      b.serializeTo(writer);\n    });\n\n    if (indent) {\n      writer\n        .unindent()\n        .appendIndent();\n    }\n\n    writer.append('</' + this.tagName + '>');\n  }\n\n  writer.appendNewLine();\n};\n\n/**\n * A serializer for types that handles serialization of data types\n */\nfunction TypeSerializer(parent, propertyDescriptor, serialization) {\n  ElementSerializer.call(this, parent, propertyDescriptor);\n\n  this.serialization = serialization;\n}\n\ninherits(TypeSerializer, ElementSerializer);\n\nTypeSerializer.prototype.parseNsAttributes = function(element) {\n\n  // extracted attributes with serialization attribute\n  // <type=typeName> stripped; it may be later\n  var attributes = ElementSerializer.prototype.parseNsAttributes.call(this, element).filter(\n    attr => attr.name !== this.serialization\n  );\n\n  var descriptor = element.$descriptor;\n\n  // only serialize <type=typeName> if necessary\n  if (descriptor.name === this.propertyDescriptor.type) {\n    return attributes;\n  }\n\n  var typeNs = this.typeNs = this.nsTagName(descriptor);\n  this.getNamespaces().logUsed(this.typeNs);\n\n  // add xsi:type attribute to represent the elements\n  // actual type\n\n  var pkg = element.$model.getPackage(typeNs.uri),\n      typePrefix = (pkg.xml && pkg.xml.typePrefix) || '';\n\n  this.addAttribute(\n    this.nsAttributeName(this.serialization),\n    (typeNs.prefix ? typeNs.prefix + ':' : '') + typePrefix + descriptor.ns.localName\n  );\n\n  return attributes;\n};\n\nTypeSerializer.prototype.isLocalNs = function(ns) {\n  return ns.uri === (this.typeNs || this.ns).uri;\n};\n\nfunction SavingWriter() {\n  this.value = '';\n\n  this.write = function(str) {\n    this.value += str;\n  };\n}\n\nfunction FormatingWriter(out, format) {\n\n  var indent = [ '' ];\n\n  this.append = function(str) {\n    out.write(str);\n\n    return this;\n  };\n\n  this.appendNewLine = function() {\n    if (format) {\n      out.write('\\n');\n    }\n\n    return this;\n  };\n\n  this.appendIndent = function() {\n    if (format) {\n      out.write(indent.join('  '));\n    }\n\n    return this;\n  };\n\n  this.indent = function() {\n    indent.push('');\n    return this;\n  };\n\n  this.unindent = function() {\n    indent.pop();\n    return this;\n  };\n}\n\n/**\n * A writer for meta-model backed document trees\n *\n * @param {Object} options output options to pass into the writer\n */\nfunction Writer(options) {\n\n  options = (0,min_dash__WEBPACK_IMPORTED_MODULE_2__.assign)({ format: false, preamble: true }, options || {});\n\n  function toXML(tree, writer) {\n    var internalWriter = writer || new SavingWriter();\n    var formatingWriter = new FormatingWriter(internalWriter, options.format);\n\n    if (options.preamble) {\n      formatingWriter.append(XML_PREAMBLE);\n    }\n\n    var serializer = new ElementSerializer();\n\n    var model = tree.$model;\n\n    serializer.getNamespaces().mapDefaultPrefixes(getDefaultPrefixMappings(model));\n\n    serializer.build(tree).serializeTo(formatingWriter);\n\n    if (!writer) {\n      return internalWriter.value;\n    }\n  }\n\n  return {\n    toXML: toXML\n  };\n}\n\n\n// helpers ///////////\n\n/**\n * @param {Moddle} model\n *\n * @return { Record<string, string> } map from prefix to URI\n */\nfunction getDefaultPrefixMappings(model) {\n\n  const nsMap = model.config && model.config.nsMap || {};\n\n  const prefixMap = {};\n\n  // { prefix -> uri }\n  for (const prefix in DEFAULT_NS_MAP) {\n    prefixMap[prefix] = DEFAULT_NS_MAP[prefix];\n  }\n\n  // { uri -> prefix }\n  for (const uri in nsMap) {\n    const prefix = nsMap[uri];\n\n    prefixMap[prefix] = uri;\n  }\n\n  for (const pkg of model.getPackages()) {\n    prefixMap[pkg.prefix] = pkg.uri;\n  }\n\n  return prefixMap;\n}\n\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9kZGxlLXhtbC9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQW1GO0FBQ3BEO0FBQ3dDOztBQUV2RTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxpQkFBaUIsbURBQVc7O0FBRTVCLDZCQUE2Qix1Q0FBdUMsSUFBSSxrQkFBa0I7O0FBRTFGLDJCQUEyQixtREFBVzs7QUFFdEM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHdCQUF3QjtBQUNwQztBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLGdCQUFnQjtBQUMzQixXQUFXLFNBQVM7QUFDcEI7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQixnQkFBZ0I7QUFDaEM7O0FBRUE7QUFDQSxnQkFBZ0IsU0FBUztBQUN6Qjs7QUFFQSxFQUFFLGdEQUFNOztBQUVSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxlQUFlO0FBQzVCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNB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O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBLEdBQUcsMENBQTBDOztBQUU3QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsT0FBTyxJQUFJOztBQUVYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtB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Q0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7O0FBRUEsWUFBWSxnREFBTSxHQUFHLCtCQUErQixlQUFlOztBQUVuRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBLGFBQWEseUJBQXlCO0FBQ3RDO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUUwQjtBQUMxQiIsInNvdXJjZXMiOlsid2VicGFjazovL2JwbW4tc3R1ZGlvLXdlYi8uL25vZGVfbW9kdWxlcy9tb2RkbGUteG1sL2Rpc3QvaW5kZXguanM/NjFlZCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBmb3JFYWNoLCBhc3NpZ24sIGZpbmQsIGlzU3RyaW5nLCBmaW5kSW5kZXgsIGZpbHRlciwgaGFzIH0gZnJvbSAnbWluLWRhc2gnO1xuaW1wb3J0IHsgUGFyc2VyIH0gZnJvbSAnc2F4ZW4nO1xuaW1wb3J0IHsgY29lcmNlVHlwZSwgcGFyc2VOYW1lTlMsIGlzU2ltcGxlVHlwZSwgTW9kZGxlIH0gZnJvbSAnbW9kZGxlJztcblxuZnVuY3Rpb24gaGFzTG93ZXJDYXNlQWxpYXMocGtnKSB7XG4gIHJldHVybiBwa2cueG1sICYmIHBrZy54bWwudGFnQWxpYXMgPT09ICdsb3dlckNhc2UnO1xufVxuXG52YXIgREVGQVVMVF9OU19NQVAgPSB7XG4gICd4c2knOiAnaHR0cDovL3d3dy53My5vcmcvMjAwMS9YTUxTY2hlbWEtaW5zdGFuY2UnLFxuICAneG1sJzogJ2h0dHA6Ly93d3cudzMub3JnL1hNTC8xOTk4L25hbWVzcGFjZSdcbn07XG5cbnZhciBTRVJJQUxJWkVfUFJPUEVSVFkgPSAncHJvcGVydHknO1xuXG5mdW5jdGlvbiBnZXRTZXJpYWxpemF0aW9uKGVsZW1lbnQpIHtcbiAgcmV0dXJuIGVsZW1lbnQueG1sICYmIGVsZW1lbnQueG1sLnNlcmlhbGl6ZTtcbn1cblxuZnVuY3Rpb24gZ2V0U2VyaWFsaXphdGlvblR5cGUoZWxlbWVudCkge1xuICBjb25zdCB0eXBlID0gZ2V0U2VyaWFsaXphdGlvbihlbGVtZW50KTtcblxuICByZXR1cm4gdHlwZSAhPT0gU0VSSUFMSVpFX1BST1BFUlRZICYmICh0eXBlIHx8IG51bGwpO1xufVxuXG5mdW5jdGlvbiBjYXBpdGFsaXplKHN0cikge1xuICByZXR1cm4gc3RyLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyLnNsaWNlKDEpO1xufVxuXG5mdW5jdGlvbiBhbGlhc1RvTmFtZShhbGlhc05zLCBwa2cpIHtcblxuICBpZiAoIWhhc0xvd2VyQ2FzZUFsaWFzKHBrZykpIHtcbiAgICByZXR1cm4gYWxpYXNOcy5uYW1lO1xuICB9XG5cbiAgcmV0dXJuIGFsaWFzTnMucHJlZml4ICsgJzonICsgY2FwaXRhbGl6ZShhbGlhc05zLmxvY2FsTmFtZSk7XG59XG5cbi8qKlxuICogVW4tcHJlZml4IGEgcG90ZW50aWFsbHkgcHJlZml4ZWQgdHlwZSBuYW1lLlxuICpcbiAqIEBwYXJhbSB7TnNOYW1lfSBuYW1lTnNcbiAqIEBwYXJhbSB7T2JqZWN0fSBbcGtnXVxuICpcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gcHJlZml4ZWRUb05hbWUobmFtZU5zLCBwa2cpIHtcblxuICB2YXIgbmFtZSA9IG5hbWVOcy5uYW1lLFxuICAgICAgbG9jYWxOYW1lID0gbmFtZU5zLmxvY2FsTmFtZTtcblxuICB2YXIgdHlwZVByZWZpeCA9IHBrZyAmJiBwa2cueG1sICYmIHBrZy54bWwudHlwZVByZWZpeDtcblxuICBpZiAodHlwZVByZWZpeCAmJiBsb2NhbE5hbWUuaW5kZXhPZih0eXBlUHJlZml4KSA9PT0gMCkge1xuICAgIHJldHVybiBuYW1lTnMucHJlZml4ICsgJzonICsgbG9jYWxOYW1lLnNsaWNlKHR5cGVQcmVmaXgubGVuZ3RoKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmFtZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBub3JtYWxpemVUeXBlTmFtZShuYW1lLCBuc01hcCwgbW9kZWwpIHtcblxuICAvLyBub3JtYWxpemUgYWdhaW5zdCBhY3R1YWwgTlNcbiAgY29uc3QgbmFtZU5zID0gcGFyc2VOYW1lTlMobmFtZSwgbnNNYXAueG1sbnMpO1xuXG4gIGNvbnN0IG5vcm1hbGl6ZWROYW1lID0gYCR7IG5zTWFwW25hbWVOcy5wcmVmaXhdIHx8IG5hbWVOcy5wcmVmaXggfTokeyBuYW1lTnMubG9jYWxOYW1lIH1gO1xuXG4gIGNvbnN0IG5vcm1hbGl6ZWROYW1lTnMgPSBwYXJzZU5hbWVOUyhub3JtYWxpemVkTmFtZSk7XG5cbiAgLy8gZGV0ZXJtaW5lIGFjdHVhbCB0eXBlIG5hbWUsIGJhc2VkIG9uIHBhY2thZ2UtZGVmaW5lZCBwcmVmaXhcbiAgdmFyIHBrZyA9IG1vZGVsLmdldFBhY2thZ2Uobm9ybWFsaXplZE5hbWVOcy5wcmVmaXgpO1xuXG4gIHJldHVybiBwcmVmaXhlZFRvTmFtZShub3JtYWxpemVkTmFtZU5zLCBwa2cpO1xufVxuXG5mdW5jdGlvbiBlcnJvcihtZXNzYWdlKSB7XG4gIHJldHVybiBuZXcgRXJyb3IobWVzc2FnZSk7XG59XG5cbi8qKlxuICogR2V0IHRoZSBtb2RkbGUgZGVzY3JpcHRvciBmb3IgYSBnaXZlbiBpbnN0YW5jZSBvciB0eXBlLlxuICpcbiAqIEBwYXJhbSAge01vZGRsZUVsZW1lbnR8RnVuY3Rpb259IGVsZW1lbnRcbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9IHRoZSBtb2RkbGUgZGVzY3JpcHRvclxuICovXG5mdW5jdGlvbiBnZXRNb2RkbGVEZXNjcmlwdG9yKGVsZW1lbnQpIHtcbiAgcmV0dXJuIGVsZW1lbnQuJGRlc2NyaXB0b3I7XG59XG5cblxuLyoqXG4gKiBBIHBhcnNlIGNvbnRleHQuXG4gKlxuICogQGNsYXNzXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBwYXJhbSB7RWxlbWVudEhhbmRsZXJ9IG9wdGlvbnMucm9vdEhhbmRsZXIgdGhlIHJvb3QgaGFuZGxlciBmb3IgcGFyc2luZyBhIGRvY3VtZW50XG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmxheD1mYWxzZV0gd2hldGhlciBvciBub3QgdG8gaWdub3JlIGludmFsaWQgZWxlbWVudHNcbiAqL1xuZnVuY3Rpb24gQ29udGV4dChvcHRpb25zKSB7XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSB7RWxlbWVudEhhbmRsZXJ9IHJvb3RIYW5kbGVyXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IGxheFxuICAgKi9cblxuICBhc3NpZ24odGhpcywgb3B0aW9ucyk7XG5cbiAgdGhpcy5lbGVtZW50c0J5SWQgPSB7fTtcbiAgdGhpcy5yZWZlcmVuY2VzID0gW107XG4gIHRoaXMud2FybmluZ3MgPSBbXTtcblxuICAvKipcbiAgICogQWRkIGFuIHVucmVzb2x2ZWQgcmVmZXJlbmNlLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gcmVmZXJlbmNlXG4gICAqL1xuICB0aGlzLmFkZFJlZmVyZW5jZSA9IGZ1bmN0aW9uKHJlZmVyZW5jZSkge1xuICAgIHRoaXMucmVmZXJlbmNlcy5wdXNoKHJlZmVyZW5jZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEFkZCBhIHByb2Nlc3NlZCBlbGVtZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge01vZGRsZUVsZW1lbnR9IGVsZW1lbnRcbiAgICovXG4gIHRoaXMuYWRkRWxlbWVudCA9IGZ1bmN0aW9uKGVsZW1lbnQpIHtcblxuICAgIGlmICghZWxlbWVudCkge1xuICAgICAgdGhyb3cgZXJyb3IoJ2V4cGVjdGVkIGVsZW1lbnQnKTtcbiAgICB9XG5cbiAgICB2YXIgZWxlbWVudHNCeUlkID0gdGhpcy5lbGVtZW50c0J5SWQ7XG5cbiAgICB2YXIgZGVzY3JpcHRvciA9IGdldE1vZGRsZURlc2NyaXB0b3IoZWxlbWVudCk7XG5cbiAgICB2YXIgaWRQcm9wZXJ0eSA9IGRlc2NyaXB0b3IuaWRQcm9wZXJ0eSxcbiAgICAgICAgaWQ7XG5cbiAgICBpZiAoaWRQcm9wZXJ0eSkge1xuICAgICAgaWQgPSBlbGVtZW50LmdldChpZFByb3BlcnR5Lm5hbWUpO1xuXG4gICAgICBpZiAoaWQpIHtcblxuICAgICAgICAvLyBmb3IgUU5hbWUgdmFsaWRhdGlvbiBhcyBwZXIgaHR0cDovL3d3dy53My5vcmcvVFIvUkVDLXhtbC8jTlQtTmFtZUNoYXJcbiAgICAgICAgaWYgKCEvXihbYS16XVtcXHctLl0qOik/W2Etel9dW1xcdy0uXSokL2kudGVzdChpZCkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2lsbGVnYWwgSUQgPCcgKyBpZCArICc+Jyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZWxlbWVudHNCeUlkW2lkXSkge1xuICAgICAgICAgIHRocm93IGVycm9yKCdkdXBsaWNhdGUgSUQgPCcgKyBpZCArICc+Jyk7XG4gICAgICAgIH1cblxuICAgICAgICBlbGVtZW50c0J5SWRbaWRdID0gZWxlbWVudDtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEFkZCBhbiBpbXBvcnQgd2FybmluZy5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IHdhcm5pbmdcbiAgICogQHBhcmFtIHtTdHJpbmd9IHdhcm5pbmcubWVzc2FnZVxuICAgKiBAcGFyYW0ge0Vycm9yfSBbd2FybmluZy5lcnJvcl1cbiAgICovXG4gIHRoaXMuYWRkV2FybmluZyA9IGZ1bmN0aW9uKHdhcm5pbmcpIHtcbiAgICB0aGlzLndhcm5pbmdzLnB1c2god2FybmluZyk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIEJhc2VIYW5kbGVyKCkge31cblxuQmFzZUhhbmRsZXIucHJvdG90eXBlLmhhbmRsZUVuZCA9IGZ1bmN0aW9uKCkge307XG5CYXNlSGFuZGxlci5wcm90b3R5cGUuaGFuZGxlVGV4dCA9IGZ1bmN0aW9uKCkge307XG5CYXNlSGFuZGxlci5wcm90b3R5cGUuaGFuZGxlTm9kZSA9IGZ1bmN0aW9uKCkge307XG5cblxuLyoqXG4gKiBBIHNpbXBsZSBwYXNzIHRocm91Z2ggaGFuZGxlciB0aGF0IGRvZXMgbm90aGluZyBleGNlcHQgZm9yXG4gKiBpZ25vcmluZyBhbGwgaW5wdXQgaXQgcmVjZWl2ZXMuXG4gKlxuICogVGhpcyBpcyB1c2VkIHRvIGlnbm9yZSB1bmtub3duIGVsZW1lbnRzIGFuZFxuICogYXR0cmlidXRlcy5cbiAqL1xuZnVuY3Rpb24gTm9vcEhhbmRsZXIoKSB7IH1cblxuTm9vcEhhbmRsZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShCYXNlSGFuZGxlci5wcm90b3R5cGUpO1xuXG5Ob29wSGFuZGxlci5wcm90b3R5cGUuaGFuZGxlTm9kZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIEJvZHlIYW5kbGVyKCkge31cblxuQm9keUhhbmRsZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShCYXNlSGFuZGxlci5wcm90b3R5cGUpO1xuXG5Cb2R5SGFuZGxlci5wcm90b3R5cGUuaGFuZGxlVGV4dCA9IGZ1bmN0aW9uKHRleHQpIHtcbiAgdGhpcy5ib2R5ID0gKHRoaXMuYm9keSB8fCAnJykgKyB0ZXh0O1xufTtcblxuZnVuY3Rpb24gUmVmZXJlbmNlSGFuZGxlcihwcm9wZXJ0eSwgY29udGV4dCkge1xuICB0aGlzLnByb3BlcnR5ID0gcHJvcGVydHk7XG4gIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG59XG5cblJlZmVyZW5jZUhhbmRsZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShCb2R5SGFuZGxlci5wcm90b3R5cGUpO1xuXG5SZWZlcmVuY2VIYW5kbGVyLnByb3RvdHlwZS5oYW5kbGVOb2RlID0gZnVuY3Rpb24obm9kZSkge1xuXG4gIGlmICh0aGlzLmVsZW1lbnQpIHtcbiAgICB0aHJvdyBlcnJvcignZXhwZWN0ZWQgbm8gc3ViIG5vZGVzJyk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5lbGVtZW50ID0gdGhpcy5jcmVhdGVSZWZlcmVuY2Uobm9kZSk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cblJlZmVyZW5jZUhhbmRsZXIucHJvdG90eXBlLmhhbmRsZUVuZCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmVsZW1lbnQuaWQgPSB0aGlzLmJvZHk7XG59O1xuXG5SZWZlcmVuY2VIYW5kbGVyLnByb3RvdHlwZS5jcmVhdGVSZWZlcmVuY2UgPSBmdW5jdGlvbihub2RlKSB7XG4gIHJldHVybiB7XG4gICAgcHJvcGVydHk6IHRoaXMucHJvcGVydHkubnMubmFtZSxcbiAgICBpZDogJydcbiAgfTtcbn07XG5cbmZ1bmN0aW9uIFZhbHVlSGFuZGxlcihwcm9wZXJ0eURlc2MsIGVsZW1lbnQpIHtcbiAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgdGhpcy5wcm9wZXJ0eURlc2MgPSBwcm9wZXJ0eURlc2M7XG59XG5cblZhbHVlSGFuZGxlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEJvZHlIYW5kbGVyLnByb3RvdHlwZSk7XG5cblZhbHVlSGFuZGxlci5wcm90b3R5cGUuaGFuZGxlRW5kID0gZnVuY3Rpb24oKSB7XG5cbiAgdmFyIHZhbHVlID0gdGhpcy5ib2R5IHx8ICcnLFxuICAgICAgZWxlbWVudCA9IHRoaXMuZWxlbWVudCxcbiAgICAgIHByb3BlcnR5RGVzYyA9IHRoaXMucHJvcGVydHlEZXNjO1xuXG4gIHZhbHVlID0gY29lcmNlVHlwZShwcm9wZXJ0eURlc2MudHlwZSwgdmFsdWUpO1xuXG4gIGlmIChwcm9wZXJ0eURlc2MuaXNNYW55KSB7XG4gICAgZWxlbWVudC5nZXQocHJvcGVydHlEZXNjLm5hbWUpLnB1c2godmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIGVsZW1lbnQuc2V0KHByb3BlcnR5RGVzYy5uYW1lLCB2YWx1ZSk7XG4gIH1cbn07XG5cblxuZnVuY3Rpb24gQmFzZUVsZW1lbnRIYW5kbGVyKCkge31cblxuQmFzZUVsZW1lbnRIYW5kbGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQm9keUhhbmRsZXIucHJvdG90eXBlKTtcblxuQmFzZUVsZW1lbnRIYW5kbGVyLnByb3RvdHlwZS5oYW5kbGVOb2RlID0gZnVuY3Rpb24obm9kZSkge1xuICB2YXIgcGFyc2VyID0gdGhpcyxcbiAgICAgIGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQ7XG5cbiAgaWYgKCFlbGVtZW50KSB7XG4gICAgZWxlbWVudCA9IHRoaXMuZWxlbWVudCA9IHRoaXMuY3JlYXRlRWxlbWVudChub2RlKTtcblxuICAgIHRoaXMuY29udGV4dC5hZGRFbGVtZW50KGVsZW1lbnQpO1xuICB9IGVsc2Uge1xuICAgIHBhcnNlciA9IHRoaXMuaGFuZGxlQ2hpbGQobm9kZSk7XG4gIH1cblxuICByZXR1cm4gcGFyc2VyO1xufTtcblxuLyoqXG4gKiBAY2xhc3MgUmVhZGVyLkVsZW1lbnRIYW5kbGVyXG4gKlxuICovXG5mdW5jdGlvbiBFbGVtZW50SGFuZGxlcihtb2RlbCwgdHlwZU5hbWUsIGNvbnRleHQpIHtcbiAgdGhpcy5tb2RlbCA9IG1vZGVsO1xuICB0aGlzLnR5cGUgPSBtb2RlbC5nZXRUeXBlKHR5cGVOYW1lKTtcbiAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbn1cblxuRWxlbWVudEhhbmRsZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShCYXNlRWxlbWVudEhhbmRsZXIucHJvdG90eXBlKTtcblxuRWxlbWVudEhhbmRsZXIucHJvdG90eXBlLmFkZFJlZmVyZW5jZSA9IGZ1bmN0aW9uKHJlZmVyZW5jZSkge1xuICB0aGlzLmNvbnRleHQuYWRkUmVmZXJlbmNlKHJlZmVyZW5jZSk7XG59O1xuXG5FbGVtZW50SGFuZGxlci5wcm90b3R5cGUuaGFuZGxlVGV4dCA9IGZ1bmN0aW9uKHRleHQpIHtcblxuICB2YXIgZWxlbWVudCA9IHRoaXMuZWxlbWVudCxcbiAgICAgIGRlc2NyaXB0b3IgPSBnZXRNb2RkbGVEZXNjcmlwdG9yKGVsZW1lbnQpLFxuICAgICAgYm9keVByb3BlcnR5ID0gZGVzY3JpcHRvci5ib2R5UHJvcGVydHk7XG5cbiAgaWYgKCFib2R5UHJvcGVydHkpIHtcbiAgICB0aHJvdyBlcnJvcigndW5leHBlY3RlZCBib2R5IHRleHQgPCcgKyB0ZXh0ICsgJz4nKTtcbiAgfVxuXG4gIEJvZHlIYW5kbGVyLnByb3RvdHlwZS5oYW5kbGVUZXh0LmNhbGwodGhpcywgdGV4dCk7XG59O1xuXG5FbGVtZW50SGFuZGxlci5wcm90b3R5cGUuaGFuZGxlRW5kID0gZnVuY3Rpb24oKSB7XG5cbiAgdmFyIHZhbHVlID0gdGhpcy5ib2R5LFxuICAgICAgZWxlbWVudCA9IHRoaXMuZWxlbWVudCxcbiAgICAgIGRlc2NyaXB0b3IgPSBnZXRNb2RkbGVEZXNjcmlwdG9yKGVsZW1lbnQpLFxuICAgICAgYm9keVByb3BlcnR5ID0gZGVzY3JpcHRvci5ib2R5UHJvcGVydHk7XG5cbiAgaWYgKGJvZHlQcm9wZXJ0eSAmJiB2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFsdWUgPSBjb2VyY2VUeXBlKGJvZHlQcm9wZXJ0eS50eXBlLCB2YWx1ZSk7XG4gICAgZWxlbWVudC5zZXQoYm9keVByb3BlcnR5Lm5hbWUsIHZhbHVlKTtcbiAgfVxufTtcblxuLyoqXG4gKiBDcmVhdGUgYW4gaW5zdGFuY2Ugb2YgdGhlIG1vZGVsIGZyb20gdGhlIGdpdmVuIG5vZGUuXG4gKlxuICogQHBhcmFtICB7RWxlbWVudH0gbm9kZSB0aGUgeG1sIG5vZGVcbiAqL1xuRWxlbWVudEhhbmRsZXIucHJvdG90eXBlLmNyZWF0ZUVsZW1lbnQgPSBmdW5jdGlvbihub2RlKSB7XG4gIHZhciBhdHRyaWJ1dGVzID0gbm9kZS5hdHRyaWJ1dGVzLFxuICAgICAgVHlwZSA9IHRoaXMudHlwZSxcbiAgICAgIGRlc2NyaXB0b3IgPSBnZXRNb2RkbGVEZXNjcmlwdG9yKFR5cGUpLFxuICAgICAgY29udGV4dCA9IHRoaXMuY29udGV4dCxcbiAgICAgIGluc3RhbmNlID0gbmV3IFR5cGUoe30pLFxuICAgICAgbW9kZWwgPSB0aGlzLm1vZGVsLFxuICAgICAgcHJvcE5hbWVOcztcblxuICBmb3JFYWNoKGF0dHJpYnV0ZXMsIGZ1bmN0aW9uKHZhbHVlLCBuYW1lKSB7XG5cbiAgICB2YXIgcHJvcCA9IGRlc2NyaXB0b3IucHJvcGVydGllc0J5TmFtZVtuYW1lXSxcbiAgICAgICAgdmFsdWVzO1xuXG4gICAgaWYgKHByb3AgJiYgcHJvcC5pc1JlZmVyZW5jZSkge1xuXG4gICAgICBpZiAoIXByb3AuaXNNYW55KSB7XG4gICAgICAgIGNvbnRleHQuYWRkUmVmZXJlbmNlKHtcbiAgICAgICAgICBlbGVtZW50OiBpbnN0YW5jZSxcbiAgICAgICAgICBwcm9wZXJ0eTogcHJvcC5ucy5uYW1lLFxuICAgICAgICAgIGlkOiB2YWx1ZVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgLy8gSURSRUZTOiBwYXJzZSByZWZlcmVuY2VzIGFzIHdoaXRlc3BhY2Utc2VwYXJhdGVkIGxpc3RcbiAgICAgICAgdmFsdWVzID0gdmFsdWUuc3BsaXQoJyAnKTtcblxuICAgICAgICBmb3JFYWNoKHZhbHVlcywgZnVuY3Rpb24odikge1xuICAgICAgICAgIGNvbnRleHQuYWRkUmVmZXJlbmNlKHtcbiAgICAgICAgICAgIGVsZW1lbnQ6IGluc3RhbmNlLFxuICAgICAgICAgICAgcHJvcGVydHk6IHByb3AubnMubmFtZSxcbiAgICAgICAgICAgIGlkOiB2XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChwcm9wKSB7XG4gICAgICAgIHZhbHVlID0gY29lcmNlVHlwZShwcm9wLnR5cGUsIHZhbHVlKTtcbiAgICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gJ3htbG5zJykge1xuICAgICAgICBuYW1lID0gJzonICsgbmFtZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb3BOYW1lTnMgPSBwYXJzZU5hbWVOUyhuYW1lLCBkZXNjcmlwdG9yLm5zLnByZWZpeCk7XG5cbiAgICAgICAgLy8gY2hlY2sgd2hldGhlciBhdHRyaWJ1dGUgaXMgZGVmaW5lZCBpbiBhIHdlbGwta25vd24gbmFtZXNwYWNlXG4gICAgICAgIC8vIGlmIHRoYXQgaXMgdGhlIGNhc2Ugd2UgZW1pdCBhIHdhcm5pbmcgdG8gaW5kaWNhdGUgcG90ZW50aWFsIG1pc3VzZVxuICAgICAgICBpZiAobW9kZWwuZ2V0UGFja2FnZShwcm9wTmFtZU5zLnByZWZpeCkpIHtcblxuICAgICAgICAgIGNvbnRleHQuYWRkV2FybmluZyh7XG4gICAgICAgICAgICBtZXNzYWdlOiAndW5rbm93biBhdHRyaWJ1dGUgPCcgKyBuYW1lICsgJz4nLFxuICAgICAgICAgICAgZWxlbWVudDogaW5zdGFuY2UsXG4gICAgICAgICAgICBwcm9wZXJ0eTogbmFtZSxcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGluc3RhbmNlLnNldChuYW1lLCB2YWx1ZSk7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gaW5zdGFuY2U7XG59O1xuXG5FbGVtZW50SGFuZGxlci5wcm90b3R5cGUuZ2V0UHJvcGVydHlGb3JOb2RlID0gZnVuY3Rpb24obm9kZSkge1xuXG4gIHZhciBuYW1lID0gbm9kZS5uYW1lO1xuICB2YXIgbmFtZU5zID0gcGFyc2VOYW1lTlMobmFtZSk7XG5cbiAgdmFyIHR5cGUgPSB0aGlzLnR5cGUsXG4gICAgICBtb2RlbCA9IHRoaXMubW9kZWwsXG4gICAgICBkZXNjcmlwdG9yID0gZ2V0TW9kZGxlRGVzY3JpcHRvcih0eXBlKTtcblxuICB2YXIgcHJvcGVydHlOYW1lID0gbmFtZU5zLm5hbWUsXG4gICAgICBwcm9wZXJ0eSA9IGRlc2NyaXB0b3IucHJvcGVydGllc0J5TmFtZVtwcm9wZXJ0eU5hbWVdO1xuXG4gIC8vIHNlYXJjaCBmb3IgcHJvcGVydGllcyBieSBuYW1lIGZpcnN0XG5cbiAgaWYgKHByb3BlcnR5ICYmICFwcm9wZXJ0eS5pc0F0dHIpIHtcblxuICAgIGNvbnN0IHNlcmlhbGl6YXRpb25UeXBlID0gZ2V0U2VyaWFsaXphdGlvblR5cGUocHJvcGVydHkpO1xuXG4gICAgaWYgKHNlcmlhbGl6YXRpb25UeXBlKSB7XG4gICAgICBjb25zdCBlbGVtZW50VHlwZU5hbWUgPSBub2RlLmF0dHJpYnV0ZXNbc2VyaWFsaXphdGlvblR5cGVdO1xuXG4gICAgICAvLyB0eXBlIGlzIG9wdGlvbmFsLCBpZiBpdCBkb2VzIG5vdCBleGlzdHMgdGhlXG4gICAgICAvLyBkZWZhdWx0IHR5cGUgaXMgYXNzdW1lZFxuICAgICAgaWYgKGVsZW1lbnRUeXBlTmFtZSkge1xuXG4gICAgICAgIC8vIGNvbnZlcnQgdGhlIHByZWZpeCB1c2VkIHRvIHRoZSBtYXBwZWQgZm9ybSwgYnV0IGFsc29cbiAgICAgICAgLy8gdGFrZSBwb3NzaWJsZSB0eXBlIHByZWZpeGVzIGZyb20gWE1MXG4gICAgICAgIC8vIGludG8gYWNjb3VudCwgaS5lLjogeHNpOnR5cGU9XCJ0e0FjdHVhbFR5cGV9XCIsXG4gICAgICAgIGNvbnN0IG5vcm1hbGl6ZWRUeXBlTmFtZSA9IG5vcm1hbGl6ZVR5cGVOYW1lKGVsZW1lbnRUeXBlTmFtZSwgbm9kZS5ucywgbW9kZWwpO1xuXG4gICAgICAgIGNvbnN0IGVsZW1lbnRUeXBlID0gbW9kZWwuZ2V0VHlwZShub3JtYWxpemVkVHlwZU5hbWUpO1xuXG4gICAgICAgIHJldHVybiBhc3NpZ24oe30sIHByb3BlcnR5LCB7XG4gICAgICAgICAgZWZmZWN0aXZlVHlwZTogZ2V0TW9kZGxlRGVzY3JpcHRvcihlbGVtZW50VHlwZSkubmFtZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBzZWFyY2ggZm9yIHByb3BlcnRpZXMgYnkgbmFtZSBmaXJzdFxuICAgIHJldHVybiBwcm9wZXJ0eTtcbiAgfVxuXG4gIHZhciBwa2cgPSBtb2RlbC5nZXRQYWNrYWdlKG5hbWVOcy5wcmVmaXgpO1xuXG4gIGlmIChwa2cpIHtcbiAgICBjb25zdCBlbGVtZW50VHlwZU5hbWUgPSBhbGlhc1RvTmFtZShuYW1lTnMsIHBrZyk7XG4gICAgY29uc3QgZWxlbWVudFR5cGUgPSBtb2RlbC5nZXRUeXBlKGVsZW1lbnRUeXBlTmFtZSk7XG5cbiAgICAvLyBzZWFyY2ggZm9yIGNvbGxlY3Rpb24gbWVtYmVycyBsYXRlclxuICAgIHByb3BlcnR5ID0gZmluZChkZXNjcmlwdG9yLnByb3BlcnRpZXMsIGZ1bmN0aW9uKHApIHtcbiAgICAgIHJldHVybiAhcC5pc1ZpcnR1YWwgJiYgIXAuaXNSZWZlcmVuY2UgJiYgIXAuaXNBdHRyaWJ1dGUgJiYgZWxlbWVudFR5cGUuaGFzVHlwZShwLnR5cGUpO1xuICAgIH0pO1xuXG4gICAgaWYgKHByb3BlcnR5KSB7XG4gICAgICByZXR1cm4gYXNzaWduKHt9LCBwcm9wZXJ0eSwge1xuICAgICAgICBlZmZlY3RpdmVUeXBlOiBnZXRNb2RkbGVEZXNjcmlwdG9yKGVsZW1lbnRUeXBlKS5uYW1lXG4gICAgICB9KTtcbiAgICB9XG4gIH0gZWxzZSB7XG5cbiAgICAvLyBwYXJzZSB1bmtub3duIGVsZW1lbnQgKG1heWJlIGV4dGVuc2lvbilcbiAgICBwcm9wZXJ0eSA9IGZpbmQoZGVzY3JpcHRvci5wcm9wZXJ0aWVzLCBmdW5jdGlvbihwKSB7XG4gICAgICByZXR1cm4gIXAuaXNSZWZlcmVuY2UgJiYgIXAuaXNBdHRyaWJ1dGUgJiYgcC50eXBlID09PSAnRWxlbWVudCc7XG4gICAgfSk7XG5cbiAgICBpZiAocHJvcGVydHkpIHtcbiAgICAgIHJldHVybiBwcm9wZXJ0eTtcbiAgICB9XG4gIH1cblxuICB0aHJvdyBlcnJvcigndW5yZWNvZ25pemVkIGVsZW1lbnQgPCcgKyBuYW1lTnMubmFtZSArICc+Jyk7XG59O1xuXG5FbGVtZW50SGFuZGxlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuICdFbGVtZW50RGVzY3JpcHRvclsnICsgZ2V0TW9kZGxlRGVzY3JpcHRvcih0aGlzLnR5cGUpLm5hbWUgKyAnXSc7XG59O1xuXG5FbGVtZW50SGFuZGxlci5wcm90b3R5cGUudmFsdWVIYW5kbGVyID0gZnVuY3Rpb24ocHJvcGVydHlEZXNjLCBlbGVtZW50KSB7XG4gIHJldHVybiBuZXcgVmFsdWVIYW5kbGVyKHByb3BlcnR5RGVzYywgZWxlbWVudCk7XG59O1xuXG5FbGVtZW50SGFuZGxlci5wcm90b3R5cGUucmVmZXJlbmNlSGFuZGxlciA9IGZ1bmN0aW9uKHByb3BlcnR5RGVzYykge1xuICByZXR1cm4gbmV3IFJlZmVyZW5jZUhhbmRsZXIocHJvcGVydHlEZXNjLCB0aGlzLmNvbnRleHQpO1xufTtcblxuRWxlbWVudEhhbmRsZXIucHJvdG90eXBlLmhhbmRsZXIgPSBmdW5jdGlvbih0eXBlKSB7XG4gIGlmICh0eXBlID09PSAnRWxlbWVudCcpIHtcbiAgICByZXR1cm4gbmV3IEdlbmVyaWNFbGVtZW50SGFuZGxlcih0aGlzLm1vZGVsLCB0eXBlLCB0aGlzLmNvbnRleHQpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBuZXcgRWxlbWVudEhhbmRsZXIodGhpcy5tb2RlbCwgdHlwZSwgdGhpcy5jb250ZXh0KTtcbiAgfVxufTtcblxuLyoqXG4gKiBIYW5kbGUgdGhlIGNoaWxkIGVsZW1lbnQgcGFyc2luZ1xuICpcbiAqIEBwYXJhbSAge0VsZW1lbnR9IG5vZGUgdGhlIHhtbCBub2RlXG4gKi9cbkVsZW1lbnRIYW5kbGVyLnByb3RvdHlwZS5oYW5kbGVDaGlsZCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgdmFyIHByb3BlcnR5RGVzYywgdHlwZSwgZWxlbWVudCwgY2hpbGRIYW5kbGVyO1xuXG4gIHByb3BlcnR5RGVzYyA9IHRoaXMuZ2V0UHJvcGVydHlGb3JOb2RlKG5vZGUpO1xuICBlbGVtZW50ID0gdGhpcy5lbGVtZW50O1xuXG4gIHR5cGUgPSBwcm9wZXJ0eURlc2MuZWZmZWN0aXZlVHlwZSB8fCBwcm9wZXJ0eURlc2MudHlwZTtcblxuICBpZiAoaXNTaW1wbGVUeXBlKHR5cGUpKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWVIYW5kbGVyKHByb3BlcnR5RGVzYywgZWxlbWVudCk7XG4gIH1cblxuICBpZiAocHJvcGVydHlEZXNjLmlzUmVmZXJlbmNlKSB7XG4gICAgY2hpbGRIYW5kbGVyID0gdGhpcy5yZWZlcmVuY2VIYW5kbGVyKHByb3BlcnR5RGVzYykuaGFuZGxlTm9kZShub2RlKTtcbiAgfSBlbHNlIHtcbiAgICBjaGlsZEhhbmRsZXIgPSB0aGlzLmhhbmRsZXIodHlwZSkuaGFuZGxlTm9kZShub2RlKTtcbiAgfVxuXG4gIHZhciBuZXdFbGVtZW50ID0gY2hpbGRIYW5kbGVyLmVsZW1lbnQ7XG5cbiAgLy8gY2hpbGQgaGFuZGxlcyBtYXkgZGVjaWRlIHRvIHNraXAgZWxlbWVudHNcbiAgLy8gYnkgbm90IHJldHVybmluZyBhbnl0aGluZ1xuICBpZiAobmV3RWxlbWVudCAhPT0gdW5kZWZpbmVkKSB7XG5cbiAgICBpZiAocHJvcGVydHlEZXNjLmlzTWFueSkge1xuICAgICAgZWxlbWVudC5nZXQocHJvcGVydHlEZXNjLm5hbWUpLnB1c2gobmV3RWxlbWVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsZW1lbnQuc2V0KHByb3BlcnR5RGVzYy5uYW1lLCBuZXdFbGVtZW50KTtcbiAgICB9XG5cbiAgICBpZiAocHJvcGVydHlEZXNjLmlzUmVmZXJlbmNlKSB7XG4gICAgICBhc3NpZ24obmV3RWxlbWVudCwge1xuICAgICAgICBlbGVtZW50OiBlbGVtZW50XG4gICAgICB9KTtcblxuICAgICAgdGhpcy5jb250ZXh0LmFkZFJlZmVyZW5jZShuZXdFbGVtZW50KTtcbiAgICB9IGVsc2Uge1xuXG4gICAgICAvLyBlc3RhYmxpc2ggY2hpbGQgLT4gcGFyZW50IHJlbGF0aW9uc2hpcFxuICAgICAgbmV3RWxlbWVudC4kcGFyZW50ID0gZWxlbWVudDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gY2hpbGRIYW5kbGVyO1xufTtcblxuLyoqXG4gKiBBbiBlbGVtZW50IGhhbmRsZXIgdGhhdCBwZXJmb3JtcyBzcGVjaWFsIHZhbGlkYXRpb25cbiAqIHRvIGVuc3VyZSB0aGUgbm9kZSBpdCBnZXRzIGluaXRpYWxpemVkIHdpdGggbWF0Y2hlc1xuICogdGhlIGhhbmRsZXJzIHR5cGUgKG5hbWVzcGFjZSB3aXNlKS5cbiAqXG4gKiBAcGFyYW0ge01vZGRsZX0gbW9kZWxcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlTmFtZVxuICogQHBhcmFtIHtDb250ZXh0fSBjb250ZXh0XG4gKi9cbmZ1bmN0aW9uIFJvb3RFbGVtZW50SGFuZGxlcihtb2RlbCwgdHlwZU5hbWUsIGNvbnRleHQpIHtcbiAgRWxlbWVudEhhbmRsZXIuY2FsbCh0aGlzLCBtb2RlbCwgdHlwZU5hbWUsIGNvbnRleHQpO1xufVxuXG5Sb290RWxlbWVudEhhbmRsZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFbGVtZW50SGFuZGxlci5wcm90b3R5cGUpO1xuXG5Sb290RWxlbWVudEhhbmRsZXIucHJvdG90eXBlLmNyZWF0ZUVsZW1lbnQgPSBmdW5jdGlvbihub2RlKSB7XG5cbiAgdmFyIG5hbWUgPSBub2RlLm5hbWUsXG4gICAgICBuYW1lTnMgPSBwYXJzZU5hbWVOUyhuYW1lKSxcbiAgICAgIG1vZGVsID0gdGhpcy5tb2RlbCxcbiAgICAgIHR5cGUgPSB0aGlzLnR5cGUsXG4gICAgICBwa2cgPSBtb2RlbC5nZXRQYWNrYWdlKG5hbWVOcy5wcmVmaXgpLFxuICAgICAgdHlwZU5hbWUgPSBwa2cgJiYgYWxpYXNUb05hbWUobmFtZU5zLCBwa2cpIHx8IG5hbWU7XG5cbiAgLy8gdmVyaWZ5IHRoZSBjb3JyZWN0IG5hbWVzcGFjZSBpZiB3ZSBwYXJzZVxuICAvLyB0aGUgZmlyc3QgZWxlbWVudCBpbiB0aGUgaGFuZGxlciB0cmVlXG4gIC8vXG4gIC8vIHRoaXMgZW5zdXJlcyB3ZSBkb24ndCBtaXN0YWtlbmx5IGltcG9ydCB3cm9uZyBuYW1lc3BhY2UgZWxlbWVudHNcbiAgaWYgKCF0eXBlLmhhc1R5cGUodHlwZU5hbWUpKSB7XG4gICAgdGhyb3cgZXJyb3IoJ3VuZXhwZWN0ZWQgZWxlbWVudCA8JyArIG5vZGUub3JpZ2luYWxOYW1lICsgJz4nKTtcbiAgfVxuXG4gIHJldHVybiBFbGVtZW50SGFuZGxlci5wcm90b3R5cGUuY3JlYXRlRWxlbWVudC5jYWxsKHRoaXMsIG5vZGUpO1xufTtcblxuXG5mdW5jdGlvbiBHZW5lcmljRWxlbWVudEhhbmRsZXIobW9kZWwsIHR5cGVOYW1lLCBjb250ZXh0KSB7XG4gIHRoaXMubW9kZWwgPSBtb2RlbDtcbiAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbn1cblxuR2VuZXJpY0VsZW1lbnRIYW5kbGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQmFzZUVsZW1lbnRIYW5kbGVyLnByb3RvdHlwZSk7XG5cbkdlbmVyaWNFbGVtZW50SGFuZGxlci5wcm90b3R5cGUuY3JlYXRlRWxlbWVudCA9IGZ1bmN0aW9uKG5vZGUpIHtcblxuICB2YXIgbmFtZSA9IG5vZGUubmFtZSxcbiAgICAgIG5zID0gcGFyc2VOYW1lTlMobmFtZSksXG4gICAgICBwcmVmaXggPSBucy5wcmVmaXgsXG4gICAgICB1cmkgPSBub2RlLm5zW3ByZWZpeCArICckdXJpJ10sXG4gICAgICBhdHRyaWJ1dGVzID0gbm9kZS5hdHRyaWJ1dGVzO1xuXG4gIHJldHVybiB0aGlzLm1vZGVsLmNyZWF0ZUFueShuYW1lLCB1cmksIGF0dHJpYnV0ZXMpO1xufTtcblxuR2VuZXJpY0VsZW1lbnRIYW5kbGVyLnByb3RvdHlwZS5oYW5kbGVDaGlsZCA9IGZ1bmN0aW9uKG5vZGUpIHtcblxuICB2YXIgaGFuZGxlciA9IG5ldyBHZW5lcmljRWxlbWVudEhhbmRsZXIodGhpcy5tb2RlbCwgJ0VsZW1lbnQnLCB0aGlzLmNvbnRleHQpLmhhbmRsZU5vZGUobm9kZSksXG4gICAgICBlbGVtZW50ID0gdGhpcy5lbGVtZW50O1xuXG4gIHZhciBuZXdFbGVtZW50ID0gaGFuZGxlci5lbGVtZW50LFxuICAgICAgY2hpbGRyZW47XG5cbiAgaWYgKG5ld0VsZW1lbnQgIT09IHVuZGVmaW5lZCkge1xuICAgIGNoaWxkcmVuID0gZWxlbWVudC4kY2hpbGRyZW4gPSBlbGVtZW50LiRjaGlsZHJlbiB8fCBbXTtcbiAgICBjaGlsZHJlbi5wdXNoKG5ld0VsZW1lbnQpO1xuXG4gICAgLy8gZXN0YWJsaXNoIGNoaWxkIC0+IHBhcmVudCByZWxhdGlvbnNoaXBcbiAgICBuZXdFbGVtZW50LiRwYXJlbnQgPSBlbGVtZW50O1xuICB9XG5cbiAgcmV0dXJuIGhhbmRsZXI7XG59O1xuXG5HZW5lcmljRWxlbWVudEhhbmRsZXIucHJvdG90eXBlLmhhbmRsZUVuZCA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5ib2R5KSB7XG4gICAgdGhpcy5lbGVtZW50LiRib2R5ID0gdGhpcy5ib2R5O1xuICB9XG59O1xuXG4vKipcbiAqIEEgcmVhZGVyIGZvciBhIG1ldGEtbW9kZWxcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHBhcmFtIHtNb2RlbH0gb3B0aW9ucy5tb2RlbCB1c2VkIHRvIHJlYWQgeG1sIGZpbGVzXG4gKiBAcGFyYW0ge0Jvb2xlYW59IG9wdGlvbnMubGF4IHdoZXRoZXIgdG8gbWFrZSBwYXJzZSBlcnJvcnMgd2FybmluZ3NcbiAqL1xuZnVuY3Rpb24gUmVhZGVyKG9wdGlvbnMpIHtcblxuICBpZiAob3B0aW9ucyBpbnN0YW5jZW9mIE1vZGRsZSkge1xuICAgIG9wdGlvbnMgPSB7XG4gICAgICBtb2RlbDogb3B0aW9uc1xuICAgIH07XG4gIH1cblxuICBhc3NpZ24odGhpcywgeyBsYXg6IGZhbHNlIH0sIG9wdGlvbnMpO1xufVxuXG4vKipcbiAqIFRoZSBmcm9tWE1MIHJlc3VsdC5cbiAqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBQYXJzZVJlc3VsdFxuICpcbiAqIEBwcm9wZXJ0eSB7TW9kZGxlRWxlbWVudH0gcm9vdEVsZW1lbnRcbiAqIEBwcm9wZXJ0eSB7QXJyYXk8T2JqZWN0Pn0gcmVmZXJlbmNlc1xuICogQHByb3BlcnR5IHtBcnJheTxFcnJvcj59IHdhcm5pbmdzXG4gKiBAcHJvcGVydHkge09iamVjdH0gZWxlbWVudHNCeUlkIC0gYSBtYXBwaW5nIGNvbnRhaW5pbmcgZWFjaCBJRCAtPiBNb2RkbGVFbGVtZW50XG4gKi9cblxuLyoqXG4gKiBUaGUgZnJvbVhNTCByZXN1bHQuXG4gKlxuICogQHR5cGVkZWYge0Vycm9yfSBQYXJzZUVycm9yXG4gKlxuICogQHByb3BlcnR5IHtBcnJheTxFcnJvcj59IHdhcm5pbmdzXG4gKi9cblxuLyoqXG4gKiBQYXJzZSB0aGUgZ2l2ZW4gWE1MIGludG8gYSBtb2RkbGUgZG9jdW1lbnQgdHJlZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30geG1sXG4gKiBAcGFyYW0ge0VsZW1lbnRIYW5kbGVyfE9iamVjdH0gb3B0aW9ucyBvciByb290SGFuZGxlclxuICpcbiAqIEByZXR1cm5zIHtQcm9taXNlPFBhcnNlUmVzdWx0LCBQYXJzZUVycm9yPn1cbiAqL1xuUmVhZGVyLnByb3RvdHlwZS5mcm9tWE1MID0gZnVuY3Rpb24oeG1sLCBvcHRpb25zLCBkb25lKSB7XG5cbiAgdmFyIHJvb3RIYW5kbGVyID0gb3B0aW9ucy5yb290SGFuZGxlcjtcblxuICBpZiAob3B0aW9ucyBpbnN0YW5jZW9mIEVsZW1lbnRIYW5kbGVyKSB7XG5cbiAgICAvLyByb290IGhhbmRsZXIgcGFzc2VkIHZpYSAoeG1sLCB7IHJvb3RIYW5kbGVyOiBFbGVtZW50SGFuZGxlciB9LCAuLi4pXG4gICAgcm9vdEhhbmRsZXIgPSBvcHRpb25zO1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfSBlbHNlIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdzdHJpbmcnKSB7XG5cbiAgICAgIC8vIHJvb3RIYW5kbGVyIHBhc3NlZCB2aWEgKHhtbCwgJ3NvbWVTdHJpbmcnLCAuLi4pXG4gICAgICByb290SGFuZGxlciA9IHRoaXMuaGFuZGxlcihvcHRpb25zKTtcbiAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiByb290SGFuZGxlciA9PT0gJ3N0cmluZycpIHtcblxuICAgICAgLy8gcm9vdEhhbmRsZXIgcGFzc2VkIHZpYSAoeG1sLCB7IHJvb3RIYW5kbGVyOiAnc29tZVN0cmluZycgfSwgLi4uKVxuICAgICAgcm9vdEhhbmRsZXIgPSB0aGlzLmhhbmRsZXIocm9vdEhhbmRsZXIpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBtb2RlbCA9IHRoaXMubW9kZWwsXG4gICAgICBsYXggPSB0aGlzLmxheDtcblxuICB2YXIgY29udGV4dCA9IG5ldyBDb250ZXh0KGFzc2lnbih7fSwgb3B0aW9ucywgeyByb290SGFuZGxlcjogcm9vdEhhbmRsZXIgfSkpLFxuICAgICAgcGFyc2VyID0gbmV3IFBhcnNlcih7IHByb3h5OiB0cnVlIH0pLFxuICAgICAgc3RhY2sgPSBjcmVhdGVTdGFjaygpO1xuXG4gIHJvb3RIYW5kbGVyLmNvbnRleHQgPSBjb250ZXh0O1xuXG4gIC8vIHB1c2ggcm9vdCBoYW5kbGVyXG4gIHN0YWNrLnB1c2gocm9vdEhhbmRsZXIpO1xuXG5cbiAgLyoqXG4gICAqIEhhbmRsZSBlcnJvci5cbiAgICpcbiAgICogQHBhcmFtICB7RXJyb3J9IGVyclxuICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gZ2V0Q29udGV4dFxuICAgKiBAcGFyYW0gIHtib29sZWFufSBsYXhcbiAgICpcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZSBpZiBoYW5kbGVkXG4gICAqL1xuICBmdW5jdGlvbiBoYW5kbGVFcnJvcihlcnIsIGdldENvbnRleHQsIGxheCkge1xuXG4gICAgdmFyIGN0eCA9IGdldENvbnRleHQoKTtcblxuICAgIHZhciBsaW5lID0gY3R4LmxpbmUsXG4gICAgICAgIGNvbHVtbiA9IGN0eC5jb2x1bW4sXG4gICAgICAgIGRhdGEgPSBjdHguZGF0YTtcblxuICAgIC8vIHdlIHJlY2VpdmUgdGhlIGZ1bGwgY29udGV4dCBkYXRhIGhlcmUsXG4gICAgLy8gZm9yIGVsZW1lbnRzIHRyaW0gZG93biB0aGUgaW5mb3JtYXRpb25cbiAgICAvLyB0byB0aGUgdGFnIG5hbWUsIG9ubHlcbiAgICBpZiAoZGF0YS5jaGFyQXQoMCkgPT09ICc8JyAmJiBkYXRhLmluZGV4T2YoJyAnKSAhPT0gLTEpIHtcbiAgICAgIGRhdGEgPSBkYXRhLnNsaWNlKDAsIGRhdGEuaW5kZXhPZignICcpKSArICc+JztcbiAgICB9XG5cbiAgICB2YXIgbWVzc2FnZSA9XG4gICAgICAndW5wYXJzYWJsZSBjb250ZW50ICcgKyAoZGF0YSA/IGRhdGEgKyAnICcgOiAnJykgKyAnZGV0ZWN0ZWRcXG5cXHQnICtcbiAgICAgICAgJ2xpbmU6ICcgKyBsaW5lICsgJ1xcblxcdCcgK1xuICAgICAgICAnY29sdW1uOiAnICsgY29sdW1uICsgJ1xcblxcdCcgK1xuICAgICAgICAnbmVzdGVkIGVycm9yOiAnICsgZXJyLm1lc3NhZ2U7XG5cbiAgICBpZiAobGF4KSB7XG4gICAgICBjb250ZXh0LmFkZFdhcm5pbmcoe1xuICAgICAgICBtZXNzYWdlOiBtZXNzYWdlLFxuICAgICAgICBlcnJvcjogZXJyXG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IGVycm9yKG1lc3NhZ2UpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZVdhcm5pbmcoZXJyLCBnZXRDb250ZXh0KSB7XG5cbiAgICAvLyBqdXN0IGxpa2UgaGFuZGxpbmcgZXJyb3JzIGluIDxsYXg9dHJ1ZT4gbW9kZVxuICAgIHJldHVybiBoYW5kbGVFcnJvcihlcnIsIGdldENvbnRleHQsIHRydWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlc29sdmUgY29sbGVjdGVkIHJlZmVyZW5jZXMgb24gcGFyc2UgZW5kLlxuICAgKi9cbiAgZnVuY3Rpb24gcmVzb2x2ZVJlZmVyZW5jZXMoKSB7XG5cbiAgICB2YXIgZWxlbWVudHNCeUlkID0gY29udGV4dC5lbGVtZW50c0J5SWQ7XG4gICAgdmFyIHJlZmVyZW5jZXMgPSBjb250ZXh0LnJlZmVyZW5jZXM7XG5cbiAgICB2YXIgaSwgcjtcblxuICAgIGZvciAoaSA9IDA7IChyID0gcmVmZXJlbmNlc1tpXSk7IGkrKykge1xuICAgICAgdmFyIGVsZW1lbnQgPSByLmVsZW1lbnQ7XG4gICAgICB2YXIgcmVmZXJlbmNlID0gZWxlbWVudHNCeUlkW3IuaWRdO1xuICAgICAgdmFyIHByb3BlcnR5ID0gZ2V0TW9kZGxlRGVzY3JpcHRvcihlbGVtZW50KS5wcm9wZXJ0aWVzQnlOYW1lW3IucHJvcGVydHldO1xuXG4gICAgICBpZiAoIXJlZmVyZW5jZSkge1xuICAgICAgICBjb250ZXh0LmFkZFdhcm5pbmcoe1xuICAgICAgICAgIG1lc3NhZ2U6ICd1bnJlc29sdmVkIHJlZmVyZW5jZSA8JyArIHIuaWQgKyAnPicsXG4gICAgICAgICAgZWxlbWVudDogci5lbGVtZW50LFxuICAgICAgICAgIHByb3BlcnR5OiByLnByb3BlcnR5LFxuICAgICAgICAgIHZhbHVlOiByLmlkXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAocHJvcGVydHkuaXNNYW55KSB7XG4gICAgICAgIHZhciBjb2xsZWN0aW9uID0gZWxlbWVudC5nZXQocHJvcGVydHkubmFtZSksXG4gICAgICAgICAgICBpZHggPSBjb2xsZWN0aW9uLmluZGV4T2Yocik7XG5cbiAgICAgICAgLy8gd2UgcmVwbGFjZSBhbiBleGlzdGluZyBwbGFjZSBob2xkZXIgKGlkeCAhPSAtMSkgb3JcbiAgICAgICAgLy8gYXBwZW5kIHRvIHRoZSBjb2xsZWN0aW9uIGluc3RlYWRcbiAgICAgICAgaWYgKGlkeCA9PT0gLTEpIHtcbiAgICAgICAgICBpZHggPSBjb2xsZWN0aW9uLmxlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghcmVmZXJlbmNlKSB7XG5cbiAgICAgICAgICAvLyByZW1vdmUgdW5yZXNvbHZhYmxlIHJlZmVyZW5jZVxuICAgICAgICAgIGNvbGxlY3Rpb24uc3BsaWNlKGlkeCwgMSk7XG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAvLyBhZGQgb3IgdXBkYXRlIHJlZmVyZW5jZSBpbiBjb2xsZWN0aW9uXG4gICAgICAgICAgY29sbGVjdGlvbltpZHhdID0gcmVmZXJlbmNlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbGVtZW50LnNldChwcm9wZXJ0eS5uYW1lLCByZWZlcmVuY2UpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZUNsb3NlKCkge1xuICAgIHN0YWNrLnBvcCgpLmhhbmRsZUVuZCgpO1xuICB9XG5cbiAgdmFyIFBSRUFNQkxFX1NUQVJUX1BBVFRFUk4gPSAvXjxcXD94bWwgL2k7XG5cbiAgdmFyIEVOQ09ESU5HX1BBVFRFUk4gPSAvIGVuY29kaW5nPVwiKFteXCJdKylcIi9pO1xuXG4gIHZhciBVVEZfOF9QQVRURVJOID0gL151dGYtOCQvaTtcblxuICBmdW5jdGlvbiBoYW5kbGVRdWVzdGlvbihxdWVzdGlvbikge1xuXG4gICAgaWYgKCFQUkVBTUJMRV9TVEFSVF9QQVRURVJOLnRlc3QocXVlc3Rpb24pKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIG1hdGNoID0gRU5DT0RJTkdfUEFUVEVSTi5leGVjKHF1ZXN0aW9uKTtcbiAgICB2YXIgZW5jb2RpbmcgPSBtYXRjaCAmJiBtYXRjaFsxXTtcblxuICAgIGlmICghZW5jb2RpbmcgfHwgVVRGXzhfUEFUVEVSTi50ZXN0KGVuY29kaW5nKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnRleHQuYWRkV2FybmluZyh7XG4gICAgICBtZXNzYWdlOlxuICAgICAgICAndW5zdXBwb3J0ZWQgZG9jdW1lbnQgZW5jb2RpbmcgPCcgKyBlbmNvZGluZyArICc+LCAnICtcbiAgICAgICAgJ2ZhbGxpbmcgYmFjayB0byBVVEYtOCdcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZU9wZW4obm9kZSwgZ2V0Q29udGV4dCkge1xuICAgIHZhciBoYW5kbGVyID0gc3RhY2sucGVlaygpO1xuXG4gICAgdHJ5IHtcbiAgICAgIHN0YWNrLnB1c2goaGFuZGxlci5oYW5kbGVOb2RlKG5vZGUpKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcblxuICAgICAgaWYgKGhhbmRsZUVycm9yKGVyciwgZ2V0Q29udGV4dCwgbGF4KSkge1xuICAgICAgICBzdGFjay5wdXNoKG5ldyBOb29wSGFuZGxlcigpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVDRGF0YSh0ZXh0LCBnZXRDb250ZXh0KSB7XG5cbiAgICB0cnkge1xuICAgICAgc3RhY2sucGVlaygpLmhhbmRsZVRleHQodGV4dCk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBoYW5kbGVXYXJuaW5nKGVyciwgZ2V0Q29udGV4dCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlVGV4dCh0ZXh0LCBnZXRDb250ZXh0KSB7XG5cbiAgICAvLyBzdHJpcCB3aGl0ZXNwYWNlIG9ubHkgbm9kZXMsIGkuZS4gYmVmb3JlXG4gICAgLy8gPCFDREFUQVsgLi4uIF0+IHNlY3Rpb25zIGFuZCBpbiBiZXR3ZWVuIHRhZ3NcblxuICAgIGlmICghdGV4dC50cmltKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBoYW5kbGVDRGF0YSh0ZXh0LCBnZXRDb250ZXh0KTtcbiAgfVxuXG4gIHZhciB1cmlNYXAgPSBtb2RlbC5nZXRQYWNrYWdlcygpLnJlZHVjZShmdW5jdGlvbih1cmlNYXAsIHApIHtcbiAgICB1cmlNYXBbcC51cmldID0gcC5wcmVmaXg7XG5cbiAgICByZXR1cm4gdXJpTWFwO1xuICB9LCBPYmplY3QuZW50cmllcyhERUZBVUxUX05TX01BUCkucmVkdWNlKGZ1bmN0aW9uKG1hcCwgWyBwcmVmaXgsIHVybCBdKSB7XG4gICAgbWFwW3VybF0gPSBwcmVmaXg7XG5cbiAgICByZXR1cm4gbWFwO1xuICB9LCBtb2RlbC5jb25maWcgJiYgbW9kZWwuY29uZmlnLm5zTWFwIHx8IHt9KSk7XG5cbiAgcGFyc2VyXG4gICAgLm5zKHVyaU1hcClcbiAgICAub24oJ29wZW5UYWcnLCBmdW5jdGlvbihvYmosIGRlY29kZVN0ciwgc2VsZkNsb3NpbmcsIGdldENvbnRleHQpIHtcblxuICAgICAgLy8gZ3JhY2VmdWxseSBoYW5kbGUgdW5wYXJzYWJsZSBhdHRyaWJ1dGVzIChhdHRycz1mYWxzZSlcbiAgICAgIHZhciBhdHRycyA9IG9iai5hdHRycyB8fCB7fTtcblxuICAgICAgdmFyIGRlY29kZWRBdHRycyA9IE9iamVjdC5rZXlzKGF0dHJzKS5yZWR1Y2UoZnVuY3Rpb24oZCwga2V5KSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGRlY29kZVN0cihhdHRyc1trZXldKTtcblxuICAgICAgICBkW2tleV0gPSB2YWx1ZTtcblxuICAgICAgICByZXR1cm4gZDtcbiAgICAgIH0sIHt9KTtcblxuICAgICAgdmFyIG5vZGUgPSB7XG4gICAgICAgIG5hbWU6IG9iai5uYW1lLFxuICAgICAgICBvcmlnaW5hbE5hbWU6IG9iai5vcmlnaW5hbE5hbWUsXG4gICAgICAgIGF0dHJpYnV0ZXM6IGRlY29kZWRBdHRycyxcbiAgICAgICAgbnM6IG9iai5uc1xuICAgICAgfTtcblxuICAgICAgaGFuZGxlT3Blbihub2RlLCBnZXRDb250ZXh0KTtcbiAgICB9KVxuICAgIC5vbigncXVlc3Rpb24nLCBoYW5kbGVRdWVzdGlvbilcbiAgICAub24oJ2Nsb3NlVGFnJywgaGFuZGxlQ2xvc2UpXG4gICAgLm9uKCdjZGF0YScsIGhhbmRsZUNEYXRhKVxuICAgIC5vbigndGV4dCcsIGZ1bmN0aW9uKHRleHQsIGRlY29kZUVudGl0aWVzLCBnZXRDb250ZXh0KSB7XG4gICAgICBoYW5kbGVUZXh0KGRlY29kZUVudGl0aWVzKHRleHQpLCBnZXRDb250ZXh0KTtcbiAgICB9KVxuICAgIC5vbignZXJyb3InLCBoYW5kbGVFcnJvcilcbiAgICAub24oJ3dhcm4nLCBoYW5kbGVXYXJuaW5nKTtcblxuICAvLyBhc3luYyBYTUwgcGFyc2luZyB0byBtYWtlIHN1cmUgdGhlIGV4ZWN1dGlvbiBlbnZpcm9ubWVudFxuICAvLyAobm9kZSBvciBicm93ZXIpIGlzIGtlcHQgcmVzcG9uc2l2ZSBhbmQgdGhhdCBjZXJ0YWluIG9wdGltaXphdGlvblxuICAvLyBzdHJhdGVnaWVzIGNhbiBraWNrIGluLlxuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG5cbiAgICB2YXIgZXJyO1xuXG4gICAgdHJ5IHtcbiAgICAgIHBhcnNlci5wYXJzZSh4bWwpO1xuXG4gICAgICByZXNvbHZlUmVmZXJlbmNlcygpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGVyciA9IGU7XG4gICAgfVxuXG4gICAgdmFyIHJvb3RFbGVtZW50ID0gcm9vdEhhbmRsZXIuZWxlbWVudDtcblxuICAgIGlmICghZXJyICYmICFyb290RWxlbWVudCkge1xuICAgICAgZXJyID0gZXJyb3IoJ2ZhaWxlZCB0byBwYXJzZSBkb2N1bWVudCBhcyA8JyArIHJvb3RIYW5kbGVyLnR5cGUuJGRlc2NyaXB0b3IubmFtZSArICc+Jyk7XG4gICAgfVxuXG4gICAgdmFyIHdhcm5pbmdzID0gY29udGV4dC53YXJuaW5ncztcbiAgICB2YXIgcmVmZXJlbmNlcyA9IGNvbnRleHQucmVmZXJlbmNlcztcbiAgICB2YXIgZWxlbWVudHNCeUlkID0gY29udGV4dC5lbGVtZW50c0J5SWQ7XG5cbiAgICBpZiAoZXJyKSB7XG4gICAgICBlcnIud2FybmluZ3MgPSB3YXJuaW5ncztcblxuICAgICAgcmV0dXJuIHJlamVjdChlcnIpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcmVzb2x2ZSh7XG4gICAgICAgIHJvb3RFbGVtZW50OiByb290RWxlbWVudCxcbiAgICAgICAgZWxlbWVudHNCeUlkOiBlbGVtZW50c0J5SWQsXG4gICAgICAgIHJlZmVyZW5jZXM6IHJlZmVyZW5jZXMsXG4gICAgICAgIHdhcm5pbmdzOiB3YXJuaW5nc1xuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbn07XG5cblJlYWRlci5wcm90b3R5cGUuaGFuZGxlciA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgcmV0dXJuIG5ldyBSb290RWxlbWVudEhhbmRsZXIodGhpcy5tb2RlbCwgbmFtZSk7XG59O1xuXG5cbi8vIGhlbHBlcnMgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuZnVuY3Rpb24gY3JlYXRlU3RhY2soKSB7XG4gIHZhciBzdGFjayA9IFtdO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzdGFjaywgJ3BlZWsnLCB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXNbdGhpcy5sZW5ndGggLSAxXTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBzdGFjaztcbn1cblxudmFyIFhNTF9QUkVBTUJMRSA9ICc8P3htbCB2ZXJzaW9uPVwiMS4wXCIgZW5jb2Rpbmc9XCJVVEYtOFwiPz5cXG4nO1xuXG52YXIgRVNDQVBFX0FUVFJfQ0hBUlMgPSAvPHw+fCd8XCJ8JnxcXG5cXHJ8XFxuL2c7XG52YXIgRVNDQVBFX0NIQVJTID0gLzx8PnwmL2c7XG5cblxuZnVuY3Rpb24gTmFtZXNwYWNlcyhwYXJlbnQpIHtcblxuICB0aGlzLnByZWZpeE1hcCA9IHt9O1xuICB0aGlzLnVyaU1hcCA9IHt9O1xuICB0aGlzLnVzZWQgPSB7fTtcblxuICB0aGlzLndlbGxrbm93biA9IFtdO1xuICB0aGlzLmN1c3RvbSA9IFtdO1xuICB0aGlzLnBhcmVudCA9IHBhcmVudDtcblxuICB0aGlzLmRlZmF1bHRQcmVmaXhNYXAgPSBwYXJlbnQgJiYgcGFyZW50LmRlZmF1bHRQcmVmaXhNYXAgfHwge307XG59XG5cbk5hbWVzcGFjZXMucHJvdG90eXBlLm1hcERlZmF1bHRQcmVmaXhlcyA9IGZ1bmN0aW9uKGRlZmF1bHRQcmVmaXhNYXApIHtcbiAgdGhpcy5kZWZhdWx0UHJlZml4TWFwID0gZGVmYXVsdFByZWZpeE1hcDtcbn07XG5cbk5hbWVzcGFjZXMucHJvdG90eXBlLmRlZmF1bHRVcmlCeVByZWZpeCA9IGZ1bmN0aW9uKHByZWZpeCkge1xuICByZXR1cm4gdGhpcy5kZWZhdWx0UHJlZml4TWFwW3ByZWZpeF07XG59O1xuXG5OYW1lc3BhY2VzLnByb3RvdHlwZS5ieVVyaSA9IGZ1bmN0aW9uKHVyaSkge1xuICByZXR1cm4gdGhpcy51cmlNYXBbdXJpXSB8fCAoXG4gICAgdGhpcy5wYXJlbnQgJiYgdGhpcy5wYXJlbnQuYnlVcmkodXJpKVxuICApO1xufTtcblxuTmFtZXNwYWNlcy5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24obnMsIGlzV2VsbGtub3duKSB7XG5cbiAgdGhpcy51cmlNYXBbbnMudXJpXSA9IG5zO1xuXG4gIGlmIChpc1dlbGxrbm93bikge1xuICAgIHRoaXMud2VsbGtub3duLnB1c2gobnMpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuY3VzdG9tLnB1c2gobnMpO1xuICB9XG5cbiAgdGhpcy5tYXBQcmVmaXgobnMucHJlZml4LCBucy51cmkpO1xufTtcblxuTmFtZXNwYWNlcy5wcm90b3R5cGUudXJpQnlQcmVmaXggPSBmdW5jdGlvbihwcmVmaXgpIHtcbiAgcmV0dXJuIHRoaXMucHJlZml4TWFwW3ByZWZpeCB8fCAneG1sbnMnXSB8fCAoXG4gICAgdGhpcy5wYXJlbnQgJiYgdGhpcy5wYXJlbnQudXJpQnlQcmVmaXgocHJlZml4KVxuICApO1xufTtcblxuTmFtZXNwYWNlcy5wcm90b3R5cGUubWFwUHJlZml4ID0gZnVuY3Rpb24ocHJlZml4LCB1cmkpIHtcbiAgdGhpcy5wcmVmaXhNYXBbcHJlZml4IHx8ICd4bWxucyddID0gdXJpO1xufTtcblxuTmFtZXNwYWNlcy5wcm90b3R5cGUuZ2V0TlNLZXkgPSBmdW5jdGlvbihucykge1xuICByZXR1cm4gKG5zLnByZWZpeCAhPT0gdW5kZWZpbmVkKSA/IChucy51cmkgKyAnfCcgKyBucy5wcmVmaXgpIDogbnMudXJpO1xufTtcblxuTmFtZXNwYWNlcy5wcm90b3R5cGUubG9nVXNlZCA9IGZ1bmN0aW9uKG5zKSB7XG5cbiAgdmFyIHVyaSA9IG5zLnVyaTtcbiAgdmFyIG5zS2V5ID0gdGhpcy5nZXROU0tleShucyk7XG5cbiAgdGhpcy51c2VkW25zS2V5XSA9IHRoaXMuYnlVcmkodXJpKTtcblxuICAvLyBJbmZvcm0gcGFyZW50IHJlY3Vyc2l2ZWx5IGFib3V0IHRoZSB1c2FnZSBvZiB0aGlzIE5TXG4gIGlmICh0aGlzLnBhcmVudCkge1xuICAgIHRoaXMucGFyZW50LmxvZ1VzZWQobnMpO1xuICB9XG59O1xuXG5OYW1lc3BhY2VzLnByb3RvdHlwZS5nZXRVc2VkID0gZnVuY3Rpb24obnMpIHtcblxuICB2YXIgYWxsTnMgPSBbXS5jb25jYXQodGhpcy53ZWxsa25vd24sIHRoaXMuY3VzdG9tKTtcblxuICByZXR1cm4gYWxsTnMuZmlsdGVyKG5zID0+IHtcbiAgICB2YXIgbnNLZXkgPSB0aGlzLmdldE5TS2V5KG5zKTtcblxuICAgIHJldHVybiB0aGlzLnVzZWRbbnNLZXldO1xuICB9KTtcbn07XG5cblxuZnVuY3Rpb24gbG93ZXIoc3RyaW5nKSB7XG4gIHJldHVybiBzdHJpbmcuY2hhckF0KDApLnRvTG93ZXJDYXNlKCkgKyBzdHJpbmcuc2xpY2UoMSk7XG59XG5cbmZ1bmN0aW9uIG5hbWVUb0FsaWFzKG5hbWUsIHBrZykge1xuICBpZiAoaGFzTG93ZXJDYXNlQWxpYXMocGtnKSkge1xuICAgIHJldHVybiBsb3dlcihuYW1lKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmFtZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3I7XG4gIGN0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckN0b3IucHJvdG90eXBlLCB7XG4gICAgY29uc3RydWN0b3I6IHtcbiAgICAgIHZhbHVlOiBjdG9yLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIG5zTmFtZShucykge1xuICBpZiAoaXNTdHJpbmcobnMpKSB7XG4gICAgcmV0dXJuIG5zO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAobnMucHJlZml4ID8gbnMucHJlZml4ICsgJzonIDogJycpICsgbnMubG9jYWxOYW1lO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldE5zQXR0cnMobmFtZXNwYWNlcykge1xuXG4gIHJldHVybiBuYW1lc3BhY2VzLmdldFVzZWQoKS5maWx0ZXIoZnVuY3Rpb24obnMpIHtcblxuICAgIC8vIGRvIG5vdCBzZXJpYWxpemUgYnVpbHQgaW4gPHhtbD4gbmFtZXNwYWNlXG4gICAgcmV0dXJuIG5zLnByZWZpeCAhPT0gJ3htbCc7XG4gIH0pLm1hcChmdW5jdGlvbihucykge1xuICAgIHZhciBuYW1lID0gJ3htbG5zJyArIChucy5wcmVmaXggPyAnOicgKyBucy5wcmVmaXggOiAnJyk7XG4gICAgcmV0dXJuIHsgbmFtZTogbmFtZSwgdmFsdWU6IG5zLnVyaSB9O1xuICB9KTtcblxufVxuXG5mdW5jdGlvbiBnZXRFbGVtZW50TnMobnMsIGRlc2NyaXB0b3IpIHtcbiAgaWYgKGRlc2NyaXB0b3IuaXNHZW5lcmljKSB7XG4gICAgcmV0dXJuIGFzc2lnbih7IGxvY2FsTmFtZTogZGVzY3JpcHRvci5ucy5sb2NhbE5hbWUgfSwgbnMpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBhc3NpZ24oeyBsb2NhbE5hbWU6IG5hbWVUb0FsaWFzKGRlc2NyaXB0b3IubnMubG9jYWxOYW1lLCBkZXNjcmlwdG9yLiRwa2cpIH0sIG5zKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRQcm9wZXJ0eU5zKG5zLCBkZXNjcmlwdG9yKSB7XG4gIHJldHVybiBhc3NpZ24oeyBsb2NhbE5hbWU6IGRlc2NyaXB0b3IubnMubG9jYWxOYW1lIH0sIG5zKTtcbn1cblxuZnVuY3Rpb24gZ2V0U2VyaWFsaXphYmxlUHJvcGVydGllcyhlbGVtZW50KSB7XG4gIHZhciBkZXNjcmlwdG9yID0gZWxlbWVudC4kZGVzY3JpcHRvcjtcblxuICByZXR1cm4gZmlsdGVyKGRlc2NyaXB0b3IucHJvcGVydGllcywgZnVuY3Rpb24ocCkge1xuICAgIHZhciBuYW1lID0gcC5uYW1lO1xuXG4gICAgaWYgKHAuaXNWaXJ0dWFsKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gZG8gbm90IHNlcmlhbGl6ZSBkZWZhdWx0c1xuICAgIGlmICghaGFzKGVsZW1lbnQsIG5hbWUpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIHZhbHVlID0gZWxlbWVudFtuYW1lXTtcblxuICAgIC8vIGRvIG5vdCBzZXJpYWxpemUgZGVmYXVsdCBlcXVhbHNcbiAgICBpZiAodmFsdWUgPT09IHAuZGVmYXVsdCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIGRvIG5vdCBzZXJpYWxpemUgbnVsbCBwcm9wZXJ0aWVzXG4gICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHAuaXNNYW55ID8gdmFsdWUubGVuZ3RoIDogdHJ1ZTtcbiAgfSk7XG59XG5cbnZhciBFU0NBUEVfQVRUUl9NQVAgPSB7XG4gICdcXG4nOiAnIzEwJyxcbiAgJ1xcblxccic6ICcjMTAnLFxuICAnXCInOiAnIzM0JyxcbiAgJ1xcJyc6ICcjMzknLFxuICAnPCc6ICcjNjAnLFxuICAnPic6ICcjNjInLFxuICAnJic6ICcjMzgnXG59O1xuXG52YXIgRVNDQVBFX01BUCA9IHtcbiAgJzwnOiAnbHQnLFxuICAnPic6ICdndCcsXG4gICcmJzogJ2FtcCdcbn07XG5cbmZ1bmN0aW9uIGVzY2FwZShzdHIsIGNoYXJQYXR0ZXJuLCByZXBsYWNlTWFwKSB7XG5cbiAgLy8gZW5zdXJlIHdlIGFyZSBoYW5kbGluZyBzdHJpbmdzIGhlcmVcbiAgc3RyID0gaXNTdHJpbmcoc3RyKSA/IHN0ciA6ICcnICsgc3RyO1xuXG4gIHJldHVybiBzdHIucmVwbGFjZShjaGFyUGF0dGVybiwgZnVuY3Rpb24ocykge1xuICAgIHJldHVybiAnJicgKyByZXBsYWNlTWFwW3NdICsgJzsnO1xuICB9KTtcbn1cblxuLyoqXG4gKiBFc2NhcGUgYSBzdHJpbmcgYXR0cmlidXRlIHRvIG5vdCBjb250YWluIGFueSBiYWQgdmFsdWVzIChsaW5lIGJyZWFrcywgJ1wiJywgLi4uKVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgdGhlIHN0cmluZyB0byBlc2NhcGVcbiAqIEByZXR1cm4ge1N0cmluZ30gdGhlIGVzY2FwZWQgc3RyaW5nXG4gKi9cbmZ1bmN0aW9uIGVzY2FwZUF0dHIoc3RyKSB7XG4gIHJldHVybiBlc2NhcGUoc3RyLCBFU0NBUEVfQVRUUl9DSEFSUywgRVNDQVBFX0FUVFJfTUFQKTtcbn1cblxuZnVuY3Rpb24gZXNjYXBlQm9keShzdHIpIHtcbiAgcmV0dXJuIGVzY2FwZShzdHIsIEVTQ0FQRV9DSEFSUywgRVNDQVBFX01BUCk7XG59XG5cbmZ1bmN0aW9uIGZpbHRlckF0dHJpYnV0ZXMocHJvcHMpIHtcbiAgcmV0dXJuIGZpbHRlcihwcm9wcywgZnVuY3Rpb24ocCkgeyByZXR1cm4gcC5pc0F0dHI7IH0pO1xufVxuXG5mdW5jdGlvbiBmaWx0ZXJDb250YWluZWQocHJvcHMpIHtcbiAgcmV0dXJuIGZpbHRlcihwcm9wcywgZnVuY3Rpb24ocCkgeyByZXR1cm4gIXAuaXNBdHRyOyB9KTtcbn1cblxuXG5mdW5jdGlvbiBSZWZlcmVuY2VTZXJpYWxpemVyKHRhZ05hbWUpIHtcbiAgdGhpcy50YWdOYW1lID0gdGFnTmFtZTtcbn1cblxuUmVmZXJlbmNlU2VyaWFsaXplci5wcm90b3R5cGUuYnVpbGQgPSBmdW5jdGlvbihlbGVtZW50KSB7XG4gIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gIHJldHVybiB0aGlzO1xufTtcblxuUmVmZXJlbmNlU2VyaWFsaXplci5wcm90b3R5cGUuc2VyaWFsaXplVG8gPSBmdW5jdGlvbih3cml0ZXIpIHtcbiAgd3JpdGVyXG4gICAgLmFwcGVuZEluZGVudCgpXG4gICAgLmFwcGVuZCgnPCcgKyB0aGlzLnRhZ05hbWUgKyAnPicgKyB0aGlzLmVsZW1lbnQuaWQgKyAnPC8nICsgdGhpcy50YWdOYW1lICsgJz4nKVxuICAgIC5hcHBlbmROZXdMaW5lKCk7XG59O1xuXG5mdW5jdGlvbiBCb2R5U2VyaWFsaXplcigpIHt9XG5cbkJvZHlTZXJpYWxpemVyLnByb3RvdHlwZS5zZXJpYWxpemVWYWx1ZSA9XG5Cb2R5U2VyaWFsaXplci5wcm90b3R5cGUuc2VyaWFsaXplVG8gPSBmdW5jdGlvbih3cml0ZXIpIHtcbiAgd3JpdGVyLmFwcGVuZChcbiAgICB0aGlzLmVzY2FwZVxuICAgICAgPyBlc2NhcGVCb2R5KHRoaXMudmFsdWUpXG4gICAgICA6IHRoaXMudmFsdWVcbiAgKTtcbn07XG5cbkJvZHlTZXJpYWxpemVyLnByb3RvdHlwZS5idWlsZCA9IGZ1bmN0aW9uKHByb3AsIHZhbHVlKSB7XG4gIHRoaXMudmFsdWUgPSB2YWx1ZTtcblxuICBpZiAocHJvcC50eXBlID09PSAnU3RyaW5nJyAmJiB2YWx1ZS5zZWFyY2goRVNDQVBFX0NIQVJTKSAhPT0gLTEpIHtcbiAgICB0aGlzLmVzY2FwZSA9IHRydWU7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIFZhbHVlU2VyaWFsaXplcih0YWdOYW1lKSB7XG4gIHRoaXMudGFnTmFtZSA9IHRhZ05hbWU7XG59XG5cbmluaGVyaXRzKFZhbHVlU2VyaWFsaXplciwgQm9keVNlcmlhbGl6ZXIpO1xuXG5WYWx1ZVNlcmlhbGl6ZXIucHJvdG90eXBlLnNlcmlhbGl6ZVRvID0gZnVuY3Rpb24od3JpdGVyKSB7XG5cbiAgd3JpdGVyXG4gICAgLmFwcGVuZEluZGVudCgpXG4gICAgLmFwcGVuZCgnPCcgKyB0aGlzLnRhZ05hbWUgKyAnPicpO1xuXG4gIHRoaXMuc2VyaWFsaXplVmFsdWUod3JpdGVyKTtcblxuICB3cml0ZXJcbiAgICAuYXBwZW5kKCc8LycgKyB0aGlzLnRhZ05hbWUgKyAnPicpXG4gICAgLmFwcGVuZE5ld0xpbmUoKTtcbn07XG5cbmZ1bmN0aW9uIEVsZW1lbnRTZXJpYWxpemVyKHBhcmVudCwgcHJvcGVydHlEZXNjcmlwdG9yKSB7XG4gIHRoaXMuYm9keSA9IFtdO1xuICB0aGlzLmF0dHJzID0gW107XG5cbiAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gIHRoaXMucHJvcGVydHlEZXNjcmlwdG9yID0gcHJvcGVydHlEZXNjcmlwdG9yO1xufVxuXG5FbGVtZW50U2VyaWFsaXplci5wcm90b3R5cGUuYnVpbGQgPSBmdW5jdGlvbihlbGVtZW50KSB7XG4gIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG5cbiAgdmFyIGVsZW1lbnREZXNjcmlwdG9yID0gZWxlbWVudC4kZGVzY3JpcHRvcixcbiAgICAgIHByb3BlcnR5RGVzY3JpcHRvciA9IHRoaXMucHJvcGVydHlEZXNjcmlwdG9yO1xuXG4gIHZhciBvdGhlckF0dHJzLFxuICAgICAgcHJvcGVydGllcztcblxuICB2YXIgaXNHZW5lcmljID0gZWxlbWVudERlc2NyaXB0b3IuaXNHZW5lcmljO1xuXG4gIGlmIChpc0dlbmVyaWMpIHtcbiAgICBvdGhlckF0dHJzID0gdGhpcy5wYXJzZUdlbmVyaWNOc0F0dHJpYnV0ZXMoZWxlbWVudCk7XG4gIH0gZWxzZSB7XG4gICAgb3RoZXJBdHRycyA9IHRoaXMucGFyc2VOc0F0dHJpYnV0ZXMoZWxlbWVudCk7XG4gIH1cblxuICBpZiAocHJvcGVydHlEZXNjcmlwdG9yKSB7XG4gICAgdGhpcy5ucyA9IHRoaXMubnNQcm9wZXJ0eVRhZ05hbWUocHJvcGVydHlEZXNjcmlwdG9yKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLm5zID0gdGhpcy5uc1RhZ05hbWUoZWxlbWVudERlc2NyaXB0b3IpO1xuICB9XG5cbiAgLy8gY29tcHV0ZSB0YWcgbmFtZVxuICB0aGlzLnRhZ05hbWUgPSB0aGlzLmFkZFRhZ05hbWUodGhpcy5ucyk7XG5cbiAgaWYgKGlzR2VuZXJpYykge1xuICAgIHRoaXMucGFyc2VHZW5lcmljQ29udGFpbm1lbnRzKGVsZW1lbnQpO1xuICB9IGVsc2Uge1xuICAgIHByb3BlcnRpZXMgPSBnZXRTZXJpYWxpemFibGVQcm9wZXJ0aWVzKGVsZW1lbnQpO1xuXG4gICAgdGhpcy5wYXJzZUF0dHJpYnV0ZXMoZmlsdGVyQXR0cmlidXRlcyhwcm9wZXJ0aWVzKSk7XG4gICAgdGhpcy5wYXJzZUNvbnRhaW5tZW50cyhmaWx0ZXJDb250YWluZWQocHJvcGVydGllcykpO1xuICB9XG5cbiAgdGhpcy5wYXJzZUdlbmVyaWNBdHRyaWJ1dGVzKGVsZW1lbnQsIG90aGVyQXR0cnMpO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRWxlbWVudFNlcmlhbGl6ZXIucHJvdG90eXBlLm5zVGFnTmFtZSA9IGZ1bmN0aW9uKGRlc2NyaXB0b3IpIHtcbiAgdmFyIGVmZmVjdGl2ZU5zID0gdGhpcy5sb2dOYW1lc3BhY2VVc2VkKGRlc2NyaXB0b3IubnMpO1xuICByZXR1cm4gZ2V0RWxlbWVudE5zKGVmZmVjdGl2ZU5zLCBkZXNjcmlwdG9yKTtcbn07XG5cbkVsZW1lbnRTZXJpYWxpemVyLnByb3RvdHlwZS5uc1Byb3BlcnR5VGFnTmFtZSA9IGZ1bmN0aW9uKGRlc2NyaXB0b3IpIHtcbiAgdmFyIGVmZmVjdGl2ZU5zID0gdGhpcy5sb2dOYW1lc3BhY2VVc2VkKGRlc2NyaXB0b3IubnMpO1xuICByZXR1cm4gZ2V0UHJvcGVydHlOcyhlZmZlY3RpdmVOcywgZGVzY3JpcHRvcik7XG59O1xuXG5FbGVtZW50U2VyaWFsaXplci5wcm90b3R5cGUuaXNMb2NhbE5zID0gZnVuY3Rpb24obnMpIHtcbiAgcmV0dXJuIG5zLnVyaSA9PT0gdGhpcy5ucy51cmk7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgYWN0dWFsIG5zIGF0dHJpYnV0ZSBuYW1lIGZvciB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZWxlbWVudFxuICogQHBhcmFtIHtCb29sZWFufSBbZWxlbWVudC5pbmhlcml0ZWQ9ZmFsc2VdXG4gKlxuICogQHJldHVybiB7T2JqZWN0fSBuc05hbWVcbiAqL1xuRWxlbWVudFNlcmlhbGl6ZXIucHJvdG90eXBlLm5zQXR0cmlidXRlTmFtZSA9IGZ1bmN0aW9uKGVsZW1lbnQpIHtcblxuICB2YXIgbnM7XG5cbiAgaWYgKGlzU3RyaW5nKGVsZW1lbnQpKSB7XG4gICAgbnMgPSBwYXJzZU5hbWVOUyhlbGVtZW50KTtcbiAgfSBlbHNlIHtcbiAgICBucyA9IGVsZW1lbnQubnM7XG4gIH1cblxuICAvLyByZXR1cm4ganVzdCBsb2NhbCBuYW1lIGZvciBpbmhlcml0ZWQgYXR0cmlidXRlc1xuICBpZiAoZWxlbWVudC5pbmhlcml0ZWQpIHtcbiAgICByZXR1cm4geyBsb2NhbE5hbWU6IG5zLmxvY2FsTmFtZSB9O1xuICB9XG5cbiAgLy8gcGFyc2UgKyBsb2cgZWZmZWN0aXZlIG5zXG4gIHZhciBlZmZlY3RpdmVOcyA9IHRoaXMubG9nTmFtZXNwYWNlVXNlZChucyk7XG5cbiAgLy8gTE9HIEFDVFVBTCBuYW1lc3BhY2UgdXNlXG4gIHRoaXMuZ2V0TmFtZXNwYWNlcygpLmxvZ1VzZWQoZWZmZWN0aXZlTnMpO1xuXG4gIC8vIHN0cmlwIHByZWZpeCBpZiBzYW1lIG5hbWVzcGFjZSBsaWtlIHBhcmVudFxuICBpZiAodGhpcy5pc0xvY2FsTnMoZWZmZWN0aXZlTnMpKSB7XG4gICAgcmV0dXJuIHsgbG9jYWxOYW1lOiBucy5sb2NhbE5hbWUgfTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYXNzaWduKHsgbG9jYWxOYW1lOiBucy5sb2NhbE5hbWUgfSwgZWZmZWN0aXZlTnMpO1xuICB9XG59O1xuXG5FbGVtZW50U2VyaWFsaXplci5wcm90b3R5cGUucGFyc2VHZW5lcmljTnNBdHRyaWJ1dGVzID0gZnVuY3Rpb24oZWxlbWVudCkge1xuXG4gIHJldHVybiBPYmplY3QuZW50cmllcyhlbGVtZW50KS5maWx0ZXIoXG4gICAgKFsga2V5LCB2YWx1ZSBdKSA9PiAha2V5LnN0YXJ0c1dpdGgoJyQnKSAmJiB0aGlzLnBhcnNlTnNBdHRyaWJ1dGUoZWxlbWVudCwga2V5LCB2YWx1ZSlcbiAgKS5tYXAoXG4gICAgKFsga2V5LCB2YWx1ZSBdKSA9PiAoeyBuYW1lOiBrZXksIHZhbHVlOiB2YWx1ZSB9KVxuICApO1xufTtcblxuRWxlbWVudFNlcmlhbGl6ZXIucHJvdG90eXBlLnBhcnNlR2VuZXJpY0NvbnRhaW5tZW50cyA9IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgdmFyIGJvZHkgPSBlbGVtZW50LiRib2R5O1xuXG4gIGlmIChib2R5KSB7XG4gICAgdGhpcy5ib2R5LnB1c2gobmV3IEJvZHlTZXJpYWxpemVyKCkuYnVpbGQoeyB0eXBlOiAnU3RyaW5nJyB9LCBib2R5KSk7XG4gIH1cblxuICB2YXIgY2hpbGRyZW4gPSBlbGVtZW50LiRjaGlsZHJlbjtcblxuICBpZiAoY2hpbGRyZW4pIHtcbiAgICBmb3JFYWNoKGNoaWxkcmVuLCBjaGlsZCA9PiB7XG4gICAgICB0aGlzLmJvZHkucHVzaChuZXcgRWxlbWVudFNlcmlhbGl6ZXIodGhpcykuYnVpbGQoY2hpbGQpKTtcbiAgICB9KTtcbiAgfVxufTtcblxuRWxlbWVudFNlcmlhbGl6ZXIucHJvdG90eXBlLnBhcnNlTnNBdHRyaWJ1dGUgPSBmdW5jdGlvbihlbGVtZW50LCBuYW1lLCB2YWx1ZSkge1xuICB2YXIgbW9kZWwgPSBlbGVtZW50LiRtb2RlbDtcblxuICB2YXIgbmFtZU5zID0gcGFyc2VOYW1lTlMobmFtZSk7XG5cbiAgdmFyIG5zO1xuXG4gIC8vIHBhcnNlIHhtbG5zOmZvbz1cImh0dHA6Ly9mb28uYmFyXCJcbiAgaWYgKG5hbWVOcy5wcmVmaXggPT09ICd4bWxucycpIHtcbiAgICBucyA9IHsgcHJlZml4OiBuYW1lTnMubG9jYWxOYW1lLCB1cmk6IHZhbHVlIH07XG4gIH1cblxuICAvLyBwYXJzZSB4bWxucz1cImh0dHA6Ly9mb28uYmFyXCJcbiAgaWYgKCFuYW1lTnMucHJlZml4ICYmIG5hbWVOcy5sb2NhbE5hbWUgPT09ICd4bWxucycpIHtcbiAgICBucyA9IHsgdXJpOiB2YWx1ZSB9O1xuICB9XG5cbiAgaWYgKCFucykge1xuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiBuYW1lLFxuICAgICAgdmFsdWU6IHZhbHVlXG4gICAgfTtcbiAgfVxuXG4gIGlmIChtb2RlbCAmJiBtb2RlbC5nZXRQYWNrYWdlKHZhbHVlKSkge1xuXG4gICAgLy8gcmVnaXN0ZXIgd2VsbCBrbm93biBuYW1lc3BhY2VcbiAgICB0aGlzLmxvZ05hbWVzcGFjZShucywgdHJ1ZSwgdHJ1ZSk7XG4gIH0gZWxzZSB7XG5cbiAgICAvLyBsb2cgY3VzdG9tIG5hbWVzcGFjZSBkaXJlY3RseSBhcyB1c2VkXG4gICAgdmFyIGFjdHVhbE5zID0gdGhpcy5sb2dOYW1lc3BhY2VVc2VkKG5zLCB0cnVlKTtcblxuICAgIHRoaXMuZ2V0TmFtZXNwYWNlcygpLmxvZ1VzZWQoYWN0dWFsTnMpO1xuICB9XG59O1xuXG5cbi8qKlxuICogUGFyc2UgbmFtZXNwYWNlcyBhbmQgcmV0dXJuIGEgbGlzdCBvZiBsZWZ0IG92ZXIgZ2VuZXJpYyBhdHRyaWJ1dGVzXG4gKlxuICogQHBhcmFtICB7T2JqZWN0fSBlbGVtZW50XG4gKiBAcmV0dXJuIHtBcnJheTxPYmplY3Q+fVxuICovXG5FbGVtZW50U2VyaWFsaXplci5wcm90b3R5cGUucGFyc2VOc0F0dHJpYnV0ZXMgPSBmdW5jdGlvbihlbGVtZW50KSB7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICB2YXIgZ2VuZXJpY0F0dHJzID0gZWxlbWVudC4kYXR0cnM7XG5cbiAgdmFyIGF0dHJpYnV0ZXMgPSBbXTtcblxuICAvLyBwYXJzZSBuYW1lc3BhY2UgYXR0cmlidXRlcyBmaXJzdFxuICAvLyBhbmQgbG9nIHRoZW0uIHB1c2ggbm9uIG5hbWVzcGFjZSBhdHRyaWJ1dGVzIHRvIGEgbGlzdFxuICAvLyBhbmQgcHJvY2VzcyB0aGVtIGxhdGVyXG4gIGZvckVhY2goZ2VuZXJpY0F0dHJzLCBmdW5jdGlvbih2YWx1ZSwgbmFtZSkge1xuXG4gICAgdmFyIG5vbk5zQXR0ciA9IHNlbGYucGFyc2VOc0F0dHJpYnV0ZShlbGVtZW50LCBuYW1lLCB2YWx1ZSk7XG5cbiAgICBpZiAobm9uTnNBdHRyKSB7XG4gICAgICBhdHRyaWJ1dGVzLnB1c2gobm9uTnNBdHRyKTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBhdHRyaWJ1dGVzO1xufTtcblxuRWxlbWVudFNlcmlhbGl6ZXIucHJvdG90eXBlLnBhcnNlR2VuZXJpY0F0dHJpYnV0ZXMgPSBmdW5jdGlvbihlbGVtZW50LCBhdHRyaWJ1dGVzKSB7XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIGZvckVhY2goYXR0cmlidXRlcywgZnVuY3Rpb24oYXR0cikge1xuXG4gICAgdHJ5IHtcbiAgICAgIHNlbGYuYWRkQXR0cmlidXRlKHNlbGYubnNBdHRyaWJ1dGVOYW1lKGF0dHIubmFtZSksIGF0dHIudmFsdWUpO1xuICAgIH0gY2F0Y2ggKGUpIHtcblxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG4gICAgICB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiYgY29uc29sZS53YXJuKFxuICAgICAgICBgbWlzc2luZyBuYW1lc3BhY2UgaW5mb3JtYXRpb24gZm9yIDwke1xuICAgICAgICAgIGF0dHIubmFtZVxuICAgICAgICB9PSR7IGF0dHIudmFsdWUgfT4gb25gLCBlbGVtZW50LCBlXG4gICAgICApO1xuICAgIH1cbiAgfSk7XG59O1xuXG5FbGVtZW50U2VyaWFsaXplci5wcm90b3R5cGUucGFyc2VDb250YWlubWVudHMgPSBmdW5jdGlvbihwcm9wZXJ0aWVzKSB7XG5cbiAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgYm9keSA9IHRoaXMuYm9keSxcbiAgICAgIGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQ7XG5cbiAgZm9yRWFjaChwcm9wZXJ0aWVzLCBmdW5jdGlvbihwKSB7XG4gICAgdmFyIHZhbHVlID0gZWxlbWVudC5nZXQocC5uYW1lKSxcbiAgICAgICAgaXNSZWZlcmVuY2UgPSBwLmlzUmVmZXJlbmNlLFxuICAgICAgICBpc01hbnkgPSBwLmlzTWFueTtcblxuICAgIGlmICghaXNNYW55KSB7XG4gICAgICB2YWx1ZSA9IFsgdmFsdWUgXTtcbiAgICB9XG5cbiAgICBpZiAocC5pc0JvZHkpIHtcbiAgICAgIGJvZHkucHVzaChuZXcgQm9keVNlcmlhbGl6ZXIoKS5idWlsZChwLCB2YWx1ZVswXSkpO1xuICAgIH0gZWxzZSBpZiAoaXNTaW1wbGVUeXBlKHAudHlwZSkpIHtcbiAgICAgIGZvckVhY2godmFsdWUsIGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgYm9keS5wdXNoKG5ldyBWYWx1ZVNlcmlhbGl6ZXIoc2VsZi5hZGRUYWdOYW1lKHNlbGYubnNQcm9wZXJ0eVRhZ05hbWUocCkpKS5idWlsZChwLCB2KSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKGlzUmVmZXJlbmNlKSB7XG4gICAgICBmb3JFYWNoKHZhbHVlLCBmdW5jdGlvbih2KSB7XG4gICAgICAgIGJvZHkucHVzaChuZXcgUmVmZXJlbmNlU2VyaWFsaXplcihzZWxmLmFkZFRhZ05hbWUoc2VsZi5uc1Byb3BlcnR5VGFnTmFtZShwKSkpLmJ1aWxkKHYpKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG5cbiAgICAgIC8vIGFsbG93IHNlcmlhbGl6YXRpb24gdmlhIHR5cGVcbiAgICAgIC8vIHJhdGhlciB0aGFuIGVsZW1lbnQgbmFtZVxuICAgICAgdmFyIHNlcmlhbGl6YXRpb24gPSBnZXRTZXJpYWxpemF0aW9uKHApO1xuXG4gICAgICBmb3JFYWNoKHZhbHVlLCBmdW5jdGlvbih2KSB7XG4gICAgICAgIHZhciBzZXJpYWxpemVyO1xuXG4gICAgICAgIGlmIChzZXJpYWxpemF0aW9uKSB7XG4gICAgICAgICAgaWYgKHNlcmlhbGl6YXRpb24gPT09IFNFUklBTElaRV9QUk9QRVJUWSkge1xuICAgICAgICAgICAgc2VyaWFsaXplciA9IG5ldyBFbGVtZW50U2VyaWFsaXplcihzZWxmLCBwKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2VyaWFsaXplciA9IG5ldyBUeXBlU2VyaWFsaXplcihzZWxmLCBwLCBzZXJpYWxpemF0aW9uKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2VyaWFsaXplciA9IG5ldyBFbGVtZW50U2VyaWFsaXplcihzZWxmKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJvZHkucHVzaChzZXJpYWxpemVyLmJ1aWxkKHYpKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG59O1xuXG5FbGVtZW50U2VyaWFsaXplci5wcm90b3R5cGUuZ2V0TmFtZXNwYWNlcyA9IGZ1bmN0aW9uKGxvY2FsKSB7XG5cbiAgdmFyIG5hbWVzcGFjZXMgPSB0aGlzLm5hbWVzcGFjZXMsXG4gICAgICBwYXJlbnQgPSB0aGlzLnBhcmVudCxcbiAgICAgIHBhcmVudE5hbWVzcGFjZXM7XG5cbiAgaWYgKCFuYW1lc3BhY2VzKSB7XG4gICAgcGFyZW50TmFtZXNwYWNlcyA9IHBhcmVudCAmJiBwYXJlbnQuZ2V0TmFtZXNwYWNlcygpO1xuXG4gICAgaWYgKGxvY2FsIHx8ICFwYXJlbnROYW1lc3BhY2VzKSB7XG4gICAgICB0aGlzLm5hbWVzcGFjZXMgPSBuYW1lc3BhY2VzID0gbmV3IE5hbWVzcGFjZXMocGFyZW50TmFtZXNwYWNlcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5hbWVzcGFjZXMgPSBwYXJlbnROYW1lc3BhY2VzO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuYW1lc3BhY2VzO1xufTtcblxuRWxlbWVudFNlcmlhbGl6ZXIucHJvdG90eXBlLmxvZ05hbWVzcGFjZSA9IGZ1bmN0aW9uKG5zLCB3ZWxsa25vd24sIGxvY2FsKSB7XG4gIHZhciBuYW1lc3BhY2VzID0gdGhpcy5nZXROYW1lc3BhY2VzKGxvY2FsKTtcblxuICB2YXIgbnNVcmkgPSBucy51cmksXG4gICAgICBuc1ByZWZpeCA9IG5zLnByZWZpeDtcblxuICB2YXIgZXhpc3RpbmcgPSBuYW1lc3BhY2VzLmJ5VXJpKG5zVXJpKTtcblxuICBpZiAoIWV4aXN0aW5nIHx8IGxvY2FsKSB7XG4gICAgbmFtZXNwYWNlcy5hZGQobnMsIHdlbGxrbm93bik7XG4gIH1cblxuICBuYW1lc3BhY2VzLm1hcFByZWZpeChuc1ByZWZpeCwgbnNVcmkpO1xuXG4gIHJldHVybiBucztcbn07XG5cbkVsZW1lbnRTZXJpYWxpemVyLnByb3RvdHlwZS5sb2dOYW1lc3BhY2VVc2VkID0gZnVuY3Rpb24obnMsIGxvY2FsKSB7XG4gIHZhciBuYW1lc3BhY2VzID0gdGhpcy5nZXROYW1lc3BhY2VzKGxvY2FsKTtcblxuICAvLyBucyBtYXkgYmVcbiAgLy9cbiAgLy8gICAqIHByZWZpeCBvbmx5XG4gIC8vICAgKiBwcmVmaXg6dXJpXG4gIC8vICAgKiBsb2NhbE5hbWUgb25seVxuXG4gIHZhciBwcmVmaXggPSBucy5wcmVmaXgsXG4gICAgICB1cmkgPSBucy51cmksXG4gICAgICBuZXdQcmVmaXgsIGlkeCxcbiAgICAgIHdlbGxrbm93blVyaTtcblxuICAvLyBoYW5kbGUgYW5vbnltb3VzIG5hbWVzcGFjZXMgKGVsZW1lbnRGb3JtPXVucXVhbGlmaWVkKSwgY2YuICMyM1xuICBpZiAoIXByZWZpeCAmJiAhdXJpKSB7XG4gICAgcmV0dXJuIHsgbG9jYWxOYW1lOiBucy5sb2NhbE5hbWUgfTtcbiAgfVxuXG4gIHdlbGxrbm93blVyaSA9IG5hbWVzcGFjZXMuZGVmYXVsdFVyaUJ5UHJlZml4KHByZWZpeCk7XG5cbiAgdXJpID0gdXJpIHx8IHdlbGxrbm93blVyaSB8fCBuYW1lc3BhY2VzLnVyaUJ5UHJlZml4KHByZWZpeCk7XG5cbiAgaWYgKCF1cmkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ25vIG5hbWVzcGFjZSB1cmkgZ2l2ZW4gZm9yIHByZWZpeCA8JyArIHByZWZpeCArICc+Jyk7XG4gIH1cblxuICBucyA9IG5hbWVzcGFjZXMuYnlVcmkodXJpKTtcblxuICAvLyByZWdpc3RlciBuZXcgZGVmYXVsdCBwcmVmaXggPHhtbG5zPiBpbiBsb2NhbCBzY29wZVxuICBpZiAoIW5zICYmICFwcmVmaXgpIHtcbiAgICBucyA9IHRoaXMubG9nTmFtZXNwYWNlKHsgdXJpIH0sIHdlbGxrbm93blVyaSA9PT0gdXJpLCB0cnVlKTtcbiAgfVxuXG4gIGlmICghbnMpIHtcbiAgICBuZXdQcmVmaXggPSBwcmVmaXg7XG4gICAgaWR4ID0gMTtcblxuICAgIC8vIGZpbmQgYSBwcmVmaXggdGhhdCBpcyBub3QgbWFwcGVkIHlldFxuICAgIHdoaWxlIChuYW1lc3BhY2VzLnVyaUJ5UHJlZml4KG5ld1ByZWZpeCkpIHtcbiAgICAgIG5ld1ByZWZpeCA9IHByZWZpeCArICdfJyArIGlkeCsrO1xuICAgIH1cblxuICAgIG5zID0gdGhpcy5sb2dOYW1lc3BhY2UoeyBwcmVmaXg6IG5ld1ByZWZpeCwgdXJpOiB1cmkgfSwgd2VsbGtub3duVXJpID09PSB1cmkpO1xuICB9XG5cbiAgaWYgKHByZWZpeCkge1xuICAgIG5hbWVzcGFjZXMubWFwUHJlZml4KHByZWZpeCwgdXJpKTtcbiAgfVxuXG4gIHJldHVybiBucztcbn07XG5cbkVsZW1lbnRTZXJpYWxpemVyLnByb3RvdHlwZS5wYXJzZUF0dHJpYnV0ZXMgPSBmdW5jdGlvbihwcm9wZXJ0aWVzKSB7XG4gIHZhciBzZWxmID0gdGhpcyxcbiAgICAgIGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQ7XG5cbiAgZm9yRWFjaChwcm9wZXJ0aWVzLCBmdW5jdGlvbihwKSB7XG5cbiAgICB2YXIgdmFsdWUgPSBlbGVtZW50LmdldChwLm5hbWUpO1xuXG4gICAgaWYgKHAuaXNSZWZlcmVuY2UpIHtcblxuICAgICAgaWYgKCFwLmlzTWFueSkge1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLmlkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHZhbHVlcyA9IFtdO1xuICAgICAgICBmb3JFYWNoKHZhbHVlLCBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgdmFsdWVzLnB1c2godi5pZCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIElEUkVGUyBpcyBhIHdoaXRlc3BhY2Utc2VwYXJhdGVkIGxpc3Qgb2YgcmVmZXJlbmNlcy5cbiAgICAgICAgdmFsdWUgPSB2YWx1ZXMuam9pbignICcpO1xuICAgICAgfVxuXG4gICAgfVxuXG4gICAgc2VsZi5hZGRBdHRyaWJ1dGUoc2VsZi5uc0F0dHJpYnV0ZU5hbWUocCksIHZhbHVlKTtcbiAgfSk7XG59O1xuXG5FbGVtZW50U2VyaWFsaXplci5wcm90b3R5cGUuYWRkVGFnTmFtZSA9IGZ1bmN0aW9uKG5zVGFnTmFtZSkge1xuICB2YXIgYWN0dWFsTnMgPSB0aGlzLmxvZ05hbWVzcGFjZVVzZWQobnNUYWdOYW1lKTtcblxuICB0aGlzLmdldE5hbWVzcGFjZXMoKS5sb2dVc2VkKGFjdHVhbE5zKTtcblxuICByZXR1cm4gbnNOYW1lKG5zVGFnTmFtZSk7XG59O1xuXG5FbGVtZW50U2VyaWFsaXplci5wcm90b3R5cGUuYWRkQXR0cmlidXRlID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgdmFyIGF0dHJzID0gdGhpcy5hdHRycztcblxuICBpZiAoaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgdmFsdWUgPSBlc2NhcGVBdHRyKHZhbHVlKTtcbiAgfVxuXG4gIC8vIGRlLWR1cGxpY2F0ZSBhdHRyaWJ1dGVzXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9icG1uLWlvL21vZGRsZS14bWwvaXNzdWVzLzY2XG4gIHZhciBpZHggPSBmaW5kSW5kZXgoYXR0cnMsIGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICByZXR1cm4gKFxuICAgICAgZWxlbWVudC5uYW1lLmxvY2FsTmFtZSA9PT0gbmFtZS5sb2NhbE5hbWUgJiZcbiAgICAgIGVsZW1lbnQubmFtZS51cmkgPT09IG5hbWUudXJpICYmXG4gICAgICBlbGVtZW50Lm5hbWUucHJlZml4ID09PSBuYW1lLnByZWZpeFxuICAgICk7XG4gIH0pO1xuXG4gIHZhciBhdHRyID0geyBuYW1lOiBuYW1lLCB2YWx1ZTogdmFsdWUgfTtcblxuICBpZiAoaWR4ICE9PSAtMSkge1xuICAgIGF0dHJzLnNwbGljZShpZHgsIDEsIGF0dHIpO1xuICB9IGVsc2Uge1xuICAgIGF0dHJzLnB1c2goYXR0cik7XG4gIH1cbn07XG5cbkVsZW1lbnRTZXJpYWxpemVyLnByb3RvdHlwZS5zZXJpYWxpemVBdHRyaWJ1dGVzID0gZnVuY3Rpb24od3JpdGVyKSB7XG4gIHZhciBhdHRycyA9IHRoaXMuYXR0cnMsXG4gICAgICBuYW1lc3BhY2VzID0gdGhpcy5uYW1lc3BhY2VzO1xuXG4gIGlmIChuYW1lc3BhY2VzKSB7XG4gICAgYXR0cnMgPSBnZXROc0F0dHJzKG5hbWVzcGFjZXMpLmNvbmNhdChhdHRycyk7XG4gIH1cblxuICBmb3JFYWNoKGF0dHJzLCBmdW5jdGlvbihhKSB7XG4gICAgd3JpdGVyXG4gICAgICAuYXBwZW5kKCcgJylcbiAgICAgIC5hcHBlbmQobnNOYW1lKGEubmFtZSkpLmFwcGVuZCgnPVwiJykuYXBwZW5kKGEudmFsdWUpLmFwcGVuZCgnXCInKTtcbiAgfSk7XG59O1xuXG5FbGVtZW50U2VyaWFsaXplci5wcm90b3R5cGUuc2VyaWFsaXplVG8gPSBmdW5jdGlvbih3cml0ZXIpIHtcbiAgdmFyIGZpcnN0Qm9keSA9IHRoaXMuYm9keVswXSxcbiAgICAgIGluZGVudCA9IGZpcnN0Qm9keSAmJiBmaXJzdEJvZHkuY29uc3RydWN0b3IgIT09IEJvZHlTZXJpYWxpemVyO1xuXG4gIHdyaXRlclxuICAgIC5hcHBlbmRJbmRlbnQoKVxuICAgIC5hcHBlbmQoJzwnICsgdGhpcy50YWdOYW1lKTtcblxuICB0aGlzLnNlcmlhbGl6ZUF0dHJpYnV0ZXMod3JpdGVyKTtcblxuICB3cml0ZXIuYXBwZW5kKGZpcnN0Qm9keSA/ICc+JyA6ICcgLz4nKTtcblxuICBpZiAoZmlyc3RCb2R5KSB7XG5cbiAgICBpZiAoaW5kZW50KSB7XG4gICAgICB3cml0ZXJcbiAgICAgICAgLmFwcGVuZE5ld0xpbmUoKVxuICAgICAgICAuaW5kZW50KCk7XG4gICAgfVxuXG4gICAgZm9yRWFjaCh0aGlzLmJvZHksIGZ1bmN0aW9uKGIpIHtcbiAgICAgIGIuc2VyaWFsaXplVG8od3JpdGVyKTtcbiAgICB9KTtcblxuICAgIGlmIChpbmRlbnQpIHtcbiAgICAgIHdyaXRlclxuICAgICAgICAudW5pbmRlbnQoKVxuICAgICAgICAuYXBwZW5kSW5kZW50KCk7XG4gICAgfVxuXG4gICAgd3JpdGVyLmFwcGVuZCgnPC8nICsgdGhpcy50YWdOYW1lICsgJz4nKTtcbiAgfVxuXG4gIHdyaXRlci5hcHBlbmROZXdMaW5lKCk7XG59O1xuXG4vKipcbiAqIEEgc2VyaWFsaXplciBmb3IgdHlwZXMgdGhhdCBoYW5kbGVzIHNlcmlhbGl6YXRpb24gb2YgZGF0YSB0eXBlc1xuICovXG5mdW5jdGlvbiBUeXBlU2VyaWFsaXplcihwYXJlbnQsIHByb3BlcnR5RGVzY3JpcHRvciwgc2VyaWFsaXphdGlvbikge1xuICBFbGVtZW50U2VyaWFsaXplci5jYWxsKHRoaXMsIHBhcmVudCwgcHJvcGVydHlEZXNjcmlwdG9yKTtcblxuICB0aGlzLnNlcmlhbGl6YXRpb24gPSBzZXJpYWxpemF0aW9uO1xufVxuXG5pbmhlcml0cyhUeXBlU2VyaWFsaXplciwgRWxlbWVudFNlcmlhbGl6ZXIpO1xuXG5UeXBlU2VyaWFsaXplci5wcm90b3R5cGUucGFyc2VOc0F0dHJpYnV0ZXMgPSBmdW5jdGlvbihlbGVtZW50KSB7XG5cbiAgLy8gZXh0cmFjdGVkIGF0dHJpYnV0ZXMgd2l0aCBzZXJpYWxpemF0aW9uIGF0dHJpYnV0ZVxuICAvLyA8dHlwZT10eXBlTmFtZT4gc3RyaXBwZWQ7IGl0IG1heSBiZSBsYXRlclxuICB2YXIgYXR0cmlidXRlcyA9IEVsZW1lbnRTZXJpYWxpemVyLnByb3RvdHlwZS5wYXJzZU5zQXR0cmlidXRlcy5jYWxsKHRoaXMsIGVsZW1lbnQpLmZpbHRlcihcbiAgICBhdHRyID0+IGF0dHIubmFtZSAhPT0gdGhpcy5zZXJpYWxpemF0aW9uXG4gICk7XG5cbiAgdmFyIGRlc2NyaXB0b3IgPSBlbGVtZW50LiRkZXNjcmlwdG9yO1xuXG4gIC8vIG9ubHkgc2VyaWFsaXplIDx0eXBlPXR5cGVOYW1lPiBpZiBuZWNlc3NhcnlcbiAgaWYgKGRlc2NyaXB0b3IubmFtZSA9PT0gdGhpcy5wcm9wZXJ0eURlc2NyaXB0b3IudHlwZSkge1xuICAgIHJldHVybiBhdHRyaWJ1dGVzO1xuICB9XG5cbiAgdmFyIHR5cGVOcyA9IHRoaXMudHlwZU5zID0gdGhpcy5uc1RhZ05hbWUoZGVzY3JpcHRvcik7XG4gIHRoaXMuZ2V0TmFtZXNwYWNlcygpLmxvZ1VzZWQodGhpcy50eXBlTnMpO1xuXG4gIC8vIGFkZCB4c2k6dHlwZSBhdHRyaWJ1dGUgdG8gcmVwcmVzZW50IHRoZSBlbGVtZW50c1xuICAvLyBhY3R1YWwgdHlwZVxuXG4gIHZhciBwa2cgPSBlbGVtZW50LiRtb2RlbC5nZXRQYWNrYWdlKHR5cGVOcy51cmkpLFxuICAgICAgdHlwZVByZWZpeCA9IChwa2cueG1sICYmIHBrZy54bWwudHlwZVByZWZpeCkgfHwgJyc7XG5cbiAgdGhpcy5hZGRBdHRyaWJ1dGUoXG4gICAgdGhpcy5uc0F0dHJpYnV0ZU5hbWUodGhpcy5zZXJpYWxpemF0aW9uKSxcbiAgICAodHlwZU5zLnByZWZpeCA/IHR5cGVOcy5wcmVmaXggKyAnOicgOiAnJykgKyB0eXBlUHJlZml4ICsgZGVzY3JpcHRvci5ucy5sb2NhbE5hbWVcbiAgKTtcblxuICByZXR1cm4gYXR0cmlidXRlcztcbn07XG5cblR5cGVTZXJpYWxpemVyLnByb3RvdHlwZS5pc0xvY2FsTnMgPSBmdW5jdGlvbihucykge1xuICByZXR1cm4gbnMudXJpID09PSAodGhpcy50eXBlTnMgfHwgdGhpcy5ucykudXJpO1xufTtcblxuZnVuY3Rpb24gU2F2aW5nV3JpdGVyKCkge1xuICB0aGlzLnZhbHVlID0gJyc7XG5cbiAgdGhpcy53cml0ZSA9IGZ1bmN0aW9uKHN0cikge1xuICAgIHRoaXMudmFsdWUgKz0gc3RyO1xuICB9O1xufVxuXG5mdW5jdGlvbiBGb3JtYXRpbmdXcml0ZXIob3V0LCBmb3JtYXQpIHtcblxuICB2YXIgaW5kZW50ID0gWyAnJyBdO1xuXG4gIHRoaXMuYXBwZW5kID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgb3V0LndyaXRlKHN0cik7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICB0aGlzLmFwcGVuZE5ld0xpbmUgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAoZm9ybWF0KSB7XG4gICAgICBvdXQud3JpdGUoJ1xcbicpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIHRoaXMuYXBwZW5kSW5kZW50ID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKGZvcm1hdCkge1xuICAgICAgb3V0LndyaXRlKGluZGVudC5qb2luKCcgICcpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICB0aGlzLmluZGVudCA9IGZ1bmN0aW9uKCkge1xuICAgIGluZGVudC5wdXNoKCcnKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICB0aGlzLnVuaW5kZW50ID0gZnVuY3Rpb24oKSB7XG4gICAgaW5kZW50LnBvcCgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xufVxuXG4vKipcbiAqIEEgd3JpdGVyIGZvciBtZXRhLW1vZGVsIGJhY2tlZCBkb2N1bWVudCB0cmVlc1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIG91dHB1dCBvcHRpb25zIHRvIHBhc3MgaW50byB0aGUgd3JpdGVyXG4gKi9cbmZ1bmN0aW9uIFdyaXRlcihvcHRpb25zKSB7XG5cbiAgb3B0aW9ucyA9IGFzc2lnbih7IGZvcm1hdDogZmFsc2UsIHByZWFtYmxlOiB0cnVlIH0sIG9wdGlvbnMgfHwge30pO1xuXG4gIGZ1bmN0aW9uIHRvWE1MKHRyZWUsIHdyaXRlcikge1xuICAgIHZhciBpbnRlcm5hbFdyaXRlciA9IHdyaXRlciB8fCBuZXcgU2F2aW5nV3JpdGVyKCk7XG4gICAgdmFyIGZvcm1hdGluZ1dyaXRlciA9IG5ldyBGb3JtYXRpbmdXcml0ZXIoaW50ZXJuYWxXcml0ZXIsIG9wdGlvbnMuZm9ybWF0KTtcblxuICAgIGlmIChvcHRpb25zLnByZWFtYmxlKSB7XG4gICAgICBmb3JtYXRpbmdXcml0ZXIuYXBwZW5kKFhNTF9QUkVBTUJMRSk7XG4gICAgfVxuXG4gICAgdmFyIHNlcmlhbGl6ZXIgPSBuZXcgRWxlbWVudFNlcmlhbGl6ZXIoKTtcblxuICAgIHZhciBtb2RlbCA9IHRyZWUuJG1vZGVsO1xuXG4gICAgc2VyaWFsaXplci5nZXROYW1lc3BhY2VzKCkubWFwRGVmYXVsdFByZWZpeGVzKGdldERlZmF1bHRQcmVmaXhNYXBwaW5ncyhtb2RlbCkpO1xuXG4gICAgc2VyaWFsaXplci5idWlsZCh0cmVlKS5zZXJpYWxpemVUbyhmb3JtYXRpbmdXcml0ZXIpO1xuXG4gICAgaWYgKCF3cml0ZXIpIHtcbiAgICAgIHJldHVybiBpbnRlcm5hbFdyaXRlci52YWx1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHRvWE1MOiB0b1hNTFxuICB9O1xufVxuXG5cbi8vIGhlbHBlcnMgLy8vLy8vLy8vLy9cblxuLyoqXG4gKiBAcGFyYW0ge01vZGRsZX0gbW9kZWxcbiAqXG4gKiBAcmV0dXJuIHsgUmVjb3JkPHN0cmluZywgc3RyaW5nPiB9IG1hcCBmcm9tIHByZWZpeCB0byBVUklcbiAqL1xuZnVuY3Rpb24gZ2V0RGVmYXVsdFByZWZpeE1hcHBpbmdzKG1vZGVsKSB7XG5cbiAgY29uc3QgbnNNYXAgPSBtb2RlbC5jb25maWcgJiYgbW9kZWwuY29uZmlnLm5zTWFwIHx8IHt9O1xuXG4gIGNvbnN0IHByZWZpeE1hcCA9IHt9O1xuXG4gIC8vIHsgcHJlZml4IC0+IHVyaSB9XG4gIGZvciAoY29uc3QgcHJlZml4IGluIERFRkFVTFRfTlNfTUFQKSB7XG4gICAgcHJlZml4TWFwW3ByZWZpeF0gPSBERUZBVUxUX05TX01BUFtwcmVmaXhdO1xuICB9XG5cbiAgLy8geyB1cmkgLT4gcHJlZml4IH1cbiAgZm9yIChjb25zdCB1cmkgaW4gbnNNYXApIHtcbiAgICBjb25zdCBwcmVmaXggPSBuc01hcFt1cmldO1xuXG4gICAgcHJlZml4TWFwW3ByZWZpeF0gPSB1cmk7XG4gIH1cblxuICBmb3IgKGNvbnN0IHBrZyBvZiBtb2RlbC5nZXRQYWNrYWdlcygpKSB7XG4gICAgcHJlZml4TWFwW3BrZy5wcmVmaXhdID0gcGtnLnVyaTtcbiAgfVxuXG4gIHJldHVybiBwcmVmaXhNYXA7XG59XG5cbmV4cG9ydCB7IFJlYWRlciwgV3JpdGVyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/moddle-xml/dist/index.js\n");

/***/ })

};
;