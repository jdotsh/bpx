"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/moddle";
exports.ids = ["vendor-chunks/moddle"];
exports.modules = {

/***/ "(ssr)/./node_modules/moddle/dist/index.js":
/*!*******************************************!*\
  !*** ./node_modules/moddle/dist/index.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Moddle: () => (/* binding */ Moddle),\n/* harmony export */   coerceType: () => (/* binding */ coerceType),\n/* harmony export */   isBuiltInType: () => (/* binding */ isBuiltIn),\n/* harmony export */   isSimpleType: () => (/* binding */ isSimple),\n/* harmony export */   parseNameNS: () => (/* binding */ parseName)\n/* harmony export */ });\n/* harmony import */ var min_dash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! min-dash */ \"(ssr)/./node_modules/min-dash/dist/index.esm.js\");\n\n\n/**\n * Moddle base element.\n */\nfunction Base() { }\n\nBase.prototype.get = function(name) {\n  return this.$model.properties.get(this, name);\n};\n\nBase.prototype.set = function(name, value) {\n  this.$model.properties.set(this, name, value);\n};\n\n/**\n * A model element factory.\n *\n * @param {Moddle} model\n * @param {Properties} properties\n */\nfunction Factory(model, properties) {\n  this.model = model;\n  this.properties = properties;\n}\n\n\nFactory.prototype.createType = function(descriptor) {\n\n  var model = this.model;\n\n  var props = this.properties,\n      prototype = Object.create(Base.prototype);\n\n  // initialize default values\n  (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(descriptor.properties, function(p) {\n    if (!p.isMany && p.default !== undefined) {\n      prototype[p.name] = p.default;\n    }\n  });\n\n  props.defineModel(prototype, model);\n  props.defineDescriptor(prototype, descriptor);\n\n  var name = descriptor.ns.name;\n\n  /**\n   * The new type constructor\n   */\n  function ModdleElement(attrs) {\n    props.define(this, '$type', { value: name, enumerable: true });\n    props.define(this, '$attrs', { value: {} });\n    props.define(this, '$parent', { writable: true });\n\n    (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(attrs, (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.bind)(function(val, key) {\n      this.set(key, val);\n    }, this));\n  }\n\n  ModdleElement.prototype = prototype;\n\n  ModdleElement.hasType = prototype.$instanceOf = this.model.hasType;\n\n  // static links\n  props.defineModel(ModdleElement, model);\n  props.defineDescriptor(ModdleElement, descriptor);\n\n  return ModdleElement;\n};\n\n/**\n * Built-in moddle types\n */\nvar BUILTINS = {\n  String: true,\n  Boolean: true,\n  Integer: true,\n  Real: true,\n  Element: true\n};\n\n/**\n * Converters for built in types from string representations\n */\nvar TYPE_CONVERTERS = {\n  String: function(s) { return s; },\n  Boolean: function(s) { return s === 'true'; },\n  Integer: function(s) { return parseInt(s, 10); },\n  Real: function(s) { return parseFloat(s); }\n};\n\n/**\n * Convert a type to its real representation\n */\nfunction coerceType(type, value) {\n\n  var converter = TYPE_CONVERTERS[type];\n\n  if (converter) {\n    return converter(value);\n  } else {\n    return value;\n  }\n}\n\n/**\n * Return whether the given type is built-in\n */\nfunction isBuiltIn(type) {\n  return !!BUILTINS[type];\n}\n\n/**\n * Return whether the given type is simple\n */\nfunction isSimple(type) {\n  return !!TYPE_CONVERTERS[type];\n}\n\n/**\n * Parses a namespaced attribute name of the form (ns:)localName to an object,\n * given a default prefix to assume in case no explicit namespace is given.\n *\n * @param {String} name\n * @param {String} [defaultPrefix] the default prefix to take, if none is present.\n *\n * @return {Object} the parsed name\n */\nfunction parseName(name, defaultPrefix) {\n  var parts = name.split(/:/),\n      localName, prefix;\n\n  // no prefix (i.e. only local name)\n  if (parts.length === 1) {\n    localName = name;\n    prefix = defaultPrefix;\n  }\n\n  // prefix + local name\n  else if (parts.length === 2) {\n    localName = parts[1];\n    prefix = parts[0];\n  }\n\n  else {\n    throw new Error('expected <prefix:localName> or <localName>, got ' + name);\n  }\n\n  name = (prefix ? prefix + ':' : '') + localName;\n\n  return {\n    name: name,\n    prefix: prefix,\n    localName: localName\n  };\n}\n\n/**\n * A utility to build element descriptors.\n */\nfunction DescriptorBuilder(nameNs) {\n  this.ns = nameNs;\n  this.name = nameNs.name;\n  this.allTypes = [];\n  this.allTypesByName = {};\n  this.properties = [];\n  this.propertiesByName = {};\n}\n\n\nDescriptorBuilder.prototype.build = function() {\n  return (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.pick)(this, [\n    'ns',\n    'name',\n    'allTypes',\n    'allTypesByName',\n    'properties',\n    'propertiesByName',\n    'bodyProperty',\n    'idProperty'\n  ]);\n};\n\n/**\n * Add property at given index.\n *\n * @param {Object} p\n * @param {Number} [idx]\n * @param {Boolean} [validate=true]\n */\nDescriptorBuilder.prototype.addProperty = function(p, idx, validate) {\n\n  if (typeof idx === 'boolean') {\n    validate = idx;\n    idx = undefined;\n  }\n\n  this.addNamedProperty(p, validate !== false);\n\n  var properties = this.properties;\n\n  if (idx !== undefined) {\n    properties.splice(idx, 0, p);\n  } else {\n    properties.push(p);\n  }\n};\n\n\nDescriptorBuilder.prototype.replaceProperty = function(oldProperty, newProperty, replace) {\n  var oldNameNs = oldProperty.ns;\n\n  var props = this.properties,\n      propertiesByName = this.propertiesByName,\n      rename = oldProperty.name !== newProperty.name;\n\n  if (oldProperty.isId) {\n    if (!newProperty.isId) {\n      throw new Error(\n        'property <' + newProperty.ns.name + '> must be id property ' +\n        'to refine <' + oldProperty.ns.name + '>');\n    }\n\n    this.setIdProperty(newProperty, false);\n  }\n\n  if (oldProperty.isBody) {\n\n    if (!newProperty.isBody) {\n      throw new Error(\n        'property <' + newProperty.ns.name + '> must be body property ' +\n        'to refine <' + oldProperty.ns.name + '>');\n    }\n\n    // TODO: Check compatibility\n    this.setBodyProperty(newProperty, false);\n  }\n\n  // validate existence and get location of old property\n  var idx = props.indexOf(oldProperty);\n  if (idx === -1) {\n    throw new Error('property <' + oldNameNs.name + '> not found in property list');\n  }\n\n  // remove old property\n  props.splice(idx, 1);\n\n  // replacing the named property is intentional\n  //\n  //  * validate only if this is a \"rename\" operation\n  //  * add at specific index unless we \"replace\"\n  //\n  this.addProperty(newProperty, replace ? undefined : idx, rename);\n\n  // make new property available under old name\n  propertiesByName[oldNameNs.name] = propertiesByName[oldNameNs.localName] = newProperty;\n};\n\n\nDescriptorBuilder.prototype.redefineProperty = function(p, targetPropertyName, replace) {\n\n  var nsPrefix = p.ns.prefix;\n  var parts = targetPropertyName.split('#');\n\n  var name = parseName(parts[0], nsPrefix);\n  var attrName = parseName(parts[1], name.prefix).name;\n\n  var redefinedProperty = this.propertiesByName[attrName];\n  if (!redefinedProperty) {\n    throw new Error('refined property <' + attrName + '> not found');\n  } else {\n    this.replaceProperty(redefinedProperty, p, replace);\n  }\n\n  delete p.redefines;\n};\n\nDescriptorBuilder.prototype.addNamedProperty = function(p, validate) {\n  var ns = p.ns,\n      propsByName = this.propertiesByName;\n\n  if (validate) {\n    this.assertNotDefined(p, ns.name);\n    this.assertNotDefined(p, ns.localName);\n  }\n\n  propsByName[ns.name] = propsByName[ns.localName] = p;\n};\n\nDescriptorBuilder.prototype.removeNamedProperty = function(p) {\n  var ns = p.ns,\n      propsByName = this.propertiesByName;\n\n  delete propsByName[ns.name];\n  delete propsByName[ns.localName];\n};\n\nDescriptorBuilder.prototype.setBodyProperty = function(p, validate) {\n\n  if (validate && this.bodyProperty) {\n    throw new Error(\n      'body property defined multiple times ' +\n      '(<' + this.bodyProperty.ns.name + '>, <' + p.ns.name + '>)');\n  }\n\n  this.bodyProperty = p;\n};\n\nDescriptorBuilder.prototype.setIdProperty = function(p, validate) {\n\n  if (validate && this.idProperty) {\n    throw new Error(\n      'id property defined multiple times ' +\n      '(<' + this.idProperty.ns.name + '>, <' + p.ns.name + '>)');\n  }\n\n  this.idProperty = p;\n};\n\nDescriptorBuilder.prototype.assertNotTrait = function(typeDescriptor) {\n\n  const _extends = typeDescriptor.extends || [];\n\n  if (_extends.length) {\n    throw new Error(\n      `cannot create <${ typeDescriptor.name }> extending <${ typeDescriptor.extends }>`\n    );\n  }\n};\n\nDescriptorBuilder.prototype.assertNotDefined = function(p, name) {\n  var propertyName = p.name,\n      definedProperty = this.propertiesByName[propertyName];\n\n  if (definedProperty) {\n    throw new Error(\n      'property <' + propertyName + '> already defined; ' +\n      'override of <' + definedProperty.definedBy.ns.name + '#' + definedProperty.ns.name + '> by ' +\n      '<' + p.definedBy.ns.name + '#' + p.ns.name + '> not allowed without redefines');\n  }\n};\n\nDescriptorBuilder.prototype.hasProperty = function(name) {\n  return this.propertiesByName[name];\n};\n\nDescriptorBuilder.prototype.addTrait = function(t, inherited) {\n\n  if (inherited) {\n    this.assertNotTrait(t);\n  }\n\n  var typesByName = this.allTypesByName,\n      types = this.allTypes;\n\n  var typeName = t.name;\n\n  if (typeName in typesByName) {\n    return;\n  }\n\n  (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(t.properties, (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.bind)(function(p) {\n\n    // clone property to allow extensions\n    p = (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.assign)({}, p, {\n      name: p.ns.localName,\n      inherited: inherited\n    });\n\n    Object.defineProperty(p, 'definedBy', {\n      value: t\n    });\n\n    var replaces = p.replaces,\n        redefines = p.redefines;\n\n    // add replace/redefine support\n    if (replaces || redefines) {\n      this.redefineProperty(p, replaces || redefines, replaces);\n    } else {\n      if (p.isBody) {\n        this.setBodyProperty(p);\n      }\n      if (p.isId) {\n        this.setIdProperty(p);\n      }\n      this.addProperty(p);\n    }\n  }, this));\n\n  types.push(t);\n  typesByName[typeName] = t;\n};\n\n/**\n * A registry of Moddle packages.\n *\n * @param {Array<Package>} packages\n * @param {Properties} properties\n */\nfunction Registry(packages, properties) {\n  this.packageMap = {};\n  this.typeMap = {};\n\n  this.packages = [];\n\n  this.properties = properties;\n\n  (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(packages, (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.bind)(this.registerPackage, this));\n}\n\n\nRegistry.prototype.getPackage = function(uriOrPrefix) {\n  return this.packageMap[uriOrPrefix];\n};\n\nRegistry.prototype.getPackages = function() {\n  return this.packages;\n};\n\n\nRegistry.prototype.registerPackage = function(pkg) {\n\n  // copy package\n  pkg = (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.assign)({}, pkg);\n\n  var pkgMap = this.packageMap;\n\n  ensureAvailable(pkgMap, pkg, 'prefix');\n  ensureAvailable(pkgMap, pkg, 'uri');\n\n  // register types\n  (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(pkg.types, (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.bind)(function(descriptor) {\n    this.registerType(descriptor, pkg);\n  }, this));\n\n  pkgMap[pkg.uri] = pkgMap[pkg.prefix] = pkg;\n  this.packages.push(pkg);\n};\n\n\n/**\n * Register a type from a specific package with us\n */\nRegistry.prototype.registerType = function(type, pkg) {\n\n  type = (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.assign)({}, type, {\n    superClass: (type.superClass || []).slice(),\n    extends: (type.extends || []).slice(),\n    properties: (type.properties || []).slice(),\n    meta: (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.assign)((type.meta || {}))\n  });\n\n  var ns = parseName(type.name, pkg.prefix),\n      name = ns.name,\n      propertiesByName = {};\n\n  // parse properties\n  (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(type.properties, (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.bind)(function(p) {\n\n    // namespace property names\n    var propertyNs = parseName(p.name, ns.prefix),\n        propertyName = propertyNs.name;\n\n    // namespace property types\n    if (!isBuiltIn(p.type)) {\n      p.type = parseName(p.type, propertyNs.prefix).name;\n    }\n\n    (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.assign)(p, {\n      ns: propertyNs,\n      name: propertyName\n    });\n\n    propertiesByName[propertyName] = p;\n  }, this));\n\n  // update ns + name\n  (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.assign)(type, {\n    ns: ns,\n    name: name,\n    propertiesByName: propertiesByName\n  });\n\n  (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(type.extends, (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.bind)(function(extendsName) {\n    var extendsNameNs = parseName(extendsName, ns.prefix);\n\n    var extended = this.typeMap[extendsNameNs.name];\n\n    extended.traits = extended.traits || [];\n    extended.traits.push(name);\n  }, this));\n\n  // link to package\n  this.definePackage(type, pkg);\n\n  // register\n  this.typeMap[name] = type;\n};\n\n\n/**\n * Traverse the type hierarchy from bottom to top,\n * calling iterator with (type, inherited) for all elements in\n * the inheritance chain.\n *\n * @param {Object} nsName\n * @param {Function} iterator\n * @param {Boolean} [trait=false]\n */\nRegistry.prototype.mapTypes = function(nsName, iterator, trait) {\n\n  var type = isBuiltIn(nsName.name) ? { name: nsName.name } : this.typeMap[nsName.name];\n\n  var self = this;\n\n  /**\n   * Traverse the selected super type or trait\n   *\n   * @param {String} cls\n   * @param {Boolean} [trait=false]\n   */\n  function traverse(cls, trait) {\n    var parentNs = parseName(cls, isBuiltIn(cls) ? '' : nsName.prefix);\n    self.mapTypes(parentNs, iterator, trait);\n  }\n\n  /**\n   * Traverse the selected trait.\n   *\n   * @param {String} cls\n   */\n  function traverseTrait(cls) {\n    return traverse(cls, true);\n  }\n\n  /**\n   * Traverse the selected super type\n   *\n   * @param {String} cls\n   */\n  function traverseSuper(cls) {\n    return traverse(cls, false);\n  }\n\n  if (!type) {\n    throw new Error('unknown type <' + nsName.name + '>');\n  }\n\n  (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(type.superClass, trait ? traverseTrait : traverseSuper);\n\n  // call iterator with (type, inherited=!trait)\n  iterator(type, !trait);\n\n  (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(type.traits, traverseTrait);\n};\n\n\n/**\n * Returns the effective descriptor for a type.\n *\n * @param  {String} type the namespaced name (ns:localName) of the type\n *\n * @return {Descriptor} the resulting effective descriptor\n */\nRegistry.prototype.getEffectiveDescriptor = function(name) {\n\n  var nsName = parseName(name);\n\n  var builder = new DescriptorBuilder(nsName);\n\n  this.mapTypes(nsName, function(type, inherited) {\n    builder.addTrait(type, inherited);\n  });\n\n  var descriptor = builder.build();\n\n  // define package link\n  this.definePackage(descriptor, descriptor.allTypes[descriptor.allTypes.length - 1].$pkg);\n\n  return descriptor;\n};\n\n\nRegistry.prototype.definePackage = function(target, pkg) {\n  this.properties.define(target, '$pkg', { value: pkg });\n};\n\n\n\n// helpers ////////////////////////////\n\nfunction ensureAvailable(packageMap, pkg, identifierKey) {\n\n  var value = pkg[identifierKey];\n\n  if (value in packageMap) {\n    throw new Error('package with ' + identifierKey + ' <' + value + '> already defined');\n  }\n}\n\n/**\n * A utility that gets and sets properties of model elements.\n *\n * @param {Model} model\n */\nfunction Properties(model) {\n  this.model = model;\n}\n\n\n/**\n * Sets a named property on the target element.\n * If the value is undefined, the property gets deleted.\n *\n * @param {Object} target\n * @param {String} name\n * @param {Object} value\n */\nProperties.prototype.set = function(target, name, value) {\n\n  if (!(0,min_dash__WEBPACK_IMPORTED_MODULE_0__.isString)(name) || !name.length) {\n    throw new TypeError('property name must be a non-empty string');\n  }\n\n  var property = this.getProperty(target, name);\n\n  var propertyName = property && property.name;\n\n  if (isUndefined(value)) {\n\n    // unset the property, if the specified value is undefined;\n    // delete from $attrs (for extensions) or the target itself\n    if (property) {\n      delete target[propertyName];\n    } else {\n      delete target.$attrs[stripGlobal(name)];\n    }\n  } else {\n\n    // set the property, defining well defined properties on the fly\n    // or simply updating them in target.$attrs (for extensions)\n    if (property) {\n      if (propertyName in target) {\n        target[propertyName] = value;\n      } else {\n        defineProperty(target, property, value);\n      }\n    } else {\n      target.$attrs[stripGlobal(name)] = value;\n    }\n  }\n};\n\n/**\n * Returns the named property of the given element\n *\n * @param  {Object} target\n * @param  {String} name\n *\n * @return {Object}\n */\nProperties.prototype.get = function(target, name) {\n\n  var property = this.getProperty(target, name);\n\n  if (!property) {\n    return target.$attrs[stripGlobal(name)];\n  }\n\n  var propertyName = property.name;\n\n  // check if access to collection property and lazily initialize it\n  if (!target[propertyName] && property.isMany) {\n    defineProperty(target, property, []);\n  }\n\n  return target[propertyName];\n};\n\n\n/**\n * Define a property on the target element\n *\n * @param  {Object} target\n * @param  {String} name\n * @param  {Object} options\n */\nProperties.prototype.define = function(target, name, options) {\n\n  if (!options.writable) {\n\n    var value = options.value;\n\n    // use getters for read-only variables to support ES6 proxies\n    // cf. https://github.com/bpmn-io/internal-docs/issues/386\n    options = (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.assign)({}, options, {\n      get: function() { return value; }\n    });\n\n    delete options.value;\n  }\n\n  Object.defineProperty(target, name, options);\n};\n\n\n/**\n * Define the descriptor for an element\n */\nProperties.prototype.defineDescriptor = function(target, descriptor) {\n  this.define(target, '$descriptor', { value: descriptor });\n};\n\n/**\n * Define the model for an element\n */\nProperties.prototype.defineModel = function(target, model) {\n  this.define(target, '$model', { value: model });\n};\n\n/**\n * Return property with the given name on the element.\n *\n * @param {any} target\n * @param {string} name\n *\n * @return {object | null} property\n */\nProperties.prototype.getProperty = function(target, name) {\n\n  var model = this.model;\n\n  var property = model.getPropertyDescriptor(target, name);\n\n  if (property) {\n    return property;\n  }\n\n  if (name.includes(':')) {\n    return null;\n  }\n\n  const strict = model.config.strict;\n\n  if (typeof strict !== 'undefined') {\n    const error = new TypeError(`unknown property <${ name }> on <${ target.$type }>`);\n\n    if (strict) {\n      throw error;\n    } else {\n\n      // eslint-disable-next-line no-undef\n      typeof console !== 'undefined' && console.warn(error);\n    }\n  }\n\n  return null;\n};\n\nfunction isUndefined(val) {\n  return typeof val === 'undefined';\n}\n\nfunction defineProperty(target, property, value) {\n  Object.defineProperty(target, property.name, {\n    enumerable: !property.isReference,\n    writable: true,\n    value: value,\n    configurable: true\n  });\n}\n\nfunction stripGlobal(name) {\n  return name.replace(/^:/, '');\n}\n\n// Moddle implementation /////////////////////////////////////////////////\n\n/**\n * @class Moddle\n *\n * A model that can be used to create elements of a specific type.\n *\n * @example\n *\n * var Moddle = require('moddle');\n *\n * var pkg = {\n *   name: 'mypackage',\n *   prefix: 'my',\n *   types: [\n *     { name: 'Root' }\n *   ]\n * };\n *\n * var moddle = new Moddle([pkg]);\n *\n * @param {Array<Package>} packages the packages to contain\n *\n * @param { { strict?: boolean } } [config] moddle configuration\n */\nfunction Moddle(packages, config = {}) {\n\n  this.properties = new Properties(this);\n\n  this.factory = new Factory(this, this.properties);\n  this.registry = new Registry(packages, this.properties);\n\n  this.typeCache = {};\n\n  this.config = config;\n}\n\n\n/**\n * Create an instance of the specified type.\n *\n * @method Moddle#create\n *\n * @example\n *\n * var foo = moddle.create('my:Foo');\n * var bar = moddle.create('my:Bar', { id: 'BAR_1' });\n *\n * @param  {String|Object} descriptor the type descriptor or name know to the model\n * @param  {Object} attrs   a number of attributes to initialize the model instance with\n * @return {Object}         model instance\n */\nModdle.prototype.create = function(descriptor, attrs) {\n  var Type = this.getType(descriptor);\n\n  if (!Type) {\n    throw new Error('unknown type <' + descriptor + '>');\n  }\n\n  return new Type(attrs);\n};\n\n\n/**\n * Returns the type representing a given descriptor\n *\n * @method Moddle#getType\n *\n * @example\n *\n * var Foo = moddle.getType('my:Foo');\n * var foo = new Foo({ 'id' : 'FOO_1' });\n *\n * @param  {String|Object} descriptor the type descriptor or name know to the model\n * @return {Object}         the type representing the descriptor\n */\nModdle.prototype.getType = function(descriptor) {\n\n  var cache = this.typeCache;\n\n  var name = (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.isString)(descriptor) ? descriptor : descriptor.ns.name;\n\n  var type = cache[name];\n\n  if (!type) {\n    descriptor = this.registry.getEffectiveDescriptor(name);\n    type = cache[name] = this.factory.createType(descriptor);\n  }\n\n  return type;\n};\n\n\n/**\n * Creates an any-element type to be used within model instances.\n *\n * This can be used to create custom elements that lie outside the meta-model.\n * The created element contains all the meta-data required to serialize it\n * as part of meta-model elements.\n *\n * @method Moddle#createAny\n *\n * @example\n *\n * var foo = moddle.createAny('vendor:Foo', 'http://vendor', {\n *   value: 'bar'\n * });\n *\n * var container = moddle.create('my:Container', 'http://my', {\n *   any: [ foo ]\n * });\n *\n * // go ahead and serialize the stuff\n *\n *\n * @param  {String} name  the name of the element\n * @param  {String} nsUri the namespace uri of the element\n * @param  {Object} [properties] a map of properties to initialize the instance with\n * @return {Object} the any type instance\n */\nModdle.prototype.createAny = function(name, nsUri, properties) {\n\n  var nameNs = parseName(name);\n\n  var element = {\n    $type: name,\n    $instanceOf: function(type) {\n      return type === this.$type;\n    },\n    get: function(key) {\n      return this[key];\n    },\n    set: function(key, value) {\n      (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.set)(this, [ key ], value);\n    }\n  };\n\n  var descriptor = {\n    name: name,\n    isGeneric: true,\n    ns: {\n      prefix: nameNs.prefix,\n      localName: nameNs.localName,\n      uri: nsUri\n    }\n  };\n\n  this.properties.defineDescriptor(element, descriptor);\n  this.properties.defineModel(element, this);\n  this.properties.define(element, 'get', { enumerable: false, writable: true });\n  this.properties.define(element, 'set', { enumerable: false, writable: true });\n  this.properties.define(element, '$parent', { enumerable: false, writable: true });\n  this.properties.define(element, '$instanceOf', { enumerable: false, writable: true });\n\n  (0,min_dash__WEBPACK_IMPORTED_MODULE_0__.forEach)(properties, function(a, key) {\n    if ((0,min_dash__WEBPACK_IMPORTED_MODULE_0__.isObject)(a) && a.value !== undefined) {\n      element[a.name] = a.value;\n    } else {\n      element[key] = a;\n    }\n  });\n\n  return element;\n};\n\n/**\n * Returns a registered package by uri or prefix\n *\n * @return {Object} the package\n */\nModdle.prototype.getPackage = function(uriOrPrefix) {\n  return this.registry.getPackage(uriOrPrefix);\n};\n\n/**\n * Returns a snapshot of all known packages\n *\n * @return {Object} the package\n */\nModdle.prototype.getPackages = function() {\n  return this.registry.getPackages();\n};\n\n/**\n * Returns the descriptor for an element\n */\nModdle.prototype.getElementDescriptor = function(element) {\n  return element.$descriptor;\n};\n\n/**\n * Returns true if the given descriptor or instance\n * represents the given type.\n *\n * May be applied to this, if element is omitted.\n */\nModdle.prototype.hasType = function(element, type) {\n  if (type === undefined) {\n    type = element;\n    element = this;\n  }\n\n  var descriptor = element.$model.getElementDescriptor(element);\n\n  return (type in descriptor.allTypesByName);\n};\n\n/**\n * Returns the descriptor of an elements named property\n */\nModdle.prototype.getPropertyDescriptor = function(element, property) {\n  return this.getElementDescriptor(element).propertiesByName[property];\n};\n\n/**\n * Returns a mapped type's descriptor\n */\nModdle.prototype.getTypeDescriptor = function(type) {\n  return this.registry.typeMap[type];\n};\n\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9kZGxlL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQWdGOztBQUVoRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFlBQVk7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEVBQUUsaURBQU87QUFDVDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsK0JBQStCO0FBQ2pFLG1DQUFtQyxXQUFXO0FBQzlDLG9DQUFvQyxnQkFBZ0I7O0FBRXBELElBQUksaURBQU8sUUFBUSw4Q0FBSTtBQUN2QjtBQUNBLEtBQUs7QUFDTDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixXQUFXO0FBQ25DLHlCQUF5QixzQkFBc0I7QUFDL0MseUJBQXlCLHlCQUF5QjtBQUNsRCxzQkFBc0I7QUFDdEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FB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O0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRThHO0FBQzlHIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYnBtbi1zdHVkaW8td2ViLy4vbm9kZV9tb2R1bGVzL21vZGRsZS9kaXN0L2luZGV4LmpzPzg3Y2UiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZm9yRWFjaCwgYmluZCwgcGljaywgYXNzaWduLCBpc1N0cmluZywgaXNPYmplY3QsIHNldCB9IGZyb20gJ21pbi1kYXNoJztcblxuLyoqXG4gKiBNb2RkbGUgYmFzZSBlbGVtZW50LlxuICovXG5mdW5jdGlvbiBCYXNlKCkgeyB9XG5cbkJhc2UucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgcmV0dXJuIHRoaXMuJG1vZGVsLnByb3BlcnRpZXMuZ2V0KHRoaXMsIG5hbWUpO1xufTtcblxuQmFzZS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgdGhpcy4kbW9kZWwucHJvcGVydGllcy5zZXQodGhpcywgbmFtZSwgdmFsdWUpO1xufTtcblxuLyoqXG4gKiBBIG1vZGVsIGVsZW1lbnQgZmFjdG9yeS5cbiAqXG4gKiBAcGFyYW0ge01vZGRsZX0gbW9kZWxcbiAqIEBwYXJhbSB7UHJvcGVydGllc30gcHJvcGVydGllc1xuICovXG5mdW5jdGlvbiBGYWN0b3J5KG1vZGVsLCBwcm9wZXJ0aWVzKSB7XG4gIHRoaXMubW9kZWwgPSBtb2RlbDtcbiAgdGhpcy5wcm9wZXJ0aWVzID0gcHJvcGVydGllcztcbn1cblxuXG5GYWN0b3J5LnByb3RvdHlwZS5jcmVhdGVUeXBlID0gZnVuY3Rpb24oZGVzY3JpcHRvcikge1xuXG4gIHZhciBtb2RlbCA9IHRoaXMubW9kZWw7XG5cbiAgdmFyIHByb3BzID0gdGhpcy5wcm9wZXJ0aWVzLFxuICAgICAgcHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShCYXNlLnByb3RvdHlwZSk7XG5cbiAgLy8gaW5pdGlhbGl6ZSBkZWZhdWx0IHZhbHVlc1xuICBmb3JFYWNoKGRlc2NyaXB0b3IucHJvcGVydGllcywgZnVuY3Rpb24ocCkge1xuICAgIGlmICghcC5pc01hbnkgJiYgcC5kZWZhdWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHByb3RvdHlwZVtwLm5hbWVdID0gcC5kZWZhdWx0O1xuICAgIH1cbiAgfSk7XG5cbiAgcHJvcHMuZGVmaW5lTW9kZWwocHJvdG90eXBlLCBtb2RlbCk7XG4gIHByb3BzLmRlZmluZURlc2NyaXB0b3IocHJvdG90eXBlLCBkZXNjcmlwdG9yKTtcblxuICB2YXIgbmFtZSA9IGRlc2NyaXB0b3IubnMubmFtZTtcblxuICAvKipcbiAgICogVGhlIG5ldyB0eXBlIGNvbnN0cnVjdG9yXG4gICAqL1xuICBmdW5jdGlvbiBNb2RkbGVFbGVtZW50KGF0dHJzKSB7XG4gICAgcHJvcHMuZGVmaW5lKHRoaXMsICckdHlwZScsIHsgdmFsdWU6IG5hbWUsIGVudW1lcmFibGU6IHRydWUgfSk7XG4gICAgcHJvcHMuZGVmaW5lKHRoaXMsICckYXR0cnMnLCB7IHZhbHVlOiB7fSB9KTtcbiAgICBwcm9wcy5kZWZpbmUodGhpcywgJyRwYXJlbnQnLCB7IHdyaXRhYmxlOiB0cnVlIH0pO1xuXG4gICAgZm9yRWFjaChhdHRycywgYmluZChmdW5jdGlvbih2YWwsIGtleSkge1xuICAgICAgdGhpcy5zZXQoa2V5LCB2YWwpO1xuICAgIH0sIHRoaXMpKTtcbiAgfVxuXG4gIE1vZGRsZUVsZW1lbnQucHJvdG90eXBlID0gcHJvdG90eXBlO1xuXG4gIE1vZGRsZUVsZW1lbnQuaGFzVHlwZSA9IHByb3RvdHlwZS4kaW5zdGFuY2VPZiA9IHRoaXMubW9kZWwuaGFzVHlwZTtcblxuICAvLyBzdGF0aWMgbGlua3NcbiAgcHJvcHMuZGVmaW5lTW9kZWwoTW9kZGxlRWxlbWVudCwgbW9kZWwpO1xuICBwcm9wcy5kZWZpbmVEZXNjcmlwdG9yKE1vZGRsZUVsZW1lbnQsIGRlc2NyaXB0b3IpO1xuXG4gIHJldHVybiBNb2RkbGVFbGVtZW50O1xufTtcblxuLyoqXG4gKiBCdWlsdC1pbiBtb2RkbGUgdHlwZXNcbiAqL1xudmFyIEJVSUxUSU5TID0ge1xuICBTdHJpbmc6IHRydWUsXG4gIEJvb2xlYW46IHRydWUsXG4gIEludGVnZXI6IHRydWUsXG4gIFJlYWw6IHRydWUsXG4gIEVsZW1lbnQ6IHRydWVcbn07XG5cbi8qKlxuICogQ29udmVydGVycyBmb3IgYnVpbHQgaW4gdHlwZXMgZnJvbSBzdHJpbmcgcmVwcmVzZW50YXRpb25zXG4gKi9cbnZhciBUWVBFX0NPTlZFUlRFUlMgPSB7XG4gIFN0cmluZzogZnVuY3Rpb24ocykgeyByZXR1cm4gczsgfSxcbiAgQm9vbGVhbjogZnVuY3Rpb24ocykgeyByZXR1cm4gcyA9PT0gJ3RydWUnOyB9LFxuICBJbnRlZ2VyOiBmdW5jdGlvbihzKSB7IHJldHVybiBwYXJzZUludChzLCAxMCk7IH0sXG4gIFJlYWw6IGZ1bmN0aW9uKHMpIHsgcmV0dXJuIHBhcnNlRmxvYXQocyk7IH1cbn07XG5cbi8qKlxuICogQ29udmVydCBhIHR5cGUgdG8gaXRzIHJlYWwgcmVwcmVzZW50YXRpb25cbiAqL1xuZnVuY3Rpb24gY29lcmNlVHlwZSh0eXBlLCB2YWx1ZSkge1xuXG4gIHZhciBjb252ZXJ0ZXIgPSBUWVBFX0NPTlZFUlRFUlNbdHlwZV07XG5cbiAgaWYgKGNvbnZlcnRlcikge1xuICAgIHJldHVybiBjb252ZXJ0ZXIodmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxufVxuXG4vKipcbiAqIFJldHVybiB3aGV0aGVyIHRoZSBnaXZlbiB0eXBlIGlzIGJ1aWx0LWluXG4gKi9cbmZ1bmN0aW9uIGlzQnVpbHRJbih0eXBlKSB7XG4gIHJldHVybiAhIUJVSUxUSU5TW3R5cGVdO1xufVxuXG4vKipcbiAqIFJldHVybiB3aGV0aGVyIHRoZSBnaXZlbiB0eXBlIGlzIHNpbXBsZVxuICovXG5mdW5jdGlvbiBpc1NpbXBsZSh0eXBlKSB7XG4gIHJldHVybiAhIVRZUEVfQ09OVkVSVEVSU1t0eXBlXTtcbn1cblxuLyoqXG4gKiBQYXJzZXMgYSBuYW1lc3BhY2VkIGF0dHJpYnV0ZSBuYW1lIG9mIHRoZSBmb3JtIChuczopbG9jYWxOYW1lIHRvIGFuIG9iamVjdCxcbiAqIGdpdmVuIGEgZGVmYXVsdCBwcmVmaXggdG8gYXNzdW1lIGluIGNhc2Ugbm8gZXhwbGljaXQgbmFtZXNwYWNlIGlzIGdpdmVuLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0ge1N0cmluZ30gW2RlZmF1bHRQcmVmaXhdIHRoZSBkZWZhdWx0IHByZWZpeCB0byB0YWtlLCBpZiBub25lIGlzIHByZXNlbnQuXG4gKlxuICogQHJldHVybiB7T2JqZWN0fSB0aGUgcGFyc2VkIG5hbWVcbiAqL1xuZnVuY3Rpb24gcGFyc2VOYW1lKG5hbWUsIGRlZmF1bHRQcmVmaXgpIHtcbiAgdmFyIHBhcnRzID0gbmFtZS5zcGxpdCgvOi8pLFxuICAgICAgbG9jYWxOYW1lLCBwcmVmaXg7XG5cbiAgLy8gbm8gcHJlZml4IChpLmUuIG9ubHkgbG9jYWwgbmFtZSlcbiAgaWYgKHBhcnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIGxvY2FsTmFtZSA9IG5hbWU7XG4gICAgcHJlZml4ID0gZGVmYXVsdFByZWZpeDtcbiAgfVxuXG4gIC8vIHByZWZpeCArIGxvY2FsIG5hbWVcbiAgZWxzZSBpZiAocGFydHMubGVuZ3RoID09PSAyKSB7XG4gICAgbG9jYWxOYW1lID0gcGFydHNbMV07XG4gICAgcHJlZml4ID0gcGFydHNbMF07XG4gIH1cblxuICBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4cGVjdGVkIDxwcmVmaXg6bG9jYWxOYW1lPiBvciA8bG9jYWxOYW1lPiwgZ290ICcgKyBuYW1lKTtcbiAgfVxuXG4gIG5hbWUgPSAocHJlZml4ID8gcHJlZml4ICsgJzonIDogJycpICsgbG9jYWxOYW1lO1xuXG4gIHJldHVybiB7XG4gICAgbmFtZTogbmFtZSxcbiAgICBwcmVmaXg6IHByZWZpeCxcbiAgICBsb2NhbE5hbWU6IGxvY2FsTmFtZVxuICB9O1xufVxuXG4vKipcbiAqIEEgdXRpbGl0eSB0byBidWlsZCBlbGVtZW50IGRlc2NyaXB0b3JzLlxuICovXG5mdW5jdGlvbiBEZXNjcmlwdG9yQnVpbGRlcihuYW1lTnMpIHtcbiAgdGhpcy5ucyA9IG5hbWVOcztcbiAgdGhpcy5uYW1lID0gbmFtZU5zLm5hbWU7XG4gIHRoaXMuYWxsVHlwZXMgPSBbXTtcbiAgdGhpcy5hbGxUeXBlc0J5TmFtZSA9IHt9O1xuICB0aGlzLnByb3BlcnRpZXMgPSBbXTtcbiAgdGhpcy5wcm9wZXJ0aWVzQnlOYW1lID0ge307XG59XG5cblxuRGVzY3JpcHRvckJ1aWxkZXIucHJvdG90eXBlLmJ1aWxkID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBwaWNrKHRoaXMsIFtcbiAgICAnbnMnLFxuICAgICduYW1lJyxcbiAgICAnYWxsVHlwZXMnLFxuICAgICdhbGxUeXBlc0J5TmFtZScsXG4gICAgJ3Byb3BlcnRpZXMnLFxuICAgICdwcm9wZXJ0aWVzQnlOYW1lJyxcbiAgICAnYm9keVByb3BlcnR5JyxcbiAgICAnaWRQcm9wZXJ0eSdcbiAgXSk7XG59O1xuXG4vKipcbiAqIEFkZCBwcm9wZXJ0eSBhdCBnaXZlbiBpbmRleC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcFxuICogQHBhcmFtIHtOdW1iZXJ9IFtpZHhdXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFt2YWxpZGF0ZT10cnVlXVxuICovXG5EZXNjcmlwdG9yQnVpbGRlci5wcm90b3R5cGUuYWRkUHJvcGVydHkgPSBmdW5jdGlvbihwLCBpZHgsIHZhbGlkYXRlKSB7XG5cbiAgaWYgKHR5cGVvZiBpZHggPT09ICdib29sZWFuJykge1xuICAgIHZhbGlkYXRlID0gaWR4O1xuICAgIGlkeCA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIHRoaXMuYWRkTmFtZWRQcm9wZXJ0eShwLCB2YWxpZGF0ZSAhPT0gZmFsc2UpO1xuXG4gIHZhciBwcm9wZXJ0aWVzID0gdGhpcy5wcm9wZXJ0aWVzO1xuXG4gIGlmIChpZHggIT09IHVuZGVmaW5lZCkge1xuICAgIHByb3BlcnRpZXMuc3BsaWNlKGlkeCwgMCwgcCk7XG4gIH0gZWxzZSB7XG4gICAgcHJvcGVydGllcy5wdXNoKHApO1xuICB9XG59O1xuXG5cbkRlc2NyaXB0b3JCdWlsZGVyLnByb3RvdHlwZS5yZXBsYWNlUHJvcGVydHkgPSBmdW5jdGlvbihvbGRQcm9wZXJ0eSwgbmV3UHJvcGVydHksIHJlcGxhY2UpIHtcbiAgdmFyIG9sZE5hbWVOcyA9IG9sZFByb3BlcnR5Lm5zO1xuXG4gIHZhciBwcm9wcyA9IHRoaXMucHJvcGVydGllcyxcbiAgICAgIHByb3BlcnRpZXNCeU5hbWUgPSB0aGlzLnByb3BlcnRpZXNCeU5hbWUsXG4gICAgICByZW5hbWUgPSBvbGRQcm9wZXJ0eS5uYW1lICE9PSBuZXdQcm9wZXJ0eS5uYW1lO1xuXG4gIGlmIChvbGRQcm9wZXJ0eS5pc0lkKSB7XG4gICAgaWYgKCFuZXdQcm9wZXJ0eS5pc0lkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdwcm9wZXJ0eSA8JyArIG5ld1Byb3BlcnR5Lm5zLm5hbWUgKyAnPiBtdXN0IGJlIGlkIHByb3BlcnR5ICcgK1xuICAgICAgICAndG8gcmVmaW5lIDwnICsgb2xkUHJvcGVydHkubnMubmFtZSArICc+Jyk7XG4gICAgfVxuXG4gICAgdGhpcy5zZXRJZFByb3BlcnR5KG5ld1Byb3BlcnR5LCBmYWxzZSk7XG4gIH1cblxuICBpZiAob2xkUHJvcGVydHkuaXNCb2R5KSB7XG5cbiAgICBpZiAoIW5ld1Byb3BlcnR5LmlzQm9keSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAncHJvcGVydHkgPCcgKyBuZXdQcm9wZXJ0eS5ucy5uYW1lICsgJz4gbXVzdCBiZSBib2R5IHByb3BlcnR5ICcgK1xuICAgICAgICAndG8gcmVmaW5lIDwnICsgb2xkUHJvcGVydHkubnMubmFtZSArICc+Jyk7XG4gICAgfVxuXG4gICAgLy8gVE9ETzogQ2hlY2sgY29tcGF0aWJpbGl0eVxuICAgIHRoaXMuc2V0Qm9keVByb3BlcnR5KG5ld1Byb3BlcnR5LCBmYWxzZSk7XG4gIH1cblxuICAvLyB2YWxpZGF0ZSBleGlzdGVuY2UgYW5kIGdldCBsb2NhdGlvbiBvZiBvbGQgcHJvcGVydHlcbiAgdmFyIGlkeCA9IHByb3BzLmluZGV4T2Yob2xkUHJvcGVydHkpO1xuICBpZiAoaWR4ID09PSAtMSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvcGVydHkgPCcgKyBvbGROYW1lTnMubmFtZSArICc+IG5vdCBmb3VuZCBpbiBwcm9wZXJ0eSBsaXN0Jyk7XG4gIH1cblxuICAvLyByZW1vdmUgb2xkIHByb3BlcnR5XG4gIHByb3BzLnNwbGljZShpZHgsIDEpO1xuXG4gIC8vIHJlcGxhY2luZyB0aGUgbmFtZWQgcHJvcGVydHkgaXMgaW50ZW50aW9uYWxcbiAgLy9cbiAgLy8gICogdmFsaWRhdGUgb25seSBpZiB0aGlzIGlzIGEgXCJyZW5hbWVcIiBvcGVyYXRpb25cbiAgLy8gICogYWRkIGF0IHNwZWNpZmljIGluZGV4IHVubGVzcyB3ZSBcInJlcGxhY2VcIlxuICAvL1xuICB0aGlzLmFkZFByb3BlcnR5KG5ld1Byb3BlcnR5LCByZXBsYWNlID8gdW5kZWZpbmVkIDogaWR4LCByZW5hbWUpO1xuXG4gIC8vIG1ha2UgbmV3IHByb3BlcnR5IGF2YWlsYWJsZSB1bmRlciBvbGQgbmFtZVxuICBwcm9wZXJ0aWVzQnlOYW1lW29sZE5hbWVOcy5uYW1lXSA9IHByb3BlcnRpZXNCeU5hbWVbb2xkTmFtZU5zLmxvY2FsTmFtZV0gPSBuZXdQcm9wZXJ0eTtcbn07XG5cblxuRGVzY3JpcHRvckJ1aWxkZXIucHJvdG90eXBlLnJlZGVmaW5lUHJvcGVydHkgPSBmdW5jdGlvbihwLCB0YXJnZXRQcm9wZXJ0eU5hbWUsIHJlcGxhY2UpIHtcblxuICB2YXIgbnNQcmVmaXggPSBwLm5zLnByZWZpeDtcbiAgdmFyIHBhcnRzID0gdGFyZ2V0UHJvcGVydHlOYW1lLnNwbGl0KCcjJyk7XG5cbiAgdmFyIG5hbWUgPSBwYXJzZU5hbWUocGFydHNbMF0sIG5zUHJlZml4KTtcbiAgdmFyIGF0dHJOYW1lID0gcGFyc2VOYW1lKHBhcnRzWzFdLCBuYW1lLnByZWZpeCkubmFtZTtcblxuICB2YXIgcmVkZWZpbmVkUHJvcGVydHkgPSB0aGlzLnByb3BlcnRpZXNCeU5hbWVbYXR0ck5hbWVdO1xuICBpZiAoIXJlZGVmaW5lZFByb3BlcnR5KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdyZWZpbmVkIHByb3BlcnR5IDwnICsgYXR0ck5hbWUgKyAnPiBub3QgZm91bmQnKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnJlcGxhY2VQcm9wZXJ0eShyZWRlZmluZWRQcm9wZXJ0eSwgcCwgcmVwbGFjZSk7XG4gIH1cblxuICBkZWxldGUgcC5yZWRlZmluZXM7XG59O1xuXG5EZXNjcmlwdG9yQnVpbGRlci5wcm90b3R5cGUuYWRkTmFtZWRQcm9wZXJ0eSA9IGZ1bmN0aW9uKHAsIHZhbGlkYXRlKSB7XG4gIHZhciBucyA9IHAubnMsXG4gICAgICBwcm9wc0J5TmFtZSA9IHRoaXMucHJvcGVydGllc0J5TmFtZTtcblxuICBpZiAodmFsaWRhdGUpIHtcbiAgICB0aGlzLmFzc2VydE5vdERlZmluZWQocCwgbnMubmFtZSk7XG4gICAgdGhpcy5hc3NlcnROb3REZWZpbmVkKHAsIG5zLmxvY2FsTmFtZSk7XG4gIH1cblxuICBwcm9wc0J5TmFtZVtucy5uYW1lXSA9IHByb3BzQnlOYW1lW25zLmxvY2FsTmFtZV0gPSBwO1xufTtcblxuRGVzY3JpcHRvckJ1aWxkZXIucHJvdG90eXBlLnJlbW92ZU5hbWVkUHJvcGVydHkgPSBmdW5jdGlvbihwKSB7XG4gIHZhciBucyA9IHAubnMsXG4gICAgICBwcm9wc0J5TmFtZSA9IHRoaXMucHJvcGVydGllc0J5TmFtZTtcblxuICBkZWxldGUgcHJvcHNCeU5hbWVbbnMubmFtZV07XG4gIGRlbGV0ZSBwcm9wc0J5TmFtZVtucy5sb2NhbE5hbWVdO1xufTtcblxuRGVzY3JpcHRvckJ1aWxkZXIucHJvdG90eXBlLnNldEJvZHlQcm9wZXJ0eSA9IGZ1bmN0aW9uKHAsIHZhbGlkYXRlKSB7XG5cbiAgaWYgKHZhbGlkYXRlICYmIHRoaXMuYm9keVByb3BlcnR5KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ2JvZHkgcHJvcGVydHkgZGVmaW5lZCBtdWx0aXBsZSB0aW1lcyAnICtcbiAgICAgICcoPCcgKyB0aGlzLmJvZHlQcm9wZXJ0eS5ucy5uYW1lICsgJz4sIDwnICsgcC5ucy5uYW1lICsgJz4pJyk7XG4gIH1cblxuICB0aGlzLmJvZHlQcm9wZXJ0eSA9IHA7XG59O1xuXG5EZXNjcmlwdG9yQnVpbGRlci5wcm90b3R5cGUuc2V0SWRQcm9wZXJ0eSA9IGZ1bmN0aW9uKHAsIHZhbGlkYXRlKSB7XG5cbiAgaWYgKHZhbGlkYXRlICYmIHRoaXMuaWRQcm9wZXJ0eSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdpZCBwcm9wZXJ0eSBkZWZpbmVkIG11bHRpcGxlIHRpbWVzICcgK1xuICAgICAgJyg8JyArIHRoaXMuaWRQcm9wZXJ0eS5ucy5uYW1lICsgJz4sIDwnICsgcC5ucy5uYW1lICsgJz4pJyk7XG4gIH1cblxuICB0aGlzLmlkUHJvcGVydHkgPSBwO1xufTtcblxuRGVzY3JpcHRvckJ1aWxkZXIucHJvdG90eXBlLmFzc2VydE5vdFRyYWl0ID0gZnVuY3Rpb24odHlwZURlc2NyaXB0b3IpIHtcblxuICBjb25zdCBfZXh0ZW5kcyA9IHR5cGVEZXNjcmlwdG9yLmV4dGVuZHMgfHwgW107XG5cbiAgaWYgKF9leHRlbmRzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBjYW5ub3QgY3JlYXRlIDwkeyB0eXBlRGVzY3JpcHRvci5uYW1lIH0+IGV4dGVuZGluZyA8JHsgdHlwZURlc2NyaXB0b3IuZXh0ZW5kcyB9PmBcbiAgICApO1xuICB9XG59O1xuXG5EZXNjcmlwdG9yQnVpbGRlci5wcm90b3R5cGUuYXNzZXJ0Tm90RGVmaW5lZCA9IGZ1bmN0aW9uKHAsIG5hbWUpIHtcbiAgdmFyIHByb3BlcnR5TmFtZSA9IHAubmFtZSxcbiAgICAgIGRlZmluZWRQcm9wZXJ0eSA9IHRoaXMucHJvcGVydGllc0J5TmFtZVtwcm9wZXJ0eU5hbWVdO1xuXG4gIGlmIChkZWZpbmVkUHJvcGVydHkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAncHJvcGVydHkgPCcgKyBwcm9wZXJ0eU5hbWUgKyAnPiBhbHJlYWR5IGRlZmluZWQ7ICcgK1xuICAgICAgJ292ZXJyaWRlIG9mIDwnICsgZGVmaW5lZFByb3BlcnR5LmRlZmluZWRCeS5ucy5uYW1lICsgJyMnICsgZGVmaW5lZFByb3BlcnR5Lm5zLm5hbWUgKyAnPiBieSAnICtcbiAgICAgICc8JyArIHAuZGVmaW5lZEJ5Lm5zLm5hbWUgKyAnIycgKyBwLm5zLm5hbWUgKyAnPiBub3QgYWxsb3dlZCB3aXRob3V0IHJlZGVmaW5lcycpO1xuICB9XG59O1xuXG5EZXNjcmlwdG9yQnVpbGRlci5wcm90b3R5cGUuaGFzUHJvcGVydHkgPSBmdW5jdGlvbihuYW1lKSB7XG4gIHJldHVybiB0aGlzLnByb3BlcnRpZXNCeU5hbWVbbmFtZV07XG59O1xuXG5EZXNjcmlwdG9yQnVpbGRlci5wcm90b3R5cGUuYWRkVHJhaXQgPSBmdW5jdGlvbih0LCBpbmhlcml0ZWQpIHtcblxuICBpZiAoaW5oZXJpdGVkKSB7XG4gICAgdGhpcy5hc3NlcnROb3RUcmFpdCh0KTtcbiAgfVxuXG4gIHZhciB0eXBlc0J5TmFtZSA9IHRoaXMuYWxsVHlwZXNCeU5hbWUsXG4gICAgICB0eXBlcyA9IHRoaXMuYWxsVHlwZXM7XG5cbiAgdmFyIHR5cGVOYW1lID0gdC5uYW1lO1xuXG4gIGlmICh0eXBlTmFtZSBpbiB0eXBlc0J5TmFtZSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGZvckVhY2godC5wcm9wZXJ0aWVzLCBiaW5kKGZ1bmN0aW9uKHApIHtcblxuICAgIC8vIGNsb25lIHByb3BlcnR5IHRvIGFsbG93IGV4dGVuc2lvbnNcbiAgICBwID0gYXNzaWduKHt9LCBwLCB7XG4gICAgICBuYW1lOiBwLm5zLmxvY2FsTmFtZSxcbiAgICAgIGluaGVyaXRlZDogaW5oZXJpdGVkXG4gICAgfSk7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocCwgJ2RlZmluZWRCeScsIHtcbiAgICAgIHZhbHVlOiB0XG4gICAgfSk7XG5cbiAgICB2YXIgcmVwbGFjZXMgPSBwLnJlcGxhY2VzLFxuICAgICAgICByZWRlZmluZXMgPSBwLnJlZGVmaW5lcztcblxuICAgIC8vIGFkZCByZXBsYWNlL3JlZGVmaW5lIHN1cHBvcnRcbiAgICBpZiAocmVwbGFjZXMgfHwgcmVkZWZpbmVzKSB7XG4gICAgICB0aGlzLnJlZGVmaW5lUHJvcGVydHkocCwgcmVwbGFjZXMgfHwgcmVkZWZpbmVzLCByZXBsYWNlcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChwLmlzQm9keSkge1xuICAgICAgICB0aGlzLnNldEJvZHlQcm9wZXJ0eShwKTtcbiAgICAgIH1cbiAgICAgIGlmIChwLmlzSWQpIHtcbiAgICAgICAgdGhpcy5zZXRJZFByb3BlcnR5KHApO1xuICAgICAgfVxuICAgICAgdGhpcy5hZGRQcm9wZXJ0eShwKTtcbiAgICB9XG4gIH0sIHRoaXMpKTtcblxuICB0eXBlcy5wdXNoKHQpO1xuICB0eXBlc0J5TmFtZVt0eXBlTmFtZV0gPSB0O1xufTtcblxuLyoqXG4gKiBBIHJlZ2lzdHJ5IG9mIE1vZGRsZSBwYWNrYWdlcy5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PFBhY2thZ2U+fSBwYWNrYWdlc1xuICogQHBhcmFtIHtQcm9wZXJ0aWVzfSBwcm9wZXJ0aWVzXG4gKi9cbmZ1bmN0aW9uIFJlZ2lzdHJ5KHBhY2thZ2VzLCBwcm9wZXJ0aWVzKSB7XG4gIHRoaXMucGFja2FnZU1hcCA9IHt9O1xuICB0aGlzLnR5cGVNYXAgPSB7fTtcblxuICB0aGlzLnBhY2thZ2VzID0gW107XG5cbiAgdGhpcy5wcm9wZXJ0aWVzID0gcHJvcGVydGllcztcblxuICBmb3JFYWNoKHBhY2thZ2VzLCBiaW5kKHRoaXMucmVnaXN0ZXJQYWNrYWdlLCB0aGlzKSk7XG59XG5cblxuUmVnaXN0cnkucHJvdG90eXBlLmdldFBhY2thZ2UgPSBmdW5jdGlvbih1cmlPclByZWZpeCkge1xuICByZXR1cm4gdGhpcy5wYWNrYWdlTWFwW3VyaU9yUHJlZml4XTtcbn07XG5cblJlZ2lzdHJ5LnByb3RvdHlwZS5nZXRQYWNrYWdlcyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5wYWNrYWdlcztcbn07XG5cblxuUmVnaXN0cnkucHJvdG90eXBlLnJlZ2lzdGVyUGFja2FnZSA9IGZ1bmN0aW9uKHBrZykge1xuXG4gIC8vIGNvcHkgcGFja2FnZVxuICBwa2cgPSBhc3NpZ24oe30sIHBrZyk7XG5cbiAgdmFyIHBrZ01hcCA9IHRoaXMucGFja2FnZU1hcDtcblxuICBlbnN1cmVBdmFpbGFibGUocGtnTWFwLCBwa2csICdwcmVmaXgnKTtcbiAgZW5zdXJlQXZhaWxhYmxlKHBrZ01hcCwgcGtnLCAndXJpJyk7XG5cbiAgLy8gcmVnaXN0ZXIgdHlwZXNcbiAgZm9yRWFjaChwa2cudHlwZXMsIGJpbmQoZnVuY3Rpb24oZGVzY3JpcHRvcikge1xuICAgIHRoaXMucmVnaXN0ZXJUeXBlKGRlc2NyaXB0b3IsIHBrZyk7XG4gIH0sIHRoaXMpKTtcblxuICBwa2dNYXBbcGtnLnVyaV0gPSBwa2dNYXBbcGtnLnByZWZpeF0gPSBwa2c7XG4gIHRoaXMucGFja2FnZXMucHVzaChwa2cpO1xufTtcblxuXG4vKipcbiAqIFJlZ2lzdGVyIGEgdHlwZSBmcm9tIGEgc3BlY2lmaWMgcGFja2FnZSB3aXRoIHVzXG4gKi9cblJlZ2lzdHJ5LnByb3RvdHlwZS5yZWdpc3RlclR5cGUgPSBmdW5jdGlvbih0eXBlLCBwa2cpIHtcblxuICB0eXBlID0gYXNzaWduKHt9LCB0eXBlLCB7XG4gICAgc3VwZXJDbGFzczogKHR5cGUuc3VwZXJDbGFzcyB8fCBbXSkuc2xpY2UoKSxcbiAgICBleHRlbmRzOiAodHlwZS5leHRlbmRzIHx8IFtdKS5zbGljZSgpLFxuICAgIHByb3BlcnRpZXM6ICh0eXBlLnByb3BlcnRpZXMgfHwgW10pLnNsaWNlKCksXG4gICAgbWV0YTogYXNzaWduKCh0eXBlLm1ldGEgfHwge30pKVxuICB9KTtcblxuICB2YXIgbnMgPSBwYXJzZU5hbWUodHlwZS5uYW1lLCBwa2cucHJlZml4KSxcbiAgICAgIG5hbWUgPSBucy5uYW1lLFxuICAgICAgcHJvcGVydGllc0J5TmFtZSA9IHt9O1xuXG4gIC8vIHBhcnNlIHByb3BlcnRpZXNcbiAgZm9yRWFjaCh0eXBlLnByb3BlcnRpZXMsIGJpbmQoZnVuY3Rpb24ocCkge1xuXG4gICAgLy8gbmFtZXNwYWNlIHByb3BlcnR5IG5hbWVzXG4gICAgdmFyIHByb3BlcnR5TnMgPSBwYXJzZU5hbWUocC5uYW1lLCBucy5wcmVmaXgpLFxuICAgICAgICBwcm9wZXJ0eU5hbWUgPSBwcm9wZXJ0eU5zLm5hbWU7XG5cbiAgICAvLyBuYW1lc3BhY2UgcHJvcGVydHkgdHlwZXNcbiAgICBpZiAoIWlzQnVpbHRJbihwLnR5cGUpKSB7XG4gICAgICBwLnR5cGUgPSBwYXJzZU5hbWUocC50eXBlLCBwcm9wZXJ0eU5zLnByZWZpeCkubmFtZTtcbiAgICB9XG5cbiAgICBhc3NpZ24ocCwge1xuICAgICAgbnM6IHByb3BlcnR5TnMsXG4gICAgICBuYW1lOiBwcm9wZXJ0eU5hbWVcbiAgICB9KTtcblxuICAgIHByb3BlcnRpZXNCeU5hbWVbcHJvcGVydHlOYW1lXSA9IHA7XG4gIH0sIHRoaXMpKTtcblxuICAvLyB1cGRhdGUgbnMgKyBuYW1lXG4gIGFzc2lnbih0eXBlLCB7XG4gICAgbnM6IG5zLFxuICAgIG5hbWU6IG5hbWUsXG4gICAgcHJvcGVydGllc0J5TmFtZTogcHJvcGVydGllc0J5TmFtZVxuICB9KTtcblxuICBmb3JFYWNoKHR5cGUuZXh0ZW5kcywgYmluZChmdW5jdGlvbihleHRlbmRzTmFtZSkge1xuICAgIHZhciBleHRlbmRzTmFtZU5zID0gcGFyc2VOYW1lKGV4dGVuZHNOYW1lLCBucy5wcmVmaXgpO1xuXG4gICAgdmFyIGV4dGVuZGVkID0gdGhpcy50eXBlTWFwW2V4dGVuZHNOYW1lTnMubmFtZV07XG5cbiAgICBleHRlbmRlZC50cmFpdHMgPSBleHRlbmRlZC50cmFpdHMgfHwgW107XG4gICAgZXh0ZW5kZWQudHJhaXRzLnB1c2gobmFtZSk7XG4gIH0sIHRoaXMpKTtcblxuICAvLyBsaW5rIHRvIHBhY2thZ2VcbiAgdGhpcy5kZWZpbmVQYWNrYWdlKHR5cGUsIHBrZyk7XG5cbiAgLy8gcmVnaXN0ZXJcbiAgdGhpcy50eXBlTWFwW25hbWVdID0gdHlwZTtcbn07XG5cblxuLyoqXG4gKiBUcmF2ZXJzZSB0aGUgdHlwZSBoaWVyYXJjaHkgZnJvbSBib3R0b20gdG8gdG9wLFxuICogY2FsbGluZyBpdGVyYXRvciB3aXRoICh0eXBlLCBpbmhlcml0ZWQpIGZvciBhbGwgZWxlbWVudHMgaW5cbiAqIHRoZSBpbmhlcml0YW5jZSBjaGFpbi5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gbnNOYW1lXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRvclxuICogQHBhcmFtIHtCb29sZWFufSBbdHJhaXQ9ZmFsc2VdXG4gKi9cblJlZ2lzdHJ5LnByb3RvdHlwZS5tYXBUeXBlcyA9IGZ1bmN0aW9uKG5zTmFtZSwgaXRlcmF0b3IsIHRyYWl0KSB7XG5cbiAgdmFyIHR5cGUgPSBpc0J1aWx0SW4obnNOYW1lLm5hbWUpID8geyBuYW1lOiBuc05hbWUubmFtZSB9IDogdGhpcy50eXBlTWFwW25zTmFtZS5uYW1lXTtcblxuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgLyoqXG4gICAqIFRyYXZlcnNlIHRoZSBzZWxlY3RlZCBzdXBlciB0eXBlIG9yIHRyYWl0XG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBjbHNcbiAgICogQHBhcmFtIHtCb29sZWFufSBbdHJhaXQ9ZmFsc2VdXG4gICAqL1xuICBmdW5jdGlvbiB0cmF2ZXJzZShjbHMsIHRyYWl0KSB7XG4gICAgdmFyIHBhcmVudE5zID0gcGFyc2VOYW1lKGNscywgaXNCdWlsdEluKGNscykgPyAnJyA6IG5zTmFtZS5wcmVmaXgpO1xuICAgIHNlbGYubWFwVHlwZXMocGFyZW50TnMsIGl0ZXJhdG9yLCB0cmFpdCk7XG4gIH1cblxuICAvKipcbiAgICogVHJhdmVyc2UgdGhlIHNlbGVjdGVkIHRyYWl0LlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gY2xzXG4gICAqL1xuICBmdW5jdGlvbiB0cmF2ZXJzZVRyYWl0KGNscykge1xuICAgIHJldHVybiB0cmF2ZXJzZShjbHMsIHRydWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRyYXZlcnNlIHRoZSBzZWxlY3RlZCBzdXBlciB0eXBlXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBjbHNcbiAgICovXG4gIGZ1bmN0aW9uIHRyYXZlcnNlU3VwZXIoY2xzKSB7XG4gICAgcmV0dXJuIHRyYXZlcnNlKGNscywgZmFsc2UpO1xuICB9XG5cbiAgaWYgKCF0eXBlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCd1bmtub3duIHR5cGUgPCcgKyBuc05hbWUubmFtZSArICc+Jyk7XG4gIH1cblxuICBmb3JFYWNoKHR5cGUuc3VwZXJDbGFzcywgdHJhaXQgPyB0cmF2ZXJzZVRyYWl0IDogdHJhdmVyc2VTdXBlcik7XG5cbiAgLy8gY2FsbCBpdGVyYXRvciB3aXRoICh0eXBlLCBpbmhlcml0ZWQ9IXRyYWl0KVxuICBpdGVyYXRvcih0eXBlLCAhdHJhaXQpO1xuXG4gIGZvckVhY2godHlwZS50cmFpdHMsIHRyYXZlcnNlVHJhaXQpO1xufTtcblxuXG4vKipcbiAqIFJldHVybnMgdGhlIGVmZmVjdGl2ZSBkZXNjcmlwdG9yIGZvciBhIHR5cGUuXG4gKlxuICogQHBhcmFtICB7U3RyaW5nfSB0eXBlIHRoZSBuYW1lc3BhY2VkIG5hbWUgKG5zOmxvY2FsTmFtZSkgb2YgdGhlIHR5cGVcbiAqXG4gKiBAcmV0dXJuIHtEZXNjcmlwdG9yfSB0aGUgcmVzdWx0aW5nIGVmZmVjdGl2ZSBkZXNjcmlwdG9yXG4gKi9cblJlZ2lzdHJ5LnByb3RvdHlwZS5nZXRFZmZlY3RpdmVEZXNjcmlwdG9yID0gZnVuY3Rpb24obmFtZSkge1xuXG4gIHZhciBuc05hbWUgPSBwYXJzZU5hbWUobmFtZSk7XG5cbiAgdmFyIGJ1aWxkZXIgPSBuZXcgRGVzY3JpcHRvckJ1aWxkZXIobnNOYW1lKTtcblxuICB0aGlzLm1hcFR5cGVzKG5zTmFtZSwgZnVuY3Rpb24odHlwZSwgaW5oZXJpdGVkKSB7XG4gICAgYnVpbGRlci5hZGRUcmFpdCh0eXBlLCBpbmhlcml0ZWQpO1xuICB9KTtcblxuICB2YXIgZGVzY3JpcHRvciA9IGJ1aWxkZXIuYnVpbGQoKTtcblxuICAvLyBkZWZpbmUgcGFja2FnZSBsaW5rXG4gIHRoaXMuZGVmaW5lUGFja2FnZShkZXNjcmlwdG9yLCBkZXNjcmlwdG9yLmFsbFR5cGVzW2Rlc2NyaXB0b3IuYWxsVHlwZXMubGVuZ3RoIC0gMV0uJHBrZyk7XG5cbiAgcmV0dXJuIGRlc2NyaXB0b3I7XG59O1xuXG5cblJlZ2lzdHJ5LnByb3RvdHlwZS5kZWZpbmVQYWNrYWdlID0gZnVuY3Rpb24odGFyZ2V0LCBwa2cpIHtcbiAgdGhpcy5wcm9wZXJ0aWVzLmRlZmluZSh0YXJnZXQsICckcGtnJywgeyB2YWx1ZTogcGtnIH0pO1xufTtcblxuXG5cbi8vIGhlbHBlcnMgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG5mdW5jdGlvbiBlbnN1cmVBdmFpbGFibGUocGFja2FnZU1hcCwgcGtnLCBpZGVudGlmaWVyS2V5KSB7XG5cbiAgdmFyIHZhbHVlID0gcGtnW2lkZW50aWZpZXJLZXldO1xuXG4gIGlmICh2YWx1ZSBpbiBwYWNrYWdlTWFwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwYWNrYWdlIHdpdGggJyArIGlkZW50aWZpZXJLZXkgKyAnIDwnICsgdmFsdWUgKyAnPiBhbHJlYWR5IGRlZmluZWQnKTtcbiAgfVxufVxuXG4vKipcbiAqIEEgdXRpbGl0eSB0aGF0IGdldHMgYW5kIHNldHMgcHJvcGVydGllcyBvZiBtb2RlbCBlbGVtZW50cy5cbiAqXG4gKiBAcGFyYW0ge01vZGVsfSBtb2RlbFxuICovXG5mdW5jdGlvbiBQcm9wZXJ0aWVzKG1vZGVsKSB7XG4gIHRoaXMubW9kZWwgPSBtb2RlbDtcbn1cblxuXG4vKipcbiAqIFNldHMgYSBuYW1lZCBwcm9wZXJ0eSBvbiB0aGUgdGFyZ2V0IGVsZW1lbnQuXG4gKiBJZiB0aGUgdmFsdWUgaXMgdW5kZWZpbmVkLCB0aGUgcHJvcGVydHkgZ2V0cyBkZWxldGVkLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXRcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsdWVcbiAqL1xuUHJvcGVydGllcy5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24odGFyZ2V0LCBuYW1lLCB2YWx1ZSkge1xuXG4gIGlmICghaXNTdHJpbmcobmFtZSkgfHwgIW5hbWUubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcigncHJvcGVydHkgbmFtZSBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZycpO1xuICB9XG5cbiAgdmFyIHByb3BlcnR5ID0gdGhpcy5nZXRQcm9wZXJ0eSh0YXJnZXQsIG5hbWUpO1xuXG4gIHZhciBwcm9wZXJ0eU5hbWUgPSBwcm9wZXJ0eSAmJiBwcm9wZXJ0eS5uYW1lO1xuXG4gIGlmIChpc1VuZGVmaW5lZCh2YWx1ZSkpIHtcblxuICAgIC8vIHVuc2V0IHRoZSBwcm9wZXJ0eSwgaWYgdGhlIHNwZWNpZmllZCB2YWx1ZSBpcyB1bmRlZmluZWQ7XG4gICAgLy8gZGVsZXRlIGZyb20gJGF0dHJzIChmb3IgZXh0ZW5zaW9ucykgb3IgdGhlIHRhcmdldCBpdHNlbGZcbiAgICBpZiAocHJvcGVydHkpIHtcbiAgICAgIGRlbGV0ZSB0YXJnZXRbcHJvcGVydHlOYW1lXTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRlIHRhcmdldC4kYXR0cnNbc3RyaXBHbG9iYWwobmFtZSldO1xuICAgIH1cbiAgfSBlbHNlIHtcblxuICAgIC8vIHNldCB0aGUgcHJvcGVydHksIGRlZmluaW5nIHdlbGwgZGVmaW5lZCBwcm9wZXJ0aWVzIG9uIHRoZSBmbHlcbiAgICAvLyBvciBzaW1wbHkgdXBkYXRpbmcgdGhlbSBpbiB0YXJnZXQuJGF0dHJzIChmb3IgZXh0ZW5zaW9ucylcbiAgICBpZiAocHJvcGVydHkpIHtcbiAgICAgIGlmIChwcm9wZXJ0eU5hbWUgaW4gdGFyZ2V0KSB7XG4gICAgICAgIHRhcmdldFtwcm9wZXJ0eU5hbWVdID0gdmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIHByb3BlcnR5LCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRhcmdldC4kYXR0cnNbc3RyaXBHbG9iYWwobmFtZSldID0gdmFsdWU7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIG5hbWVkIHByb3BlcnR5IG9mIHRoZSBnaXZlbiBlbGVtZW50XG4gKlxuICogQHBhcmFtICB7T2JqZWN0fSB0YXJnZXRcbiAqIEBwYXJhbSAge1N0cmluZ30gbmFtZVxuICpcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuUHJvcGVydGllcy5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24odGFyZ2V0LCBuYW1lKSB7XG5cbiAgdmFyIHByb3BlcnR5ID0gdGhpcy5nZXRQcm9wZXJ0eSh0YXJnZXQsIG5hbWUpO1xuXG4gIGlmICghcHJvcGVydHkpIHtcbiAgICByZXR1cm4gdGFyZ2V0LiRhdHRyc1tzdHJpcEdsb2JhbChuYW1lKV07XG4gIH1cblxuICB2YXIgcHJvcGVydHlOYW1lID0gcHJvcGVydHkubmFtZTtcblxuICAvLyBjaGVjayBpZiBhY2Nlc3MgdG8gY29sbGVjdGlvbiBwcm9wZXJ0eSBhbmQgbGF6aWx5IGluaXRpYWxpemUgaXRcbiAgaWYgKCF0YXJnZXRbcHJvcGVydHlOYW1lXSAmJiBwcm9wZXJ0eS5pc01hbnkpIHtcbiAgICBkZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIHByb3BlcnR5LCBbXSk7XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0W3Byb3BlcnR5TmFtZV07XG59O1xuXG5cbi8qKlxuICogRGVmaW5lIGEgcHJvcGVydHkgb24gdGhlIHRhcmdldCBlbGVtZW50XG4gKlxuICogQHBhcmFtICB7T2JqZWN0fSB0YXJnZXRcbiAqIEBwYXJhbSAge1N0cmluZ30gbmFtZVxuICogQHBhcmFtICB7T2JqZWN0fSBvcHRpb25zXG4gKi9cblByb3BlcnRpZXMucHJvdG90eXBlLmRlZmluZSA9IGZ1bmN0aW9uKHRhcmdldCwgbmFtZSwgb3B0aW9ucykge1xuXG4gIGlmICghb3B0aW9ucy53cml0YWJsZSkge1xuXG4gICAgdmFyIHZhbHVlID0gb3B0aW9ucy52YWx1ZTtcblxuICAgIC8vIHVzZSBnZXR0ZXJzIGZvciByZWFkLW9ubHkgdmFyaWFibGVzIHRvIHN1cHBvcnQgRVM2IHByb3hpZXNcbiAgICAvLyBjZi4gaHR0cHM6Ly9naXRodWIuY29tL2JwbW4taW8vaW50ZXJuYWwtZG9jcy9pc3N1ZXMvMzg2XG4gICAgb3B0aW9ucyA9IGFzc2lnbih7fSwgb3B0aW9ucywge1xuICAgICAgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIHZhbHVlOyB9XG4gICAgfSk7XG5cbiAgICBkZWxldGUgb3B0aW9ucy52YWx1ZTtcbiAgfVxuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIG5hbWUsIG9wdGlvbnMpO1xufTtcblxuXG4vKipcbiAqIERlZmluZSB0aGUgZGVzY3JpcHRvciBmb3IgYW4gZWxlbWVudFxuICovXG5Qcm9wZXJ0aWVzLnByb3RvdHlwZS5kZWZpbmVEZXNjcmlwdG9yID0gZnVuY3Rpb24odGFyZ2V0LCBkZXNjcmlwdG9yKSB7XG4gIHRoaXMuZGVmaW5lKHRhcmdldCwgJyRkZXNjcmlwdG9yJywgeyB2YWx1ZTogZGVzY3JpcHRvciB9KTtcbn07XG5cbi8qKlxuICogRGVmaW5lIHRoZSBtb2RlbCBmb3IgYW4gZWxlbWVudFxuICovXG5Qcm9wZXJ0aWVzLnByb3RvdHlwZS5kZWZpbmVNb2RlbCA9IGZ1bmN0aW9uKHRhcmdldCwgbW9kZWwpIHtcbiAgdGhpcy5kZWZpbmUodGFyZ2V0LCAnJG1vZGVsJywgeyB2YWx1ZTogbW9kZWwgfSk7XG59O1xuXG4vKipcbiAqIFJldHVybiBwcm9wZXJ0eSB3aXRoIHRoZSBnaXZlbiBuYW1lIG9uIHRoZSBlbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7YW55fSB0YXJnZXRcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKlxuICogQHJldHVybiB7b2JqZWN0IHwgbnVsbH0gcHJvcGVydHlcbiAqL1xuUHJvcGVydGllcy5wcm90b3R5cGUuZ2V0UHJvcGVydHkgPSBmdW5jdGlvbih0YXJnZXQsIG5hbWUpIHtcblxuICB2YXIgbW9kZWwgPSB0aGlzLm1vZGVsO1xuXG4gIHZhciBwcm9wZXJ0eSA9IG1vZGVsLmdldFByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIG5hbWUpO1xuXG4gIGlmIChwcm9wZXJ0eSkge1xuICAgIHJldHVybiBwcm9wZXJ0eTtcbiAgfVxuXG4gIGlmIChuYW1lLmluY2x1ZGVzKCc6JykpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGNvbnN0IHN0cmljdCA9IG1vZGVsLmNvbmZpZy5zdHJpY3Q7XG5cbiAgaWYgKHR5cGVvZiBzdHJpY3QgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgY29uc3QgZXJyb3IgPSBuZXcgVHlwZUVycm9yKGB1bmtub3duIHByb3BlcnR5IDwkeyBuYW1lIH0+IG9uIDwkeyB0YXJnZXQuJHR5cGUgfT5gKTtcblxuICAgIGlmIChzdHJpY3QpIHtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH0gZWxzZSB7XG5cbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuICAgICAgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmIGNvbnNvbGUud2FybihlcnJvcik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59O1xuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZCh2YWwpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICd1bmRlZmluZWQnO1xufVxuXG5mdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIHByb3BlcnR5LCB2YWx1ZSkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBwcm9wZXJ0eS5uYW1lLCB7XG4gICAgZW51bWVyYWJsZTogIXByb3BlcnR5LmlzUmVmZXJlbmNlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiB2YWx1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHN0cmlwR2xvYmFsKG5hbWUpIHtcbiAgcmV0dXJuIG5hbWUucmVwbGFjZSgvXjovLCAnJyk7XG59XG5cbi8vIE1vZGRsZSBpbXBsZW1lbnRhdGlvbiAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbi8qKlxuICogQGNsYXNzIE1vZGRsZVxuICpcbiAqIEEgbW9kZWwgdGhhdCBjYW4gYmUgdXNlZCB0byBjcmVhdGUgZWxlbWVudHMgb2YgYSBzcGVjaWZpYyB0eXBlLlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIE1vZGRsZSA9IHJlcXVpcmUoJ21vZGRsZScpO1xuICpcbiAqIHZhciBwa2cgPSB7XG4gKiAgIG5hbWU6ICdteXBhY2thZ2UnLFxuICogICBwcmVmaXg6ICdteScsXG4gKiAgIHR5cGVzOiBbXG4gKiAgICAgeyBuYW1lOiAnUm9vdCcgfVxuICogICBdXG4gKiB9O1xuICpcbiAqIHZhciBtb2RkbGUgPSBuZXcgTW9kZGxlKFtwa2ddKTtcbiAqXG4gKiBAcGFyYW0ge0FycmF5PFBhY2thZ2U+fSBwYWNrYWdlcyB0aGUgcGFja2FnZXMgdG8gY29udGFpblxuICpcbiAqIEBwYXJhbSB7IHsgc3RyaWN0PzogYm9vbGVhbiB9IH0gW2NvbmZpZ10gbW9kZGxlIGNvbmZpZ3VyYXRpb25cbiAqL1xuZnVuY3Rpb24gTW9kZGxlKHBhY2thZ2VzLCBjb25maWcgPSB7fSkge1xuXG4gIHRoaXMucHJvcGVydGllcyA9IG5ldyBQcm9wZXJ0aWVzKHRoaXMpO1xuXG4gIHRoaXMuZmFjdG9yeSA9IG5ldyBGYWN0b3J5KHRoaXMsIHRoaXMucHJvcGVydGllcyk7XG4gIHRoaXMucmVnaXN0cnkgPSBuZXcgUmVnaXN0cnkocGFja2FnZXMsIHRoaXMucHJvcGVydGllcyk7XG5cbiAgdGhpcy50eXBlQ2FjaGUgPSB7fTtcblxuICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbn1cblxuXG4vKipcbiAqIENyZWF0ZSBhbiBpbnN0YW5jZSBvZiB0aGUgc3BlY2lmaWVkIHR5cGUuXG4gKlxuICogQG1ldGhvZCBNb2RkbGUjY3JlYXRlXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgZm9vID0gbW9kZGxlLmNyZWF0ZSgnbXk6Rm9vJyk7XG4gKiB2YXIgYmFyID0gbW9kZGxlLmNyZWF0ZSgnbXk6QmFyJywgeyBpZDogJ0JBUl8xJyB9KTtcbiAqXG4gKiBAcGFyYW0gIHtTdHJpbmd8T2JqZWN0fSBkZXNjcmlwdG9yIHRoZSB0eXBlIGRlc2NyaXB0b3Igb3IgbmFtZSBrbm93IHRvIHRoZSBtb2RlbFxuICogQHBhcmFtICB7T2JqZWN0fSBhdHRycyAgIGEgbnVtYmVyIG9mIGF0dHJpYnV0ZXMgdG8gaW5pdGlhbGl6ZSB0aGUgbW9kZWwgaW5zdGFuY2Ugd2l0aFxuICogQHJldHVybiB7T2JqZWN0fSAgICAgICAgIG1vZGVsIGluc3RhbmNlXG4gKi9cbk1vZGRsZS5wcm90b3R5cGUuY3JlYXRlID0gZnVuY3Rpb24oZGVzY3JpcHRvciwgYXR0cnMpIHtcbiAgdmFyIFR5cGUgPSB0aGlzLmdldFR5cGUoZGVzY3JpcHRvcik7XG5cbiAgaWYgKCFUeXBlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCd1bmtub3duIHR5cGUgPCcgKyBkZXNjcmlwdG9yICsgJz4nKTtcbiAgfVxuXG4gIHJldHVybiBuZXcgVHlwZShhdHRycyk7XG59O1xuXG5cbi8qKlxuICogUmV0dXJucyB0aGUgdHlwZSByZXByZXNlbnRpbmcgYSBnaXZlbiBkZXNjcmlwdG9yXG4gKlxuICogQG1ldGhvZCBNb2RkbGUjZ2V0VHlwZVxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIEZvbyA9IG1vZGRsZS5nZXRUeXBlKCdteTpGb28nKTtcbiAqIHZhciBmb28gPSBuZXcgRm9vKHsgJ2lkJyA6ICdGT09fMScgfSk7XG4gKlxuICogQHBhcmFtICB7U3RyaW5nfE9iamVjdH0gZGVzY3JpcHRvciB0aGUgdHlwZSBkZXNjcmlwdG9yIG9yIG5hbWUga25vdyB0byB0aGUgbW9kZWxcbiAqIEByZXR1cm4ge09iamVjdH0gICAgICAgICB0aGUgdHlwZSByZXByZXNlbnRpbmcgdGhlIGRlc2NyaXB0b3JcbiAqL1xuTW9kZGxlLnByb3RvdHlwZS5nZXRUeXBlID0gZnVuY3Rpb24oZGVzY3JpcHRvcikge1xuXG4gIHZhciBjYWNoZSA9IHRoaXMudHlwZUNhY2hlO1xuXG4gIHZhciBuYW1lID0gaXNTdHJpbmcoZGVzY3JpcHRvcikgPyBkZXNjcmlwdG9yIDogZGVzY3JpcHRvci5ucy5uYW1lO1xuXG4gIHZhciB0eXBlID0gY2FjaGVbbmFtZV07XG5cbiAgaWYgKCF0eXBlKSB7XG4gICAgZGVzY3JpcHRvciA9IHRoaXMucmVnaXN0cnkuZ2V0RWZmZWN0aXZlRGVzY3JpcHRvcihuYW1lKTtcbiAgICB0eXBlID0gY2FjaGVbbmFtZV0gPSB0aGlzLmZhY3RvcnkuY3JlYXRlVHlwZShkZXNjcmlwdG9yKTtcbiAgfVxuXG4gIHJldHVybiB0eXBlO1xufTtcblxuXG4vKipcbiAqIENyZWF0ZXMgYW4gYW55LWVsZW1lbnQgdHlwZSB0byBiZSB1c2VkIHdpdGhpbiBtb2RlbCBpbnN0YW5jZXMuXG4gKlxuICogVGhpcyBjYW4gYmUgdXNlZCB0byBjcmVhdGUgY3VzdG9tIGVsZW1lbnRzIHRoYXQgbGllIG91dHNpZGUgdGhlIG1ldGEtbW9kZWwuXG4gKiBUaGUgY3JlYXRlZCBlbGVtZW50IGNvbnRhaW5zIGFsbCB0aGUgbWV0YS1kYXRhIHJlcXVpcmVkIHRvIHNlcmlhbGl6ZSBpdFxuICogYXMgcGFydCBvZiBtZXRhLW1vZGVsIGVsZW1lbnRzLlxuICpcbiAqIEBtZXRob2QgTW9kZGxlI2NyZWF0ZUFueVxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIGZvbyA9IG1vZGRsZS5jcmVhdGVBbnkoJ3ZlbmRvcjpGb28nLCAnaHR0cDovL3ZlbmRvcicsIHtcbiAqICAgdmFsdWU6ICdiYXInXG4gKiB9KTtcbiAqXG4gKiB2YXIgY29udGFpbmVyID0gbW9kZGxlLmNyZWF0ZSgnbXk6Q29udGFpbmVyJywgJ2h0dHA6Ly9teScsIHtcbiAqICAgYW55OiBbIGZvbyBdXG4gKiB9KTtcbiAqXG4gKiAvLyBnbyBhaGVhZCBhbmQgc2VyaWFsaXplIHRoZSBzdHVmZlxuICpcbiAqXG4gKiBAcGFyYW0gIHtTdHJpbmd9IG5hbWUgIHRoZSBuYW1lIG9mIHRoZSBlbGVtZW50XG4gKiBAcGFyYW0gIHtTdHJpbmd9IG5zVXJpIHRoZSBuYW1lc3BhY2UgdXJpIG9mIHRoZSBlbGVtZW50XG4gKiBAcGFyYW0gIHtPYmplY3R9IFtwcm9wZXJ0aWVzXSBhIG1hcCBvZiBwcm9wZXJ0aWVzIHRvIGluaXRpYWxpemUgdGhlIGluc3RhbmNlIHdpdGhcbiAqIEByZXR1cm4ge09iamVjdH0gdGhlIGFueSB0eXBlIGluc3RhbmNlXG4gKi9cbk1vZGRsZS5wcm90b3R5cGUuY3JlYXRlQW55ID0gZnVuY3Rpb24obmFtZSwgbnNVcmksIHByb3BlcnRpZXMpIHtcblxuICB2YXIgbmFtZU5zID0gcGFyc2VOYW1lKG5hbWUpO1xuXG4gIHZhciBlbGVtZW50ID0ge1xuICAgICR0eXBlOiBuYW1lLFxuICAgICRpbnN0YW5jZU9mOiBmdW5jdGlvbih0eXBlKSB7XG4gICAgICByZXR1cm4gdHlwZSA9PT0gdGhpcy4kdHlwZTtcbiAgICB9LFxuICAgIGdldDogZnVuY3Rpb24oa2V5KSB7XG4gICAgICByZXR1cm4gdGhpc1trZXldO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgICBzZXQodGhpcywgWyBrZXkgXSwgdmFsdWUpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgZGVzY3JpcHRvciA9IHtcbiAgICBuYW1lOiBuYW1lLFxuICAgIGlzR2VuZXJpYzogdHJ1ZSxcbiAgICBuczoge1xuICAgICAgcHJlZml4OiBuYW1lTnMucHJlZml4LFxuICAgICAgbG9jYWxOYW1lOiBuYW1lTnMubG9jYWxOYW1lLFxuICAgICAgdXJpOiBuc1VyaVxuICAgIH1cbiAgfTtcblxuICB0aGlzLnByb3BlcnRpZXMuZGVmaW5lRGVzY3JpcHRvcihlbGVtZW50LCBkZXNjcmlwdG9yKTtcbiAgdGhpcy5wcm9wZXJ0aWVzLmRlZmluZU1vZGVsKGVsZW1lbnQsIHRoaXMpO1xuICB0aGlzLnByb3BlcnRpZXMuZGVmaW5lKGVsZW1lbnQsICdnZXQnLCB7IGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSB9KTtcbiAgdGhpcy5wcm9wZXJ0aWVzLmRlZmluZShlbGVtZW50LCAnc2V0JywgeyBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUgfSk7XG4gIHRoaXMucHJvcGVydGllcy5kZWZpbmUoZWxlbWVudCwgJyRwYXJlbnQnLCB7IGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSB9KTtcbiAgdGhpcy5wcm9wZXJ0aWVzLmRlZmluZShlbGVtZW50LCAnJGluc3RhbmNlT2YnLCB7IGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSB9KTtcblxuICBmb3JFYWNoKHByb3BlcnRpZXMsIGZ1bmN0aW9uKGEsIGtleSkge1xuICAgIGlmIChpc09iamVjdChhKSAmJiBhLnZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGVsZW1lbnRbYS5uYW1lXSA9IGEudmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsZW1lbnRba2V5XSA9IGE7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gZWxlbWVudDtcbn07XG5cbi8qKlxuICogUmV0dXJucyBhIHJlZ2lzdGVyZWQgcGFja2FnZSBieSB1cmkgb3IgcHJlZml4XG4gKlxuICogQHJldHVybiB7T2JqZWN0fSB0aGUgcGFja2FnZVxuICovXG5Nb2RkbGUucHJvdG90eXBlLmdldFBhY2thZ2UgPSBmdW5jdGlvbih1cmlPclByZWZpeCkge1xuICByZXR1cm4gdGhpcy5yZWdpc3RyeS5nZXRQYWNrYWdlKHVyaU9yUHJlZml4KTtcbn07XG5cbi8qKlxuICogUmV0dXJucyBhIHNuYXBzaG90IG9mIGFsbCBrbm93biBwYWNrYWdlc1xuICpcbiAqIEByZXR1cm4ge09iamVjdH0gdGhlIHBhY2thZ2VcbiAqL1xuTW9kZGxlLnByb3RvdHlwZS5nZXRQYWNrYWdlcyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5yZWdpc3RyeS5nZXRQYWNrYWdlcygpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBkZXNjcmlwdG9yIGZvciBhbiBlbGVtZW50XG4gKi9cbk1vZGRsZS5wcm90b3R5cGUuZ2V0RWxlbWVudERlc2NyaXB0b3IgPSBmdW5jdGlvbihlbGVtZW50KSB7XG4gIHJldHVybiBlbGVtZW50LiRkZXNjcmlwdG9yO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIGRlc2NyaXB0b3Igb3IgaW5zdGFuY2VcbiAqIHJlcHJlc2VudHMgdGhlIGdpdmVuIHR5cGUuXG4gKlxuICogTWF5IGJlIGFwcGxpZWQgdG8gdGhpcywgaWYgZWxlbWVudCBpcyBvbWl0dGVkLlxuICovXG5Nb2RkbGUucHJvdG90eXBlLmhhc1R5cGUgPSBmdW5jdGlvbihlbGVtZW50LCB0eXBlKSB7XG4gIGlmICh0eXBlID09PSB1bmRlZmluZWQpIHtcbiAgICB0eXBlID0gZWxlbWVudDtcbiAgICBlbGVtZW50ID0gdGhpcztcbiAgfVxuXG4gIHZhciBkZXNjcmlwdG9yID0gZWxlbWVudC4kbW9kZWwuZ2V0RWxlbWVudERlc2NyaXB0b3IoZWxlbWVudCk7XG5cbiAgcmV0dXJuICh0eXBlIGluIGRlc2NyaXB0b3IuYWxsVHlwZXNCeU5hbWUpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBkZXNjcmlwdG9yIG9mIGFuIGVsZW1lbnRzIG5hbWVkIHByb3BlcnR5XG4gKi9cbk1vZGRsZS5wcm90b3R5cGUuZ2V0UHJvcGVydHlEZXNjcmlwdG9yID0gZnVuY3Rpb24oZWxlbWVudCwgcHJvcGVydHkpIHtcbiAgcmV0dXJuIHRoaXMuZ2V0RWxlbWVudERlc2NyaXB0b3IoZWxlbWVudCkucHJvcGVydGllc0J5TmFtZVtwcm9wZXJ0eV07XG59O1xuXG4vKipcbiAqIFJldHVybnMgYSBtYXBwZWQgdHlwZSdzIGRlc2NyaXB0b3JcbiAqL1xuTW9kZGxlLnByb3RvdHlwZS5nZXRUeXBlRGVzY3JpcHRvciA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgcmV0dXJuIHRoaXMucmVnaXN0cnkudHlwZU1hcFt0eXBlXTtcbn07XG5cbmV4cG9ydCB7IE1vZGRsZSwgY29lcmNlVHlwZSwgaXNCdWlsdEluIGFzIGlzQnVpbHRJblR5cGUsIGlzU2ltcGxlIGFzIGlzU2ltcGxlVHlwZSwgcGFyc2VOYW1lIGFzIHBhcnNlTmFtZU5TIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/moddle/dist/index.js\n");

/***/ })

};
;