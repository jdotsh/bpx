"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/tiny-svg";
exports.ids = ["vendor-chunks/tiny-svg"];
exports.modules = {

/***/ "(ssr)/./node_modules/tiny-svg/dist/index.esm.js":
/*!*************************************************!*\
  !*** ./node_modules/tiny-svg/dist/index.esm.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   append: () => (/* binding */ append),\n/* harmony export */   appendTo: () => (/* binding */ appendTo),\n/* harmony export */   attr: () => (/* binding */ attr),\n/* harmony export */   classes: () => (/* binding */ classes),\n/* harmony export */   clear: () => (/* binding */ clear),\n/* harmony export */   clone: () => (/* binding */ clone),\n/* harmony export */   create: () => (/* binding */ create),\n/* harmony export */   createMatrix: () => (/* binding */ createMatrix),\n/* harmony export */   createPoint: () => (/* binding */ createPoint),\n/* harmony export */   createTransform: () => (/* binding */ createTransform),\n/* harmony export */   innerSVG: () => (/* binding */ innerSVG),\n/* harmony export */   off: () => (/* binding */ off),\n/* harmony export */   on: () => (/* binding */ on),\n/* harmony export */   prepend: () => (/* binding */ prepend),\n/* harmony export */   prependTo: () => (/* binding */ prependTo),\n/* harmony export */   remove: () => (/* binding */ remove),\n/* harmony export */   replace: () => (/* binding */ replace),\n/* harmony export */   select: () => (/* binding */ select),\n/* harmony export */   selectAll: () => (/* binding */ selectAll),\n/* harmony export */   transform: () => (/* binding */ transform)\n/* harmony export */ });\nfunction ensureImported(element, target) {\n\n  if (element.ownerDocument !== target.ownerDocument) {\n    try {\n\n      // may fail on webkit\n      return target.ownerDocument.importNode(element, true);\n    } catch (e) {\n\n      // ignore\n    }\n  }\n\n  return element;\n}\n\n/**\n * appendTo utility\n */\n\n\n/**\n * Append a node to a target element and return the appended node.\n *\n * @param  {SVGElement} element\n * @param  {SVGElement} target\n *\n * @return {SVGElement} the appended node\n */\nfunction appendTo(element, target) {\n  return target.appendChild(ensureImported(element, target));\n}\n\n/**\n * append utility\n */\n\n\n/**\n * Append a node to an element\n *\n * @param  {SVGElement} element\n * @param  {SVGElement} node\n *\n * @return {SVGElement} the element\n */\nfunction append(target, node) {\n  appendTo(node, target);\n  return target;\n}\n\n/**\n * attribute accessor utility\n */\n\nvar LENGTH_ATTR = 2;\n\nvar CSS_PROPERTIES = {\n  'alignment-baseline': 1,\n  'baseline-shift': 1,\n  'clip': 1,\n  'clip-path': 1,\n  'clip-rule': 1,\n  'color': 1,\n  'color-interpolation': 1,\n  'color-interpolation-filters': 1,\n  'color-profile': 1,\n  'color-rendering': 1,\n  'cursor': 1,\n  'direction': 1,\n  'display': 1,\n  'dominant-baseline': 1,\n  'enable-background': 1,\n  'fill': 1,\n  'fill-opacity': 1,\n  'fill-rule': 1,\n  'filter': 1,\n  'flood-color': 1,\n  'flood-opacity': 1,\n  'font': 1,\n  'font-family': 1,\n  'font-size': LENGTH_ATTR,\n  'font-size-adjust': 1,\n  'font-stretch': 1,\n  'font-style': 1,\n  'font-variant': 1,\n  'font-weight': 1,\n  'glyph-orientation-horizontal': 1,\n  'glyph-orientation-vertical': 1,\n  'image-rendering': 1,\n  'kerning': 1,\n  'letter-spacing': 1,\n  'lighting-color': 1,\n  'marker': 1,\n  'marker-end': 1,\n  'marker-mid': 1,\n  'marker-start': 1,\n  'mask': 1,\n  'opacity': 1,\n  'overflow': 1,\n  'pointer-events': 1,\n  'shape-rendering': 1,\n  'stop-color': 1,\n  'stop-opacity': 1,\n  'stroke': 1,\n  'stroke-dasharray': 1,\n  'stroke-dashoffset': 1,\n  'stroke-linecap': 1,\n  'stroke-linejoin': 1,\n  'stroke-miterlimit': 1,\n  'stroke-opacity': 1,\n  'stroke-width': LENGTH_ATTR,\n  'text-anchor': 1,\n  'text-decoration': 1,\n  'text-rendering': 1,\n  'unicode-bidi': 1,\n  'visibility': 1,\n  'word-spacing': 1,\n  'writing-mode': 1\n};\n\n\nfunction getAttribute(node, name) {\n  if (CSS_PROPERTIES[name]) {\n    return node.style[name];\n  } else {\n    return node.getAttributeNS(null, name);\n  }\n}\n\nfunction setAttribute(node, name, value) {\n  var hyphenated = name.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();\n\n  var type = CSS_PROPERTIES[hyphenated];\n\n  if (type) {\n\n    // append pixel unit, unless present\n    if (type === LENGTH_ATTR && typeof value === 'number') {\n      value = String(value) + 'px';\n    }\n\n    node.style[hyphenated] = value;\n  } else {\n    node.setAttributeNS(null, name, value);\n  }\n}\n\nfunction setAttributes(node, attrs) {\n\n  var names = Object.keys(attrs), i, name;\n\n  for (i = 0, name; (name = names[i]); i++) {\n    setAttribute(node, name, attrs[name]);\n  }\n}\n\n/**\n * Gets or sets raw attributes on a node.\n *\n * @param  {SVGElement} node\n * @param  {Object} [attrs]\n * @param  {String} [name]\n * @param  {String} [value]\n *\n * @return {String}\n */\nfunction attr(node, name, value) {\n  if (typeof name === 'string') {\n    if (value !== undefined) {\n      setAttribute(node, name, value);\n    } else {\n      return getAttribute(node, name);\n    }\n  } else {\n    setAttributes(node, name);\n  }\n\n  return node;\n}\n\n/**\r\n * Taken from https://github.com/component/classes\r\n *\r\n * Without the component bits.\r\n */\r\n\r\n/**\r\n * toString reference.\r\n */\r\n\r\nconst toString = Object.prototype.toString;\r\n\r\n/**\r\n  * Wrap `el` in a `ClassList`.\r\n  *\r\n  * @param {Element} el\r\n  * @return {ClassList}\r\n  * @api public\r\n  */\r\n\r\nfunction classes(el) {\r\n  return new ClassList(el);\r\n}\r\n\r\nfunction ClassList(el) {\r\n  if (!el || !el.nodeType) {\r\n    throw new Error('A DOM element reference is required');\r\n  }\r\n  this.el = el;\r\n  this.list = el.classList;\r\n}\r\n\r\n/**\r\n  * Add class `name` if not already present.\r\n  *\r\n  * @param {String} name\r\n  * @return {ClassList}\r\n  * @api public\r\n  */\r\n\r\nClassList.prototype.add = function(name) {\r\n  this.list.add(name);\r\n  return this;\r\n};\r\n\r\n/**\r\n  * Remove class `name` when present, or\r\n  * pass a regular expression to remove\r\n  * any which match.\r\n  *\r\n  * @param {String|RegExp} name\r\n  * @return {ClassList}\r\n  * @api public\r\n  */\r\n\r\nClassList.prototype.remove = function(name) {\r\n  if ('[object RegExp]' == toString.call(name)) {\r\n    return this.removeMatching(name);\r\n  }\r\n\r\n  this.list.remove(name);\r\n  return this;\r\n};\r\n\r\n/**\r\n  * Remove all classes matching `re`.\r\n  *\r\n  * @param {RegExp} re\r\n  * @return {ClassList}\r\n  * @api private\r\n  */\r\n\r\nClassList.prototype.removeMatching = function(re) {\r\n  const arr = this.array();\r\n  for (let i = 0; i < arr.length; i++) {\r\n    if (re.test(arr[i])) {\r\n      this.remove(arr[i]);\r\n    }\r\n  }\r\n  return this;\r\n};\r\n\r\n/**\r\n  * Toggle class `name`, can force state via `force`.\r\n  *\r\n  * For browsers that support classList, but do not support `force` yet,\r\n  * the mistake will be detected and corrected.\r\n  *\r\n  * @param {String} name\r\n  * @param {Boolean} force\r\n  * @return {ClassList}\r\n  * @api public\r\n  */\r\n\r\nClassList.prototype.toggle = function(name, force) {\r\n  if ('undefined' !== typeof force) {\r\n    if (force !== this.list.toggle(name, force)) {\r\n      this.list.toggle(name); // toggle again to correct\r\n    }\r\n  } else {\r\n    this.list.toggle(name);\r\n  }\r\n  return this;\r\n};\r\n\r\n/**\r\n  * Return an array of classes.\r\n  *\r\n  * @return {Array}\r\n  * @api public\r\n  */\r\n\r\nClassList.prototype.array = function() {\r\n  return Array.from(this.list);\r\n};\r\n\r\n/**\r\n  * Check if class `name` is present.\r\n  *\r\n  * @param {String} name\r\n  * @return {ClassList}\r\n  * @api public\r\n  */\r\n\r\nClassList.prototype.has =\r\n ClassList.prototype.contains = function(name) {\r\n   return this.list.contains(name);\r\n };\n\n/**\n * Clear utility\n */\n\n/**\n * Removes all children from the given element\n *\n * @param  {SVGElement} element\n * @return {Element} the element (for chaining)\n */\nfunction clear(element) {\n  var child;\n\n  while ((child = element.firstChild)) {\n    element.removeChild(child);\n  }\n\n  return element;\n}\n\nfunction clone(element) {\n  return element.cloneNode(true);\n}\n\nvar ns = {\n  svg: 'http://www.w3.org/2000/svg'\n};\n\n/**\n * DOM parsing utility\n */\n\n\nvar SVG_START = '<svg xmlns=\"' + ns.svg + '\"';\n\nfunction parse(svg) {\n\n  var unwrap = false;\n\n  // ensure we import a valid svg document\n  if (svg.substring(0, 4) === '<svg') {\n    if (svg.indexOf(ns.svg) === -1) {\n      svg = SVG_START + svg.substring(4);\n    }\n  } else {\n\n    // namespace svg\n    svg = SVG_START + '>' + svg + '</svg>';\n    unwrap = true;\n  }\n\n  var parsed = parseDocument(svg);\n\n  if (!unwrap) {\n    return parsed;\n  }\n\n  var fragment = document.createDocumentFragment();\n\n  var parent = parsed.firstChild;\n\n  while (parent.firstChild) {\n    fragment.appendChild(parent.firstChild);\n  }\n\n  return fragment;\n}\n\nfunction parseDocument(svg) {\n\n  var parser;\n\n  // parse\n  parser = new DOMParser();\n  parser.async = false;\n\n  return parser.parseFromString(svg, 'text/xml');\n}\n\n/**\n * Create utility for SVG elements\n */\n\n\n\n/**\n * Create a specific type from name or SVG markup.\n *\n * @param {String} name the name or markup of the element\n * @param {Object} [attrs] attributes to set on the element\n *\n * @returns {SVGElement}\n */\nfunction create(name, attrs) {\n  var element;\n\n  name = name.trim();\n\n  if (name.charAt(0) === '<') {\n    element = parse(name).firstChild;\n    element = document.importNode(element, true);\n  } else {\n    element = document.createElementNS(ns.svg, name);\n  }\n\n  if (attrs) {\n    attr(element, attrs);\n  }\n\n  return element;\n}\n\n/**\n * Events handling utility\n */\n\nfunction on(node, event, listener, useCapture) {\n  node.addEventListener(event, listener, useCapture);\n}\n\nfunction off(node, event, listener, useCapture) {\n  node.removeEventListener(event, listener, useCapture);\n}\n\n/**\n * Geometry helpers\n */\n\n\n// fake node used to instantiate svg geometry elements\nvar node = null;\n\nfunction getNode() {\n  if (node === null) {\n    node = create('svg');\n  }\n\n  return node;\n}\n\nfunction extend(object, props) {\n  var i, k, keys = Object.keys(props);\n\n  for (i = 0; (k = keys[i]); i++) {\n    object[k] = props[k];\n  }\n\n  return object;\n}\n\n\nfunction createPoint(x, y) {\n  var point = getNode().createSVGPoint();\n\n  switch (arguments.length) {\n  case 0:\n    return point;\n  case 2:\n    x = {\n      x: x,\n      y: y\n    };\n    break;\n  }\n\n  return extend(point, x);\n}\n\n/**\n * Create matrix via args.\n *\n * @example\n *\n * createMatrix({ a: 1, b: 1 });\n * createMatrix();\n * createMatrix(1, 2, 0, 0, 30, 20);\n *\n * @return {SVGMatrix}\n */\nfunction createMatrix(a, b, c, d, e, f) {\n  var matrix = getNode().createSVGMatrix();\n\n  switch (arguments.length) {\n  case 0:\n    return matrix;\n  case 1:\n    return extend(matrix, a);\n  case 6:\n    return extend(matrix, {\n      a: a,\n      b: b,\n      c: c,\n      d: d,\n      e: e,\n      f: f\n    });\n  }\n}\n\nfunction createTransform(matrix) {\n  if (matrix) {\n    return getNode().createSVGTransformFromMatrix(matrix);\n  } else {\n    return getNode().createSVGTransform();\n  }\n}\n\n/**\n * Serialization util\n */\n\nvar TEXT_ENTITIES = /([&<>]{1})/g;\nvar ATTR_ENTITIES = /([&<>\\n\\r\"]{1})/g;\n\nvar ENTITY_REPLACEMENT = {\n  '&': '&amp;',\n  '<': '&lt;',\n  '>': '&gt;',\n  '\"': '\\''\n};\n\nfunction escape(str, pattern) {\n\n  function replaceFn(match, entity) {\n    return ENTITY_REPLACEMENT[entity] || entity;\n  }\n\n  return str.replace(pattern, replaceFn);\n}\n\nfunction serialize(node, output) {\n\n  var i, len, attrMap, attrNode, childNodes;\n\n  switch (node.nodeType) {\n\n  // TEXT\n  case 3:\n\n    // replace special XML characters\n    output.push(escape(node.textContent, TEXT_ENTITIES));\n    break;\n\n  // ELEMENT\n  case 1:\n    output.push('<', node.tagName);\n\n    if (node.hasAttributes()) {\n      attrMap = node.attributes;\n      for (i = 0, len = attrMap.length; i < len; ++i) {\n        attrNode = attrMap.item(i);\n        output.push(' ', attrNode.name, '=\"', escape(attrNode.value, ATTR_ENTITIES), '\"');\n      }\n    }\n\n    if (node.hasChildNodes()) {\n      output.push('>');\n      childNodes = node.childNodes;\n      for (i = 0, len = childNodes.length; i < len; ++i) {\n        serialize(childNodes.item(i), output);\n      }\n      output.push('</', node.tagName, '>');\n    } else {\n      output.push('/>');\n    }\n    break;\n\n  // COMMENT\n  case 8:\n    output.push('<!--', escape(node.nodeValue, TEXT_ENTITIES), '-->');\n    break;\n\n  // CDATA\n  case 4:\n    output.push('<![CDATA[', node.nodeValue, ']]>');\n    break;\n\n  default:\n    throw new Error('unable to handle node ' + node.nodeType);\n  }\n\n  return output;\n}\n\n/**\n * innerHTML like functionality for SVG elements.\n * based on innerSVG (https://code.google.com/p/innersvg)\n */\n\n\n\nfunction set(element, svg) {\n\n  var parsed = parse(svg);\n\n  // clear element contents\n  clear(element);\n\n  if (!svg) {\n    return;\n  }\n\n  if (!isFragment(parsed)) {\n\n    // extract <svg> from parsed document\n    parsed = parsed.documentElement;\n  }\n\n  var nodes = slice(parsed.childNodes);\n\n  // import + append each node\n  for (var i = 0; i < nodes.length; i++) {\n    appendTo(nodes[i], element);\n  }\n\n}\n\nfunction get(element) {\n  var child = element.firstChild,\n      output = [];\n\n  while (child) {\n    serialize(child, output);\n    child = child.nextSibling;\n  }\n\n  return output.join('');\n}\n\nfunction isFragment(node) {\n  return node.nodeName === '#document-fragment';\n}\n\nfunction innerSVG(element, svg) {\n\n  if (svg !== undefined) {\n\n    try {\n      set(element, svg);\n    } catch (e) {\n      throw new Error('error parsing SVG: ' + e.message);\n    }\n\n    return element;\n  } else {\n    return get(element);\n  }\n}\n\n\nfunction slice(arr) {\n  return Array.prototype.slice.call(arr);\n}\n\n/**\n * Selection utilities\n */\n\nfunction select(node, selector) {\n  return node.querySelector(selector);\n}\n\nfunction selectAll(node, selector) {\n  var nodes = node.querySelectorAll(selector);\n\n  return [].map.call(nodes, function(element) {\n    return element;\n  });\n}\n\n/**\n * prependTo utility\n */\n\n\n/**\n * Prepend a node to a target element and return the prepended node.\n *\n * @param  {SVGElement} node\n * @param  {SVGElement} target\n *\n * @return {SVGElement} the prepended node\n */\nfunction prependTo(node, target) {\n  return target.insertBefore(ensureImported(node, target), target.firstChild || null);\n}\n\n/**\n * prepend utility\n */\n\n\n/**\n * Prepend a node to a target element\n *\n * @param  {SVGElement} target\n * @param  {SVGElement} node\n *\n * @return {SVGElement} the target element\n */\nfunction prepend(target, node) {\n  prependTo(node, target);\n  return target;\n}\n\nfunction remove(element) {\n  var parent = element.parentNode;\n\n  if (parent) {\n    parent.removeChild(element);\n  }\n\n  return element;\n}\n\n/**\n * Replace utility\n */\n\n\nfunction replace(element, replacement) {\n  element.parentNode.replaceChild(ensureImported(replacement, element), element);\n  return replacement;\n}\n\n/**\n * transform accessor utility\n */\n\nfunction wrapMatrix(transformList, transform) {\n  if (transform instanceof SVGMatrix) {\n    return transformList.createSVGTransformFromMatrix(transform);\n  }\n\n  return transform;\n}\n\n\nfunction setTransforms(transformList, transforms) {\n  var i, t;\n\n  transformList.clear();\n\n  for (i = 0; (t = transforms[i]); i++) {\n    transformList.appendItem(wrapMatrix(transformList, t));\n  }\n}\n\n/**\n * Get or set the transforms on the given node.\n *\n * @param {SVGElement} node\n * @param  {SVGTransform|SVGMatrix|Array<SVGTransform|SVGMatrix>} [transforms]\n *\n * @return {SVGTransform} the consolidated transform\n */\nfunction transform(node, transforms) {\n  var transformList = node.transform.baseVal;\n\n  if (transforms) {\n\n    if (!Array.isArray(transforms)) {\n      transforms = [ transforms ];\n    }\n\n    setTransforms(transformList, transforms);\n  }\n\n  return transformList.consolidate();\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdGlueS1zdmcvZGlzdC9pbmRleC5lc20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxZQUFZO0FBQ3hCLFlBQVksWUFBWTtBQUN4QjtBQUNBLFlBQVksWUFBWTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLFlBQVksWUFBWTtBQUN4QixZQUFZLFlBQVk7QUFDeEI7QUFDQSxZQUFZLFlBQVk7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLG9CQUFvQixtQkFBbUI7QUFDdkM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7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QUFZO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxZQUFZO0FBQ3hCLFlBQVksWUFBWTtBQUN4QjtBQUNBLFlBQVksWUFBWTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTs7QUFFQSxjQUFjLHFCQUFxQjtBQUNuQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCLFlBQVksc0RBQXNEO0FBQ2xFO0FBQ0EsWUFBWSxjQUFjO0FBQzFCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVtTSIsInNvdXJjZXMiOlsid2VicGFjazovL2JwbW4tc3R1ZGlvLXdlYi8uL25vZGVfbW9kdWxlcy90aW55LXN2Zy9kaXN0L2luZGV4LmVzbS5qcz9kYzUwIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIGVuc3VyZUltcG9ydGVkKGVsZW1lbnQsIHRhcmdldCkge1xuXG4gIGlmIChlbGVtZW50Lm93bmVyRG9jdW1lbnQgIT09IHRhcmdldC5vd25lckRvY3VtZW50KSB7XG4gICAgdHJ5IHtcblxuICAgICAgLy8gbWF5IGZhaWwgb24gd2Via2l0XG4gICAgICByZXR1cm4gdGFyZ2V0Lm93bmVyRG9jdW1lbnQuaW1wb3J0Tm9kZShlbGVtZW50LCB0cnVlKTtcbiAgICB9IGNhdGNoIChlKSB7XG5cbiAgICAgIC8vIGlnbm9yZVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBlbGVtZW50O1xufVxuXG4vKipcbiAqIGFwcGVuZFRvIHV0aWxpdHlcbiAqL1xuXG5cbi8qKlxuICogQXBwZW5kIGEgbm9kZSB0byBhIHRhcmdldCBlbGVtZW50IGFuZCByZXR1cm4gdGhlIGFwcGVuZGVkIG5vZGUuXG4gKlxuICogQHBhcmFtICB7U1ZHRWxlbWVudH0gZWxlbWVudFxuICogQHBhcmFtICB7U1ZHRWxlbWVudH0gdGFyZ2V0XG4gKlxuICogQHJldHVybiB7U1ZHRWxlbWVudH0gdGhlIGFwcGVuZGVkIG5vZGVcbiAqL1xuZnVuY3Rpb24gYXBwZW5kVG8oZWxlbWVudCwgdGFyZ2V0KSB7XG4gIHJldHVybiB0YXJnZXQuYXBwZW5kQ2hpbGQoZW5zdXJlSW1wb3J0ZWQoZWxlbWVudCwgdGFyZ2V0KSk7XG59XG5cbi8qKlxuICogYXBwZW5kIHV0aWxpdHlcbiAqL1xuXG5cbi8qKlxuICogQXBwZW5kIGEgbm9kZSB0byBhbiBlbGVtZW50XG4gKlxuICogQHBhcmFtICB7U1ZHRWxlbWVudH0gZWxlbWVudFxuICogQHBhcmFtICB7U1ZHRWxlbWVudH0gbm9kZVxuICpcbiAqIEByZXR1cm4ge1NWR0VsZW1lbnR9IHRoZSBlbGVtZW50XG4gKi9cbmZ1bmN0aW9uIGFwcGVuZCh0YXJnZXQsIG5vZGUpIHtcbiAgYXBwZW5kVG8obm9kZSwgdGFyZ2V0KTtcbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuLyoqXG4gKiBhdHRyaWJ1dGUgYWNjZXNzb3IgdXRpbGl0eVxuICovXG5cbnZhciBMRU5HVEhfQVRUUiA9IDI7XG5cbnZhciBDU1NfUFJPUEVSVElFUyA9IHtcbiAgJ2FsaWdubWVudC1iYXNlbGluZSc6IDEsXG4gICdiYXNlbGluZS1zaGlmdCc6IDEsXG4gICdjbGlwJzogMSxcbiAgJ2NsaXAtcGF0aCc6IDEsXG4gICdjbGlwLXJ1bGUnOiAxLFxuICAnY29sb3InOiAxLFxuICAnY29sb3ItaW50ZXJwb2xhdGlvbic6IDEsXG4gICdjb2xvci1pbnRlcnBvbGF0aW9uLWZpbHRlcnMnOiAxLFxuICAnY29sb3ItcHJvZmlsZSc6IDEsXG4gICdjb2xvci1yZW5kZXJpbmcnOiAxLFxuICAnY3Vyc29yJzogMSxcbiAgJ2RpcmVjdGlvbic6IDEsXG4gICdkaXNwbGF5JzogMSxcbiAgJ2RvbWluYW50LWJhc2VsaW5lJzogMSxcbiAgJ2VuYWJsZS1iYWNrZ3JvdW5kJzogMSxcbiAgJ2ZpbGwnOiAxLFxuICAnZmlsbC1vcGFjaXR5JzogMSxcbiAgJ2ZpbGwtcnVsZSc6IDEsXG4gICdmaWx0ZXInOiAxLFxuICAnZmxvb2QtY29sb3InOiAxLFxuICAnZmxvb2Qtb3BhY2l0eSc6IDEsXG4gICdmb250JzogMSxcbiAgJ2ZvbnQtZmFtaWx5JzogMSxcbiAgJ2ZvbnQtc2l6ZSc6IExFTkdUSF9BVFRSLFxuICAnZm9udC1zaXplLWFkanVzdCc6IDEsXG4gICdmb250LXN0cmV0Y2gnOiAxLFxuICAnZm9udC1zdHlsZSc6IDEsXG4gICdmb250LXZhcmlhbnQnOiAxLFxuICAnZm9udC13ZWlnaHQnOiAxLFxuICAnZ2x5cGgtb3JpZW50YXRpb24taG9yaXpvbnRhbCc6IDEsXG4gICdnbHlwaC1vcmllbnRhdGlvbi12ZXJ0aWNhbCc6IDEsXG4gICdpbWFnZS1yZW5kZXJpbmcnOiAxLFxuICAna2VybmluZyc6IDEsXG4gICdsZXR0ZXItc3BhY2luZyc6IDEsXG4gICdsaWdodGluZy1jb2xvcic6IDEsXG4gICdtYXJrZXInOiAxLFxuICAnbWFya2VyLWVuZCc6IDEsXG4gICdtYXJrZXItbWlkJzogMSxcbiAgJ21hcmtlci1zdGFydCc6IDEsXG4gICdtYXNrJzogMSxcbiAgJ29wYWNpdHknOiAxLFxuICAnb3ZlcmZsb3cnOiAxLFxuICAncG9pbnRlci1ldmVudHMnOiAxLFxuICAnc2hhcGUtcmVuZGVyaW5nJzogMSxcbiAgJ3N0b3AtY29sb3InOiAxLFxuICAnc3RvcC1vcGFjaXR5JzogMSxcbiAgJ3N0cm9rZSc6IDEsXG4gICdzdHJva2UtZGFzaGFycmF5JzogMSxcbiAgJ3N0cm9rZS1kYXNob2Zmc2V0JzogMSxcbiAgJ3N0cm9rZS1saW5lY2FwJzogMSxcbiAgJ3N0cm9rZS1saW5lam9pbic6IDEsXG4gICdzdHJva2UtbWl0ZXJsaW1pdCc6IDEsXG4gICdzdHJva2Utb3BhY2l0eSc6IDEsXG4gICdzdHJva2Utd2lkdGgnOiBMRU5HVEhfQVRUUixcbiAgJ3RleHQtYW5jaG9yJzogMSxcbiAgJ3RleHQtZGVjb3JhdGlvbic6IDEsXG4gICd0ZXh0LXJlbmRlcmluZyc6IDEsXG4gICd1bmljb2RlLWJpZGknOiAxLFxuICAndmlzaWJpbGl0eSc6IDEsXG4gICd3b3JkLXNwYWNpbmcnOiAxLFxuICAnd3JpdGluZy1tb2RlJzogMVxufTtcblxuXG5mdW5jdGlvbiBnZXRBdHRyaWJ1dGUobm9kZSwgbmFtZSkge1xuICBpZiAoQ1NTX1BST1BFUlRJRVNbbmFtZV0pIHtcbiAgICByZXR1cm4gbm9kZS5zdHlsZVtuYW1lXTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbm9kZS5nZXRBdHRyaWJ1dGVOUyhudWxsLCBuYW1lKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzZXRBdHRyaWJ1dGUobm9kZSwgbmFtZSwgdmFsdWUpIHtcbiAgdmFyIGh5cGhlbmF0ZWQgPSBuYW1lLnJlcGxhY2UoLyhbYS16XSkoW0EtWl0pL2csICckMS0kMicpLnRvTG93ZXJDYXNlKCk7XG5cbiAgdmFyIHR5cGUgPSBDU1NfUFJPUEVSVElFU1toeXBoZW5hdGVkXTtcblxuICBpZiAodHlwZSkge1xuXG4gICAgLy8gYXBwZW5kIHBpeGVsIHVuaXQsIHVubGVzcyBwcmVzZW50XG4gICAgaWYgKHR5cGUgPT09IExFTkdUSF9BVFRSICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgIHZhbHVlID0gU3RyaW5nKHZhbHVlKSArICdweCc7XG4gICAgfVxuXG4gICAgbm9kZS5zdHlsZVtoeXBoZW5hdGVkXSA9IHZhbHVlO1xuICB9IGVsc2Uge1xuICAgIG5vZGUuc2V0QXR0cmlidXRlTlMobnVsbCwgbmFtZSwgdmFsdWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNldEF0dHJpYnV0ZXMobm9kZSwgYXR0cnMpIHtcblxuICB2YXIgbmFtZXMgPSBPYmplY3Qua2V5cyhhdHRycyksIGksIG5hbWU7XG5cbiAgZm9yIChpID0gMCwgbmFtZTsgKG5hbWUgPSBuYW1lc1tpXSk7IGkrKykge1xuICAgIHNldEF0dHJpYnV0ZShub2RlLCBuYW1lLCBhdHRyc1tuYW1lXSk7XG4gIH1cbn1cblxuLyoqXG4gKiBHZXRzIG9yIHNldHMgcmF3IGF0dHJpYnV0ZXMgb24gYSBub2RlLlxuICpcbiAqIEBwYXJhbSAge1NWR0VsZW1lbnR9IG5vZGVcbiAqIEBwYXJhbSAge09iamVjdH0gW2F0dHJzXVxuICogQHBhcmFtICB7U3RyaW5nfSBbbmFtZV1cbiAqIEBwYXJhbSAge1N0cmluZ30gW3ZhbHVlXVxuICpcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuZnVuY3Rpb24gYXR0cihub2RlLCBuYW1lLCB2YWx1ZSkge1xuICBpZiAodHlwZW9mIG5hbWUgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHNldEF0dHJpYnV0ZShub2RlLCBuYW1lLCB2YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBnZXRBdHRyaWJ1dGUobm9kZSwgbmFtZSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHNldEF0dHJpYnV0ZXMobm9kZSwgbmFtZSk7XG4gIH1cblxuICByZXR1cm4gbm9kZTtcbn1cblxuLyoqXHJcbiAqIFRha2VuIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2NvbXBvbmVudC9jbGFzc2VzXHJcbiAqXHJcbiAqIFdpdGhvdXQgdGhlIGNvbXBvbmVudCBiaXRzLlxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiB0b1N0cmluZyByZWZlcmVuY2UuXHJcbiAqL1xyXG5cclxuY29uc3QgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xyXG5cclxuLyoqXHJcbiAgKiBXcmFwIGBlbGAgaW4gYSBgQ2xhc3NMaXN0YC5cclxuICAqXHJcbiAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsXHJcbiAgKiBAcmV0dXJuIHtDbGFzc0xpc3R9XHJcbiAgKiBAYXBpIHB1YmxpY1xyXG4gICovXHJcblxyXG5mdW5jdGlvbiBjbGFzc2VzKGVsKSB7XHJcbiAgcmV0dXJuIG5ldyBDbGFzc0xpc3QoZWwpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBDbGFzc0xpc3QoZWwpIHtcclxuICBpZiAoIWVsIHx8ICFlbC5ub2RlVHlwZSkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdBIERPTSBlbGVtZW50IHJlZmVyZW5jZSBpcyByZXF1aXJlZCcpO1xyXG4gIH1cclxuICB0aGlzLmVsID0gZWw7XHJcbiAgdGhpcy5saXN0ID0gZWwuY2xhc3NMaXN0O1xyXG59XHJcblxyXG4vKipcclxuICAqIEFkZCBjbGFzcyBgbmFtZWAgaWYgbm90IGFscmVhZHkgcHJlc2VudC5cclxuICAqXHJcbiAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxyXG4gICogQHJldHVybiB7Q2xhc3NMaXN0fVxyXG4gICogQGFwaSBwdWJsaWNcclxuICAqL1xyXG5cclxuQ2xhc3NMaXN0LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbihuYW1lKSB7XHJcbiAgdGhpcy5saXN0LmFkZChuYW1lKTtcclxuICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8qKlxyXG4gICogUmVtb3ZlIGNsYXNzIGBuYW1lYCB3aGVuIHByZXNlbnQsIG9yXHJcbiAgKiBwYXNzIGEgcmVndWxhciBleHByZXNzaW9uIHRvIHJlbW92ZVxyXG4gICogYW55IHdoaWNoIG1hdGNoLlxyXG4gICpcclxuICAqIEBwYXJhbSB7U3RyaW5nfFJlZ0V4cH0gbmFtZVxyXG4gICogQHJldHVybiB7Q2xhc3NMaXN0fVxyXG4gICogQGFwaSBwdWJsaWNcclxuICAqL1xyXG5cclxuQ2xhc3NMaXN0LnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbihuYW1lKSB7XHJcbiAgaWYgKCdbb2JqZWN0IFJlZ0V4cF0nID09IHRvU3RyaW5nLmNhbGwobmFtZSkpIHtcclxuICAgIHJldHVybiB0aGlzLnJlbW92ZU1hdGNoaW5nKG5hbWUpO1xyXG4gIH1cclxuXHJcbiAgdGhpcy5saXN0LnJlbW92ZShuYW1lKTtcclxuICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8qKlxyXG4gICogUmVtb3ZlIGFsbCBjbGFzc2VzIG1hdGNoaW5nIGByZWAuXHJcbiAgKlxyXG4gICogQHBhcmFtIHtSZWdFeHB9IHJlXHJcbiAgKiBAcmV0dXJuIHtDbGFzc0xpc3R9XHJcbiAgKiBAYXBpIHByaXZhdGVcclxuICAqL1xyXG5cclxuQ2xhc3NMaXN0LnByb3RvdHlwZS5yZW1vdmVNYXRjaGluZyA9IGZ1bmN0aW9uKHJlKSB7XHJcbiAgY29uc3QgYXJyID0gdGhpcy5hcnJheSgpO1xyXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XHJcbiAgICBpZiAocmUudGVzdChhcnJbaV0pKSB7XHJcbiAgICAgIHRoaXMucmVtb3ZlKGFycltpXSk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAgKiBUb2dnbGUgY2xhc3MgYG5hbWVgLCBjYW4gZm9yY2Ugc3RhdGUgdmlhIGBmb3JjZWAuXHJcbiAgKlxyXG4gICogRm9yIGJyb3dzZXJzIHRoYXQgc3VwcG9ydCBjbGFzc0xpc3QsIGJ1dCBkbyBub3Qgc3VwcG9ydCBgZm9yY2VgIHlldCxcclxuICAqIHRoZSBtaXN0YWtlIHdpbGwgYmUgZGV0ZWN0ZWQgYW5kIGNvcnJlY3RlZC5cclxuICAqXHJcbiAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxyXG4gICogQHBhcmFtIHtCb29sZWFufSBmb3JjZVxyXG4gICogQHJldHVybiB7Q2xhc3NMaXN0fVxyXG4gICogQGFwaSBwdWJsaWNcclxuICAqL1xyXG5cclxuQ2xhc3NMaXN0LnByb3RvdHlwZS50b2dnbGUgPSBmdW5jdGlvbihuYW1lLCBmb3JjZSkge1xyXG4gIGlmICgndW5kZWZpbmVkJyAhPT0gdHlwZW9mIGZvcmNlKSB7XHJcbiAgICBpZiAoZm9yY2UgIT09IHRoaXMubGlzdC50b2dnbGUobmFtZSwgZm9yY2UpKSB7XHJcbiAgICAgIHRoaXMubGlzdC50b2dnbGUobmFtZSk7IC8vIHRvZ2dsZSBhZ2FpbiB0byBjb3JyZWN0XHJcbiAgICB9XHJcbiAgfSBlbHNlIHtcclxuICAgIHRoaXMubGlzdC50b2dnbGUobmFtZSk7XHJcbiAgfVxyXG4gIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAgKiBSZXR1cm4gYW4gYXJyYXkgb2YgY2xhc3Nlcy5cclxuICAqXHJcbiAgKiBAcmV0dXJuIHtBcnJheX1cclxuICAqIEBhcGkgcHVibGljXHJcbiAgKi9cclxuXHJcbkNsYXNzTGlzdC5wcm90b3R5cGUuYXJyYXkgPSBmdW5jdGlvbigpIHtcclxuICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLmxpc3QpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAgKiBDaGVjayBpZiBjbGFzcyBgbmFtZWAgaXMgcHJlc2VudC5cclxuICAqXHJcbiAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxyXG4gICogQHJldHVybiB7Q2xhc3NMaXN0fVxyXG4gICogQGFwaSBwdWJsaWNcclxuICAqL1xyXG5cclxuQ2xhc3NMaXN0LnByb3RvdHlwZS5oYXMgPVxyXG4gQ2xhc3NMaXN0LnByb3RvdHlwZS5jb250YWlucyA9IGZ1bmN0aW9uKG5hbWUpIHtcclxuICAgcmV0dXJuIHRoaXMubGlzdC5jb250YWlucyhuYW1lKTtcclxuIH07XG5cbi8qKlxuICogQ2xlYXIgdXRpbGl0eVxuICovXG5cbi8qKlxuICogUmVtb3ZlcyBhbGwgY2hpbGRyZW4gZnJvbSB0aGUgZ2l2ZW4gZWxlbWVudFxuICpcbiAqIEBwYXJhbSAge1NWR0VsZW1lbnR9IGVsZW1lbnRcbiAqIEByZXR1cm4ge0VsZW1lbnR9IHRoZSBlbGVtZW50IChmb3IgY2hhaW5pbmcpXG4gKi9cbmZ1bmN0aW9uIGNsZWFyKGVsZW1lbnQpIHtcbiAgdmFyIGNoaWxkO1xuXG4gIHdoaWxlICgoY2hpbGQgPSBlbGVtZW50LmZpcnN0Q2hpbGQpKSB7XG4gICAgZWxlbWVudC5yZW1vdmVDaGlsZChjaGlsZCk7XG4gIH1cblxuICByZXR1cm4gZWxlbWVudDtcbn1cblxuZnVuY3Rpb24gY2xvbmUoZWxlbWVudCkge1xuICByZXR1cm4gZWxlbWVudC5jbG9uZU5vZGUodHJ1ZSk7XG59XG5cbnZhciBucyA9IHtcbiAgc3ZnOiAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnXG59O1xuXG4vKipcbiAqIERPTSBwYXJzaW5nIHV0aWxpdHlcbiAqL1xuXG5cbnZhciBTVkdfU1RBUlQgPSAnPHN2ZyB4bWxucz1cIicgKyBucy5zdmcgKyAnXCInO1xuXG5mdW5jdGlvbiBwYXJzZShzdmcpIHtcblxuICB2YXIgdW53cmFwID0gZmFsc2U7XG5cbiAgLy8gZW5zdXJlIHdlIGltcG9ydCBhIHZhbGlkIHN2ZyBkb2N1bWVudFxuICBpZiAoc3ZnLnN1YnN0cmluZygwLCA0KSA9PT0gJzxzdmcnKSB7XG4gICAgaWYgKHN2Zy5pbmRleE9mKG5zLnN2ZykgPT09IC0xKSB7XG4gICAgICBzdmcgPSBTVkdfU1RBUlQgKyBzdmcuc3Vic3RyaW5nKDQpO1xuICAgIH1cbiAgfSBlbHNlIHtcblxuICAgIC8vIG5hbWVzcGFjZSBzdmdcbiAgICBzdmcgPSBTVkdfU1RBUlQgKyAnPicgKyBzdmcgKyAnPC9zdmc+JztcbiAgICB1bndyYXAgPSB0cnVlO1xuICB9XG5cbiAgdmFyIHBhcnNlZCA9IHBhcnNlRG9jdW1lbnQoc3ZnKTtcblxuICBpZiAoIXVud3JhcCkge1xuICAgIHJldHVybiBwYXJzZWQ7XG4gIH1cblxuICB2YXIgZnJhZ21lbnQgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG5cbiAgdmFyIHBhcmVudCA9IHBhcnNlZC5maXJzdENoaWxkO1xuXG4gIHdoaWxlIChwYXJlbnQuZmlyc3RDaGlsZCkge1xuICAgIGZyYWdtZW50LmFwcGVuZENoaWxkKHBhcmVudC5maXJzdENoaWxkKTtcbiAgfVxuXG4gIHJldHVybiBmcmFnbWVudDtcbn1cblxuZnVuY3Rpb24gcGFyc2VEb2N1bWVudChzdmcpIHtcblxuICB2YXIgcGFyc2VyO1xuXG4gIC8vIHBhcnNlXG4gIHBhcnNlciA9IG5ldyBET01QYXJzZXIoKTtcbiAgcGFyc2VyLmFzeW5jID0gZmFsc2U7XG5cbiAgcmV0dXJuIHBhcnNlci5wYXJzZUZyb21TdHJpbmcoc3ZnLCAndGV4dC94bWwnKTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgdXRpbGl0eSBmb3IgU1ZHIGVsZW1lbnRzXG4gKi9cblxuXG5cbi8qKlxuICogQ3JlYXRlIGEgc3BlY2lmaWMgdHlwZSBmcm9tIG5hbWUgb3IgU1ZHIG1hcmt1cC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSB0aGUgbmFtZSBvciBtYXJrdXAgb2YgdGhlIGVsZW1lbnRcbiAqIEBwYXJhbSB7T2JqZWN0fSBbYXR0cnNdIGF0dHJpYnV0ZXMgdG8gc2V0IG9uIHRoZSBlbGVtZW50XG4gKlxuICogQHJldHVybnMge1NWR0VsZW1lbnR9XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZShuYW1lLCBhdHRycykge1xuICB2YXIgZWxlbWVudDtcblxuICBuYW1lID0gbmFtZS50cmltKCk7XG5cbiAgaWYgKG5hbWUuY2hhckF0KDApID09PSAnPCcpIHtcbiAgICBlbGVtZW50ID0gcGFyc2UobmFtZSkuZmlyc3RDaGlsZDtcbiAgICBlbGVtZW50ID0gZG9jdW1lbnQuaW1wb3J0Tm9kZShlbGVtZW50LCB0cnVlKTtcbiAgfSBlbHNlIHtcbiAgICBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKG5zLnN2ZywgbmFtZSk7XG4gIH1cblxuICBpZiAoYXR0cnMpIHtcbiAgICBhdHRyKGVsZW1lbnQsIGF0dHJzKTtcbiAgfVxuXG4gIHJldHVybiBlbGVtZW50O1xufVxuXG4vKipcbiAqIEV2ZW50cyBoYW5kbGluZyB1dGlsaXR5XG4gKi9cblxuZnVuY3Rpb24gb24obm9kZSwgZXZlbnQsIGxpc3RlbmVyLCB1c2VDYXB0dXJlKSB7XG4gIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgbGlzdGVuZXIsIHVzZUNhcHR1cmUpO1xufVxuXG5mdW5jdGlvbiBvZmYobm9kZSwgZXZlbnQsIGxpc3RlbmVyLCB1c2VDYXB0dXJlKSB7XG4gIG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgbGlzdGVuZXIsIHVzZUNhcHR1cmUpO1xufVxuXG4vKipcbiAqIEdlb21ldHJ5IGhlbHBlcnNcbiAqL1xuXG5cbi8vIGZha2Ugbm9kZSB1c2VkIHRvIGluc3RhbnRpYXRlIHN2ZyBnZW9tZXRyeSBlbGVtZW50c1xudmFyIG5vZGUgPSBudWxsO1xuXG5mdW5jdGlvbiBnZXROb2RlKCkge1xuICBpZiAobm9kZSA9PT0gbnVsbCkge1xuICAgIG5vZGUgPSBjcmVhdGUoJ3N2ZycpO1xuICB9XG5cbiAgcmV0dXJuIG5vZGU7XG59XG5cbmZ1bmN0aW9uIGV4dGVuZChvYmplY3QsIHByb3BzKSB7XG4gIHZhciBpLCBrLCBrZXlzID0gT2JqZWN0LmtleXMocHJvcHMpO1xuXG4gIGZvciAoaSA9IDA7IChrID0ga2V5c1tpXSk7IGkrKykge1xuICAgIG9iamVjdFtrXSA9IHByb3BzW2tdO1xuICB9XG5cbiAgcmV0dXJuIG9iamVjdDtcbn1cblxuXG5mdW5jdGlvbiBjcmVhdGVQb2ludCh4LCB5KSB7XG4gIHZhciBwb2ludCA9IGdldE5vZGUoKS5jcmVhdGVTVkdQb2ludCgpO1xuXG4gIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICBjYXNlIDA6XG4gICAgcmV0dXJuIHBvaW50O1xuICBjYXNlIDI6XG4gICAgeCA9IHtcbiAgICAgIHg6IHgsXG4gICAgICB5OiB5XG4gICAgfTtcbiAgICBicmVhaztcbiAgfVxuXG4gIHJldHVybiBleHRlbmQocG9pbnQsIHgpO1xufVxuXG4vKipcbiAqIENyZWF0ZSBtYXRyaXggdmlhIGFyZ3MuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBjcmVhdGVNYXRyaXgoeyBhOiAxLCBiOiAxIH0pO1xuICogY3JlYXRlTWF0cml4KCk7XG4gKiBjcmVhdGVNYXRyaXgoMSwgMiwgMCwgMCwgMzAsIDIwKTtcbiAqXG4gKiBAcmV0dXJuIHtTVkdNYXRyaXh9XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZU1hdHJpeChhLCBiLCBjLCBkLCBlLCBmKSB7XG4gIHZhciBtYXRyaXggPSBnZXROb2RlKCkuY3JlYXRlU1ZHTWF0cml4KCk7XG5cbiAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gIGNhc2UgMDpcbiAgICByZXR1cm4gbWF0cml4O1xuICBjYXNlIDE6XG4gICAgcmV0dXJuIGV4dGVuZChtYXRyaXgsIGEpO1xuICBjYXNlIDY6XG4gICAgcmV0dXJuIGV4dGVuZChtYXRyaXgsIHtcbiAgICAgIGE6IGEsXG4gICAgICBiOiBiLFxuICAgICAgYzogYyxcbiAgICAgIGQ6IGQsXG4gICAgICBlOiBlLFxuICAgICAgZjogZlxuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVRyYW5zZm9ybShtYXRyaXgpIHtcbiAgaWYgKG1hdHJpeCkge1xuICAgIHJldHVybiBnZXROb2RlKCkuY3JlYXRlU1ZHVHJhbnNmb3JtRnJvbU1hdHJpeChtYXRyaXgpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBnZXROb2RlKCkuY3JlYXRlU1ZHVHJhbnNmb3JtKCk7XG4gIH1cbn1cblxuLyoqXG4gKiBTZXJpYWxpemF0aW9uIHV0aWxcbiAqL1xuXG52YXIgVEVYVF9FTlRJVElFUyA9IC8oWyY8Pl17MX0pL2c7XG52YXIgQVRUUl9FTlRJVElFUyA9IC8oWyY8PlxcblxcclwiXXsxfSkvZztcblxudmFyIEVOVElUWV9SRVBMQUNFTUVOVCA9IHtcbiAgJyYnOiAnJmFtcDsnLFxuICAnPCc6ICcmbHQ7JyxcbiAgJz4nOiAnJmd0OycsXG4gICdcIic6ICdcXCcnXG59O1xuXG5mdW5jdGlvbiBlc2NhcGUoc3RyLCBwYXR0ZXJuKSB7XG5cbiAgZnVuY3Rpb24gcmVwbGFjZUZuKG1hdGNoLCBlbnRpdHkpIHtcbiAgICByZXR1cm4gRU5USVRZX1JFUExBQ0VNRU5UW2VudGl0eV0gfHwgZW50aXR5O1xuICB9XG5cbiAgcmV0dXJuIHN0ci5yZXBsYWNlKHBhdHRlcm4sIHJlcGxhY2VGbik7XG59XG5cbmZ1bmN0aW9uIHNlcmlhbGl6ZShub2RlLCBvdXRwdXQpIHtcblxuICB2YXIgaSwgbGVuLCBhdHRyTWFwLCBhdHRyTm9kZSwgY2hpbGROb2RlcztcblxuICBzd2l0Y2ggKG5vZGUubm9kZVR5cGUpIHtcblxuICAvLyBURVhUXG4gIGNhc2UgMzpcblxuICAgIC8vIHJlcGxhY2Ugc3BlY2lhbCBYTUwgY2hhcmFjdGVyc1xuICAgIG91dHB1dC5wdXNoKGVzY2FwZShub2RlLnRleHRDb250ZW50LCBURVhUX0VOVElUSUVTKSk7XG4gICAgYnJlYWs7XG5cbiAgLy8gRUxFTUVOVFxuICBjYXNlIDE6XG4gICAgb3V0cHV0LnB1c2goJzwnLCBub2RlLnRhZ05hbWUpO1xuXG4gICAgaWYgKG5vZGUuaGFzQXR0cmlidXRlcygpKSB7XG4gICAgICBhdHRyTWFwID0gbm9kZS5hdHRyaWJ1dGVzO1xuICAgICAgZm9yIChpID0gMCwgbGVuID0gYXR0ck1hcC5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgICBhdHRyTm9kZSA9IGF0dHJNYXAuaXRlbShpKTtcbiAgICAgICAgb3V0cHV0LnB1c2goJyAnLCBhdHRyTm9kZS5uYW1lLCAnPVwiJywgZXNjYXBlKGF0dHJOb2RlLnZhbHVlLCBBVFRSX0VOVElUSUVTKSwgJ1wiJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG5vZGUuaGFzQ2hpbGROb2RlcygpKSB7XG4gICAgICBvdXRwdXQucHVzaCgnPicpO1xuICAgICAgY2hpbGROb2RlcyA9IG5vZGUuY2hpbGROb2RlcztcbiAgICAgIGZvciAoaSA9IDAsIGxlbiA9IGNoaWxkTm9kZXMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgc2VyaWFsaXplKGNoaWxkTm9kZXMuaXRlbShpKSwgb3V0cHV0KTtcbiAgICAgIH1cbiAgICAgIG91dHB1dC5wdXNoKCc8LycsIG5vZGUudGFnTmFtZSwgJz4nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0cHV0LnB1c2goJy8+Jyk7XG4gICAgfVxuICAgIGJyZWFrO1xuXG4gIC8vIENPTU1FTlRcbiAgY2FzZSA4OlxuICAgIG91dHB1dC5wdXNoKCc8IS0tJywgZXNjYXBlKG5vZGUubm9kZVZhbHVlLCBURVhUX0VOVElUSUVTKSwgJy0tPicpO1xuICAgIGJyZWFrO1xuXG4gIC8vIENEQVRBXG4gIGNhc2UgNDpcbiAgICBvdXRwdXQucHVzaCgnPCFbQ0RBVEFbJywgbm9kZS5ub2RlVmFsdWUsICddXT4nKTtcbiAgICBicmVhaztcblxuICBkZWZhdWx0OlxuICAgIHRocm93IG5ldyBFcnJvcigndW5hYmxlIHRvIGhhbmRsZSBub2RlICcgKyBub2RlLm5vZGVUeXBlKTtcbiAgfVxuXG4gIHJldHVybiBvdXRwdXQ7XG59XG5cbi8qKlxuICogaW5uZXJIVE1MIGxpa2UgZnVuY3Rpb25hbGl0eSBmb3IgU1ZHIGVsZW1lbnRzLlxuICogYmFzZWQgb24gaW5uZXJTVkcgKGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvaW5uZXJzdmcpXG4gKi9cblxuXG5cbmZ1bmN0aW9uIHNldChlbGVtZW50LCBzdmcpIHtcblxuICB2YXIgcGFyc2VkID0gcGFyc2Uoc3ZnKTtcblxuICAvLyBjbGVhciBlbGVtZW50IGNvbnRlbnRzXG4gIGNsZWFyKGVsZW1lbnQpO1xuXG4gIGlmICghc3ZnKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKCFpc0ZyYWdtZW50KHBhcnNlZCkpIHtcblxuICAgIC8vIGV4dHJhY3QgPHN2Zz4gZnJvbSBwYXJzZWQgZG9jdW1lbnRcbiAgICBwYXJzZWQgPSBwYXJzZWQuZG9jdW1lbnRFbGVtZW50O1xuICB9XG5cbiAgdmFyIG5vZGVzID0gc2xpY2UocGFyc2VkLmNoaWxkTm9kZXMpO1xuXG4gIC8vIGltcG9ydCArIGFwcGVuZCBlYWNoIG5vZGVcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgIGFwcGVuZFRvKG5vZGVzW2ldLCBlbGVtZW50KTtcbiAgfVxuXG59XG5cbmZ1bmN0aW9uIGdldChlbGVtZW50KSB7XG4gIHZhciBjaGlsZCA9IGVsZW1lbnQuZmlyc3RDaGlsZCxcbiAgICAgIG91dHB1dCA9IFtdO1xuXG4gIHdoaWxlIChjaGlsZCkge1xuICAgIHNlcmlhbGl6ZShjaGlsZCwgb3V0cHV0KTtcbiAgICBjaGlsZCA9IGNoaWxkLm5leHRTaWJsaW5nO1xuICB9XG5cbiAgcmV0dXJuIG91dHB1dC5qb2luKCcnKTtcbn1cblxuZnVuY3Rpb24gaXNGcmFnbWVudChub2RlKSB7XG4gIHJldHVybiBub2RlLm5vZGVOYW1lID09PSAnI2RvY3VtZW50LWZyYWdtZW50Jztcbn1cblxuZnVuY3Rpb24gaW5uZXJTVkcoZWxlbWVudCwgc3ZnKSB7XG5cbiAgaWYgKHN2ZyAhPT0gdW5kZWZpbmVkKSB7XG5cbiAgICB0cnkge1xuICAgICAgc2V0KGVsZW1lbnQsIHN2Zyk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdlcnJvciBwYXJzaW5nIFNWRzogJyArIGUubWVzc2FnZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGdldChlbGVtZW50KTtcbiAgfVxufVxuXG5cbmZ1bmN0aW9uIHNsaWNlKGFycikge1xuICByZXR1cm4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJyKTtcbn1cblxuLyoqXG4gKiBTZWxlY3Rpb24gdXRpbGl0aWVzXG4gKi9cblxuZnVuY3Rpb24gc2VsZWN0KG5vZGUsIHNlbGVjdG9yKSB7XG4gIHJldHVybiBub2RlLnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpO1xufVxuXG5mdW5jdGlvbiBzZWxlY3RBbGwobm9kZSwgc2VsZWN0b3IpIHtcbiAgdmFyIG5vZGVzID0gbm9kZS5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKTtcblxuICByZXR1cm4gW10ubWFwLmNhbGwobm9kZXMsIGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfSk7XG59XG5cbi8qKlxuICogcHJlcGVuZFRvIHV0aWxpdHlcbiAqL1xuXG5cbi8qKlxuICogUHJlcGVuZCBhIG5vZGUgdG8gYSB0YXJnZXQgZWxlbWVudCBhbmQgcmV0dXJuIHRoZSBwcmVwZW5kZWQgbm9kZS5cbiAqXG4gKiBAcGFyYW0gIHtTVkdFbGVtZW50fSBub2RlXG4gKiBAcGFyYW0gIHtTVkdFbGVtZW50fSB0YXJnZXRcbiAqXG4gKiBAcmV0dXJuIHtTVkdFbGVtZW50fSB0aGUgcHJlcGVuZGVkIG5vZGVcbiAqL1xuZnVuY3Rpb24gcHJlcGVuZFRvKG5vZGUsIHRhcmdldCkge1xuICByZXR1cm4gdGFyZ2V0Lmluc2VydEJlZm9yZShlbnN1cmVJbXBvcnRlZChub2RlLCB0YXJnZXQpLCB0YXJnZXQuZmlyc3RDaGlsZCB8fCBudWxsKTtcbn1cblxuLyoqXG4gKiBwcmVwZW5kIHV0aWxpdHlcbiAqL1xuXG5cbi8qKlxuICogUHJlcGVuZCBhIG5vZGUgdG8gYSB0YXJnZXQgZWxlbWVudFxuICpcbiAqIEBwYXJhbSAge1NWR0VsZW1lbnR9IHRhcmdldFxuICogQHBhcmFtICB7U1ZHRWxlbWVudH0gbm9kZVxuICpcbiAqIEByZXR1cm4ge1NWR0VsZW1lbnR9IHRoZSB0YXJnZXQgZWxlbWVudFxuICovXG5mdW5jdGlvbiBwcmVwZW5kKHRhcmdldCwgbm9kZSkge1xuICBwcmVwZW5kVG8obm9kZSwgdGFyZ2V0KTtcbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlKGVsZW1lbnQpIHtcbiAgdmFyIHBhcmVudCA9IGVsZW1lbnQucGFyZW50Tm9kZTtcblxuICBpZiAocGFyZW50KSB7XG4gICAgcGFyZW50LnJlbW92ZUNoaWxkKGVsZW1lbnQpO1xuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnQ7XG59XG5cbi8qKlxuICogUmVwbGFjZSB1dGlsaXR5XG4gKi9cblxuXG5mdW5jdGlvbiByZXBsYWNlKGVsZW1lbnQsIHJlcGxhY2VtZW50KSB7XG4gIGVsZW1lbnQucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQoZW5zdXJlSW1wb3J0ZWQocmVwbGFjZW1lbnQsIGVsZW1lbnQpLCBlbGVtZW50KTtcbiAgcmV0dXJuIHJlcGxhY2VtZW50O1xufVxuXG4vKipcbiAqIHRyYW5zZm9ybSBhY2Nlc3NvciB1dGlsaXR5XG4gKi9cblxuZnVuY3Rpb24gd3JhcE1hdHJpeCh0cmFuc2Zvcm1MaXN0LCB0cmFuc2Zvcm0pIHtcbiAgaWYgKHRyYW5zZm9ybSBpbnN0YW5jZW9mIFNWR01hdHJpeCkge1xuICAgIHJldHVybiB0cmFuc2Zvcm1MaXN0LmNyZWF0ZVNWR1RyYW5zZm9ybUZyb21NYXRyaXgodHJhbnNmb3JtKTtcbiAgfVxuXG4gIHJldHVybiB0cmFuc2Zvcm07XG59XG5cblxuZnVuY3Rpb24gc2V0VHJhbnNmb3Jtcyh0cmFuc2Zvcm1MaXN0LCB0cmFuc2Zvcm1zKSB7XG4gIHZhciBpLCB0O1xuXG4gIHRyYW5zZm9ybUxpc3QuY2xlYXIoKTtcblxuICBmb3IgKGkgPSAwOyAodCA9IHRyYW5zZm9ybXNbaV0pOyBpKyspIHtcbiAgICB0cmFuc2Zvcm1MaXN0LmFwcGVuZEl0ZW0od3JhcE1hdHJpeCh0cmFuc2Zvcm1MaXN0LCB0KSk7XG4gIH1cbn1cblxuLyoqXG4gKiBHZXQgb3Igc2V0IHRoZSB0cmFuc2Zvcm1zIG9uIHRoZSBnaXZlbiBub2RlLlxuICpcbiAqIEBwYXJhbSB7U1ZHRWxlbWVudH0gbm9kZVxuICogQHBhcmFtICB7U1ZHVHJhbnNmb3JtfFNWR01hdHJpeHxBcnJheTxTVkdUcmFuc2Zvcm18U1ZHTWF0cml4Pn0gW3RyYW5zZm9ybXNdXG4gKlxuICogQHJldHVybiB7U1ZHVHJhbnNmb3JtfSB0aGUgY29uc29saWRhdGVkIHRyYW5zZm9ybVxuICovXG5mdW5jdGlvbiB0cmFuc2Zvcm0obm9kZSwgdHJhbnNmb3Jtcykge1xuICB2YXIgdHJhbnNmb3JtTGlzdCA9IG5vZGUudHJhbnNmb3JtLmJhc2VWYWw7XG5cbiAgaWYgKHRyYW5zZm9ybXMpIHtcblxuICAgIGlmICghQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1zKSkge1xuICAgICAgdHJhbnNmb3JtcyA9IFsgdHJhbnNmb3JtcyBdO1xuICAgIH1cblxuICAgIHNldFRyYW5zZm9ybXModHJhbnNmb3JtTGlzdCwgdHJhbnNmb3Jtcyk7XG4gIH1cblxuICByZXR1cm4gdHJhbnNmb3JtTGlzdC5jb25zb2xpZGF0ZSgpO1xufVxuXG5leHBvcnQgeyBhcHBlbmQsIGFwcGVuZFRvLCBhdHRyLCBjbGFzc2VzLCBjbGVhciwgY2xvbmUsIGNyZWF0ZSwgY3JlYXRlTWF0cml4LCBjcmVhdGVQb2ludCwgY3JlYXRlVHJhbnNmb3JtLCBpbm5lclNWRywgb2ZmLCBvbiwgcHJlcGVuZCwgcHJlcGVuZFRvLCByZW1vdmUsIHJlcGxhY2UsIHNlbGVjdCwgc2VsZWN0QWxsLCB0cmFuc2Zvcm0gfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/tiny-svg/dist/index.esm.js\n");

/***/ })

};
;